{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nebula introduction","text":"<p>The project is separated into four main parts: \u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306f\u4e3b\u3068\u306a\u308b 4 \u3064\u306e\u30d1\u30fc\u30c8\u306b\u5206\u304b\u308c\u3066\u3044\u308b\uff1a Lidar \u30c9\u30e9\u30a4\u30d0\u3001ROS \u30e9\u30c3\u30d1\u30fc\u3001HWI \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u3060\u3002</p> <ul> <li>Common: <code>nebula_common</code>. This packages contains the structures, data types, calibration and configuration definitions used among all the packages.</li> <li>Drivers: <code>nebula_decoders</code>. The Drivers take care of all the data parsing and conversion. Lidar \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u5168\u3066\u306e\u30bb\u30f3\u30b5\u901a\u4fe1\u3068\u30c7\u30fc\u30bf\u30d1\u30fc\u30b7\u30f3\u30b0\u3092\u7ba1\u7406\u3057\u3066\u3044\u308b\u3002</li> <li>ROS Nodes Wrappers: <code>nebula_ros</code>, The ROSWrappers are a lightweight layer responsible for the data conversion between the LidarDriver point cloud and the corresponding ROS counterparts. The ROSWrapper also provides methods for configuration and the obtention of the status information of the Lidar. ROS \u30e9\u30c3\u30d1\u30fc\u306f\u3001Lidar \u30c9\u30e9\u30a4\u30d0\u70b9\u7fa4\u3068\u5bfe\u5fdc\u3059\u308b ROS \u306e\u30ab\u30a6\u30f3\u30bf\u30fc\u30d1\u30fc\u30c4\u306e\u30c7\u30fc\u30bf\u5909\u63db\u3092\u638c\u308b\u8efd\u91cf\u306e\u30ec\u30a4\u30e4\u3067\u3042\u308b\u3002 ROS \u30e9\u30c3\u30d1\u30fc\u306f\u3001\u69cb\u6210\u65b9\u6cd5\u3001Lidar \u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u60c5\u5831\u53d6\u5f97\u306e\u65b9\u6cd5\u3092\u63d0\u4f9b\u3057\u3066\u3044\u308b\u3002</li> <li>HWInterface: <code>nebula_hw_interfaces</code>. The HWInterface offers an abstraction layer between the parser and the sensor communication. HW \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306f\u3001\u30d1\u30fc\u30b5\u3068\u30bb\u30f3\u30b5\u9593\u306e\u62bd\u8c61\u5316\u30ec\u30a4\u30e4\u3092\u63d0\u4f9b\u3057\u3066\u3044\u308b\u3002</li> </ul>"},{"location":"#nebula-common","title":"Nebula Common","text":"<p>The Nebula common package contains structure definition such as configuration, calibration, point types. It also contains other common status strings and conversions used among all the packages.</p>"},{"location":"#point-types","title":"Point Types","text":"<p>Nebula supports three point cloud output types. However, it can easily be extended to support other custom point cloud types.</p> <p>These definitions can be found in the <code>nebula_common/include/point_types.hpp</code>.</p>"},{"location":"#pointxyzir","title":"PointXYZIR","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration."},{"location":"#pointxyzicaetr","title":"PointXYZICAETR","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>channel</code> <code>uint8</code> Contains the laser channel id. <code>azimuth</code> <code>float</code> <code>rad</code> Contains the azimuth of the current point. <code>elevation</code> <code>float</code> <code>rad</code> Contains the elevation of the current point. <code>timestamp</code> <code>float</code> <code>ns</code> Contains the relative time to the triggered scan time. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration."},{"location":"#pointxyzicatr","title":"PointXYZICATR","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>channel</code> <code>uint8</code> Contains the laser channel id. <code>azimuth</code> <code>float</code> <code>degrees</code> Contains the azimuth of the current point. <code>timestamp</code> <code>float</code> <code>ns</code> Contains the relative time to the triggered scan time. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration."},{"location":"#pointxyziradt","title":"PointXYZIRADT","text":"Field Type Units Description <code>x</code> <code>float</code> <code>m</code> Contains the abscissa member of the point in cartesian coordinates. <code>y</code> <code>float</code> <code>m</code> Contains the ordinate member of the point in cartesian coordinates. <code>z</code> <code>float</code> <code>m</code> Contains the applicate member of the point in cartesian coordinates. <code>intensity</code> <code>uint8</code> Contains the laser energy return value as reported by the sensor. <code>return type</code> <code>uint8</code> Contains the lase return type according to the sensor configuration. <code>azimuth</code> <code>float</code> <code>degrees</code> Contains the azimuth of the current point. <code>distance</code> <code>float</code> <code>m</code> Contains the distance from the sensor origin to this echo on the XY plane. <code>timestamp</code> <code>float</code> <code>ns</code> Contains the relative time to the triggered scan time."},{"location":"add_sensor/","title":"How to add your sensor","text":"<ol> <li>Add your sensor to the <code>SensorModel</code> enumeration class located in the <code>nebula_common.hpp</code> header inside the <code>nebula_common</code> package.</li> <li>Add your sensor model string to the <code>SensorModelFromString</code> method in the <code>nebula_common.hpp</code> header inside the <code>nebula_common</code> package.</li> <li>Write the sensor decoder for your sensor. This class is in charge of converting raw packets to point clouds. This class should implement the abstract class defined in <code>nebula_driver_base.hpp</code> inside the <code>nebula_decoders</code> package. Add methods as the sensor requires.</li> <li>Write the sensor hardware interface. This class is in charge of obtaining raw packets from the sensor using the <code>transport_drivers</code> library, accumulating them to form a scan, and making them available for consumption through callbacks. This class should implement the <code>nebula_hw_interface_base.hpp</code> inside the <code>nebula_hw_interfaces</code> package. Add methods as the sensor requires.</li> <li>Write the ROS wrappers. The ROS wrappers use the sensor libraries to obtain raw data, decode it and convert it to PointCloud2 ROS messages. The Decoder wrapper receives the configuration and calibration data from files and sends them as structures to the decoder and the hw_interface.</li> </ol>"},{"location":"design/","title":"Nebula requirements","text":"<p>The driver follows the following functional requirements: \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u6b21\u306e\u6a5f\u80fd\u7684\u306a\u8981\u6c42\u306b\u5fdc\u3048\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002</p>"},{"location":"design/#hardware-interface-independent","title":"Hardware interface independent","text":"<p>The data acquisition and communication with the sensor must not be bound to a specific hardware interface. \u30bb\u30f3\u30b5\u3067\u306e\u30c7\u30fc\u30bf\u53d6\u5f97\u3068\u901a\u4fe1\u306f\u3001\u7279\u5b9a\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u306b\u7e1b\u3089\u308c\u3066\u306f\u306a\u3089\u306a\u3044\u3002</p>"},{"location":"design/#why","title":"Why?","text":"<p>Writing a general-purpose driver independent of the interface will support different types of hardware interfaces. \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u4f9d\u5b58\u3057\u306a\u3044\u6c4e\u7528\u30c9\u30e9\u30a4\u30d0\u3092\u66f8\u304f\u3053\u3068\u3067\u3001\u7570\u306a\u3063\u305f\u30bf\u30a4\u30d7\u306e\u30cf\u30fc\u30c9\u30a6\u30a7\u30a2\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u306b\u5bfe\u5fdc\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"design/#sensor-control","title":"Sensor Control","text":"<p>The driver should obtain, set, and confirm the desired sensor configuration at launch, i.e., scan frequency, synchronization methods, etc. \u30c9\u30e9\u30a4\u30d0\u306f\u8d77\u52d5\u6642\u306b\u3001\u671b\u307e\u3057\u3044\u30bb\u30f3\u30b5\u8a2d\u5b9a\uff08\u30b9\u30ad\u30e3\u30f3\u5468\u6ce2\u6570\u3001\u540c\u671f\u65b9\u6cd5\u7b49\uff09\u3092\u53d6\u5f97\u3001\u8a2d\u5b9a\u3001\u78ba\u8a8d\u3067\u304d\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002</p>"},{"location":"design/#why_1","title":"Why?","text":"<p>The sensor control will ensure that the sensor works in the expected mode as it was initially intended. \u3053\u308c\u306b\u3088\u3063\u3066\u3001\u30bb\u30f3\u30b5\u304c\u5f53\u521d\u3088\u308a\u610f\u56f3\u3057\u3066\u3044\u305f\u30e2\u30fc\u30c9\u3067\u52d5\u3044\u3066\u3044\u308b\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u308b\u3002</p>"},{"location":"design/#configurable-output-cloud","title":"Configurable output cloud","text":"<p>The ROS wrapper should be able to define the desired output format of the point cloud. i.e., customize the fields to be contained in the final output cloud. ROS \u30e9\u30c3\u30d1\u30fc\u306f\u70b9\u7fa4\u306e\u671b\u307e\u3057\u3044\u51fa\u529b\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3067\u5b9a\u7fa9\u3067\u304d\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\uff08\u6700\u7d42\u7684\u306a\u51fa\u529b\u30af\u30e9\u30a6\u30c9\u306b\u542b\u307e\u308c\u308b\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u30ab\u30b9\u30bf\u30de\u30a4\u30ba\u3067\u304d\u308b\uff09 In addition, it should be able to generate the corresponding 2D range image for the output point cloud.</p> <p>\u3055\u3089\u306b\u3001\u51fa\u529b\u3055\u308c\u305f\u70b9\u7fa4\u3092\u5bfe\u5fdc\u3059\u308b\u4e8c\u6b21\u5143\u30ec\u30f3\u30b8\u753b\u50cf\u306b\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002 If the sensor allows it, have an option to add a minimum and maximum range distance as an option. For instance, if the user launches the driver with a range limit set to 0, the driver will not perform any filtering. \u30bb\u30f3\u30b5\u304c\u8a31\u53ef\u3057\u3066\u3044\u308b\u5834\u5408\u306f\u3001\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u3057\u3066\u6700\u5c0f\u5024\u3068\u6700\u5927\u5024\u306e\u30ec\u30f3\u30b8\u8ddd\u96e2\u3092\u8ffd\u52a0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4f8b\u3048\u3070\u3001\u30e6\u30fc\u30b6\u30fc\u304c\u7bc4\u56f2\u5236\u9650\u3092 0 \u306b\u8a2d\u5b9a\u3057\u3066\u30c9\u30e9\u30a4\u30d0\u30fc\u3092\u8d77\u52d5\u3057\u305f\u5834\u5408\u3001\u30c9\u30e9\u30a4\u30d0\u306f\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3092\u884c\u308f\u306a\u3044\u3002 The driver should have an option to define if the output cloud is of a fixed size or dynamic size. If a fixed size is selected, the output cloud must include NaN values for those lasers without any return. If a dynamic size is selected, the lasers with no valid returns are to be removed. \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u51fa\u529b\u30af\u30e9\u30a6\u30c9\u3092\u56fa\u5b9a\u3055\u308c\u305f\u30b5\u30a4\u30ba\u304b\u3001\u3082\u3057\u304f\u306f\u30c0\u30a4\u30ca\u30df\u30c3\u30af\u30b5\u30a4\u30ba\u306b\u3059\u308b\u304b\u3092\u5b9a\u7fa9\u3059\u308b\u30aa\u30d7\u30b7\u30e7\u30f3\u304c\u5fc5\u8981\u3067\u3042\u308b\u3002\u56fa\u5b9a\u3055\u308c\u305f\u30b5\u30a4\u30ba\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u3001\u51fa\u529b\u30af\u30e9\u30a6\u30c9\u306f\u3001\u30ea\u30bf\u30fc\u30f3\u306e\u306a\u3044\u30ec\u30fc\u30b6\u306e NaN \u5024\u3092\u542b\u307e\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\u30c0\u30a4\u30ca\u30df\u30c3\u30af\u30b5\u30a4\u30ba\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u3001\u30ea\u30bf\u30fc\u30f3\u306e\u306a\u3044\u30ec\u30fc\u30b6\u306f\u524a\u9664\u3055\u308c\u308b\u3002 Default behavior: Dynamic, remove invalid laser returns (NaN). \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u52d5\u4f5c\uff1a\u30c0\u30a4\u30ca\u30df\u30c3\u30af\u3001\u7121\u52b9\u306a\u30ec\u30fc\u30b6\u30ea\u30bf\u30fc\u30f3\u3092\u524a\u9664\u3002\uff08NaN)</p>"},{"location":"design/#why_2","title":"Why?","text":"<p>The configurable output will allow the generation of the point cloud according to the expected use case application. \u3053\u308c\u306b\u3088\u3063\u3066\u3001\u4e88\u5b9a\u3057\u305f\u30e6\u30fc\u30b9\u30b1\u30fc\u30b9\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308a\u5fc5\u8981\u306a\u51fa\u529b\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"design/#sensor-metadata","title":"Sensor Metadata","text":"<p>The driver should include the following metadata for each generated point cloud: \u30c9\u30e9\u30a4\u30d0\u306f\u3001\u751f\u6210\u3055\u308c\u305f\u70b9\u7fa4\u305d\u308c\u305e\u308c\u306b\u3001\u6b21\u306e\u30e1\u30bf\u30c7\u30fc\u30bf\u304c\u542b\u307e\u308c\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\uff1a</p>"},{"location":"design/#calibration-data","title":"Calibration data \u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30c7\u30fc\u30bf","text":"<p>Contains the sensor calibration parameters used to generate the point cloud from the raw data. \u751f\u30c7\u30fc\u30bf\u304b\u3089\u70b9\u7fa4\u3092\u751f\u6210\u3059\u308b\u306e\u306b\u4f7f\u7528\u3057\u305f\u30bb\u30f3\u30b5\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u30d1\u30e9\u30e1\u30fc\u30bf</p>"},{"location":"design/#sensor-settings","title":"Sensor settings \u30bb\u30f3\u30b5\u8a2d\u5b9a","text":"<p>The configuration mode in which the sensor is being executed: \u30bb\u30f3\u30b5\u304c\u5b9f\u884c\u3055\u308c\u305f\u8a2d\u5b9a\u30e2\u30fc\u30c9</p>"},{"location":"design/#synchronization-mode-ptp-ppsnmea-ptp-ppsnmea","title":"Synchronization mode (PTP, PPS/NMEA)\u3000\u540c\u671f\u30e2\u30fc\u30c9(PTP, PPS/NMEA)","text":"<p>Sensor Type \u30bb\u30f3\u30b5\u30bf\u30a4\u30d7 Sensor Model \u30bb\u30f3\u30b5\u30e2\u30c7\u30eb Scan frequency \u30b9\u30ad\u30e3\u30f3\u5468\u6ce2\u6570</p>"},{"location":"design/#why_3","title":"Why?","text":"<p>The processed point cloud or the raw data does not always contain the state on which the sensor was run. Moreover, having this information at hand will help identify, classify and understand the situation of the recorded data. \u51e6\u7406\u3057\u305f\u70b9\u7fa4\u3001\u3064\u307e\u308a\u751f\u30c7\u30fc\u30bf\u306f\u3001\u5e38\u306b\u30bb\u30f3\u30b5\u304c\u4f5c\u52d5\u3057\u305f\u72b6\u614b\u3092\u542b\u3093\u3067\u3044\u308b\u3068\u306f\u9650\u3089\u306a\u3044\u3002\u624b\u5143\u306b\u60c5\u5831\u304c\u3042\u308b\u3053\u3068\u306f\u3001\u8a18\u9332\u30c7\u30fc\u30bf\u306e\u72b6\u6cc1\u3092\u7d20\u65e9\u304f\u628a\u63e1\u3057\u3001\u5206\u985e\u3057\u3001\u7406\u89e3\u3059\u308b\u3053\u3068\u306e\u52a9\u3051\u306b\u306a\u308b\u3002</p>"},{"location":"design/#multi-echo-compatible","title":"Multi echo compatible","text":"<p>The sensor should consider the possibility of the future inclusion of more than two echos. \u30bb\u30f3\u30b5\u306f\uff12\u3064\u4ee5\u4e0a\u306e\u30a8\u30b3\u30fc\u304c\u5c06\u6765\u7684\u306b\u542b\u307e\u308c\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u3053\u3068\u3092\u8003\u616e\u3059\u3079\u304d\u3067\u3042\u308b\u3002</p>"},{"location":"design/#why_4","title":"Why?","text":"<p>Multi-echo support will help to future-proof the driver according to new features included or used in new sensors. In addition, multiple echo support has been proven to improve sensor resilience against weather conditions such as rain, fog, and snow. \u3053\u308c\u306b\u3088\u3063\u3066\u3001\u65b0\u3057\u3044\u30bb\u30f3\u30b5\u306b\u642d\u8f09\u3055\u308c\u305f\u3001\u3082\u3057\u304f\u306f\u3001\u958b\u767a\u3055\u308c\u305f\u65b0\u6a5f\u80fd\u306b\u3088\u3063\u3066\u3001\u30c9\u30e9\u30a4\u30d0\u306e\u5c06\u6765\u6027\u3092\u9ad8\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u8907\u6570\u306e\u30a8\u30b3\u30fc\u306b\u5bfe\u5fdc\u3059\u308b\u3053\u3068\u3067\u3001\u96e8\u3084\u9727\u3001\u96ea\u306a\u3069\u306e\u5929\u5019\u6761\u4ef6\u306b\u5bfe\u3057\u3066\u3001\u30bb\u30f3\u30b5\u306e\u56de\u5fa9\u529b\u304c\u6539\u5584\u3055\u308c\u308b\u3053\u3068\u304c\u8a3c\u660e\u3055\u308c\u3066\u3044\u308b\u3002</p>"},{"location":"design/#ros-independent","title":"ROS independent","text":"<p>The objects used inside the driver must be ROS independent. \u30c9\u30e9\u30a4\u30d0\u5185\u306b\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b API \u7b49\u306e\u5bfe\u8c61\u7269\u306f\u3001ROS \u306b\u4f9d\u5b58\u3057\u3066\u306f\u306a\u3089\u306a\u3044\u3002</p>"},{"location":"design/#why_5","title":"Why?","text":"<p>The third-party dependency reduction allows any software to be quickly updated without waiting for external dependencies to be updated. \u3053\u308c\u306b\u3088\u308a\u3001\u3069\u3093\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3067\u3082\u3001\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u306e\u305f\u3081\u306e\u5916\u90e8\u4f9d\u5b58\u3092\u5f85\u3064\u5fc5\u8981\u304c\u306a\u304f\u3001\u7d20\u65e9\u304f\u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"design/#offline-ready","title":"Offline ready","text":"<p>The data parser API inside the driver should not be designed to expect the data to be received in a real-time stream. \u30c9\u30e9\u30a4\u30d0\u5185\u306e\u30c7\u30fc\u30bf\u30d1\u30fc\u30b5 API \u306f\u3001\u30c7\u30fc\u30bf\u3092\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u30b9\u30c8\u30ea\u30fc\u30e0\u3067\u53d7\u3051\u53d6\u308b\u3088\u3046\u306b\u8a2d\u8a08\u3055\u308c\u308b\u3079\u304d\u3067\u306f\u306a\u3044\u3002</p>"},{"location":"design/#why_6","title":"Why?","text":"<p>Offline processing will help process the data faster than in real-time. \u3053\u308c\u306b\u3088\u308a\u3001\u30c7\u30fc\u30bf\u304c\u30bb\u30f3\u30b5\u306e\u4ee3\u308f\u308a\u306b\u30ed\u30b0\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u767a\u4fe1\u3055\u308c\u305f\u6642\u306b\u30c7\u30fc\u30bf\u51e6\u7406\u3092\u30ea\u30a2\u30eb\u30bf\u30a4\u30e0\u3088\u308a\u901f\u304f\u51e6\u7406\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"nebula_common/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>struct HesaiStatus Status definition for Hesai. </li> <li>struct Status Status definition. </li> <li>struct VelodyneStatus Status definition for Velodyne. </li> <li>namespace drivers <ul> <li>struct CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) </li> <li>struct HesaiCalibrationConfiguration struct for Hesai calibration configuration </li> <li>struct HesaiCorrection struct for Hesai correction configuration (for AT) </li> <li>struct HesaiSensorConfiguration struct for Hesai sensor configuration </li> <li>struct PointField not used? </li> <li>struct PointXYZICATR </li> <li>struct PointXYZIR </li> <li>struct PointXYZIRADT </li> <li>struct PointXYZIRCAEDT </li> <li>struct SensorConfigurationBase Base struct for Sensor configuration. </li> <li>class VelodyneCalibration Calibration information for the entire device. </li> <li>struct VelodyneCalibrationConfiguration struct for Velodyne calibration configuration </li> <li>struct VelodyneLaserCorrection </li> <li>struct VelodyneSensorConfiguration struct for Velodyne sensor configuration </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_common/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_common <ul> <li>dir include <ul> <li>dir nebula_common <ul> <li>file nebula_common.hpp </li> <li>dir hesai <ul> <li>file hesai_common.hpp </li> <li>file hesai_status.hpp </li> </ul> </li> <li>dir velodyne <ul> <li>file velodyne_calibration_decoder.hpp </li> <li>file velodyne_common.hpp </li> <li>file velodyne_status.hpp </li> </ul> </li> <li>file nebula_status.hpp </li> <li>file point_types.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_common/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_common/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace drivers"},{"location":"nebula_common/namespacenebula/#classes","title":"Classes","text":"Type Name struct HesaiStatus Status definition for Hesai. struct Status Status definition. struct VelodyneStatus Status definition for Velodyne. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/","title":"Struct nebula::HesaiStatus","text":"<p>ClassList &gt; nebula &gt; HesaiStatus</p> <p>Status definition for Hesai.</p> <ul> <li><code>#include &lt;hesai_status.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::Status</p>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-types","title":"Public Types","text":"Type Name enum HesaiType"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-types-inherited-from-nebulastatus","title":"Public Types inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum Type"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-attributes","title":"Public Attributes","text":"Type Name enum nebula::HesaiStatus::HesaiType _hesai_type"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-attributes-inherited-from-nebulastatus","title":"Public Attributes inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum nebula::Status::Type _type"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-functions","title":"Public Functions","text":"Type Name HesaiStatus ()  HesaiStatus (Type v)  HesaiStatus (HesaiType v)  HesaiStatus (int type)  Status ()  Status (Type v)  Status (int type)  int type () const"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-functions-inherited-from-nebulastatus","title":"Public Functions inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name Status ()  Status (Type v)  Status (int type)  Type type () const"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#enum-hesaitype","title":"enum HesaiType","text":"<pre><code>enum nebula::HesaiStatus::HesaiType {\nINVALID_RPM_ERROR = Type_end_of_Status + 1,\nINVALID_FOV_ERROR,\nINVALID_RETURN_MODE_ERROR,\nType_end_of_Status = INVALID_RPM_ERROR\n};\n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#variable-_hesai_type","title":"variable _hesai_type","text":"<pre><code>enum nebula::HesaiStatus::HesaiType nebula::HesaiStatus::_hesai_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-14","title":"function HesaiStatus [1/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus () </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-24","title":"function HesaiStatus [2/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus (\nType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-34","title":"function HesaiStatus [3/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus (\nHesaiType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-hesaistatus-44","title":"function HesaiStatus [4/4]","text":"<pre><code>inline nebula::HesaiStatus::HesaiStatus (\nint type\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-status-13","title":"function Status [1/3]","text":"<pre><code>inline nebula::HesaiStatus::Status () </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-status-23","title":"function Status [2/3]","text":"<pre><code>inline nebula::HesaiStatus::Status (\nType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-status-33","title":"function Status [3/3]","text":"<pre><code>inline nebula::HesaiStatus::Status (\nint type\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#function-type","title":"function type","text":"<pre><code>inline int nebula::HesaiStatus::type () const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool nebula::HesaiStatus::operator!= (\nconst HesaiStatus &amp; L,\nconst HesaiStatus &amp; R\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<p>Convert Status enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::HesaiStatus::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiStatus const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/structnebula_1_1HesaiStatus/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline bool nebula::HesaiStatus::operator== (\nconst HesaiStatus &amp; L,\nconst HesaiStatus &amp; R\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_status.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1Status/","title":"Struct nebula::Status","text":"<p>ClassList &gt; nebula &gt; Status</p> <p>Status definition.</p> <ul> <li><code>#include &lt;nebula_status.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::HesaiStatus,  nebula::VelodyneStatus</p>"},{"location":"nebula_common/structnebula_1_1Status/#public-types","title":"Public Types","text":"Type Name enum Type"},{"location":"nebula_common/structnebula_1_1Status/#public-attributes","title":"Public Attributes","text":"Type Name enum nebula::Status::Type _type"},{"location":"nebula_common/structnebula_1_1Status/#public-functions","title":"Public Functions","text":"Type Name Status ()  Status (Type v)  Status (int type)  Type type () const"},{"location":"nebula_common/structnebula_1_1Status/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#enum-type","title":"enum Type","text":"<pre><code>enum nebula::Status::Type {\nOK = 0,\nUDP_CONNECTION_ERROR,\nSENSOR_CONFIG_ERROR,\nINVALID_SENSOR_MODEL,\nINVALID_ECHO_MODE,\nNOT_IMPLEMENTED,\nNOT_INITIALIZED,\nINVALID_CALIBRATION_FILE,\nCANNOT_SAVE_FILE,\nHTTP_CONNECTION_ERROR,\nWAITING_FOR_SENSOR_RESPONSE,\nERROR_1,\nType_end_of_Status = ERROR_1\n};\n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#variable-_type","title":"variable _type","text":"<pre><code>enum nebula::Status::Type nebula::Status::_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#function-status-13","title":"function Status [1/3]","text":"<pre><code>inline nebula::Status::Status () </code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#function-status-23","title":"function Status [2/3]","text":"<pre><code>inline nebula::Status::Status (\nType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#function-status-33","title":"function Status [3/3]","text":"<pre><code>inline nebula::Status::Status (\nint type\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#function-type","title":"function type","text":"<pre><code>inline Type nebula::Status::type () const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_common/structnebula_1_1Status/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool nebula::Status::operator!= (\nconst Status &amp; L,\nconst Status &amp; R\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1Status/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<p>Convert Status enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::Status::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::Status const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/structnebula_1_1Status/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline bool nebula::Status::operator== (\nconst Status &amp; L,\nconst Status &amp; R\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_status.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/","title":"Struct nebula::VelodyneStatus","text":"<p>ClassList &gt; nebula &gt; VelodyneStatus</p> <p>Status definition for Velodyne.</p> <ul> <li><code>#include &lt;velodyne_status.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::Status</p>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-types","title":"Public Types","text":"Type Name enum VelodyneType"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-types-inherited-from-nebulastatus","title":"Public Types inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum Type"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-attributes","title":"Public Attributes","text":"Type Name enum nebula::VelodyneStatus::VelodyneType _velo_type"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-attributes-inherited-from-nebulastatus","title":"Public Attributes inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name enum nebula::Status::Type _type"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-functions","title":"Public Functions","text":"Type Name Status ()  Status (Type v)  Status (int type)  VelodyneStatus ()  VelodyneStatus (Type v)  VelodyneStatus (VelodyneType v)  VelodyneStatus (int type)  int type () const"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-functions-inherited-from-nebulastatus","title":"Public Functions inherited from nebula::Status","text":"<p>See nebula::Status</p> Type Name Status ()  Status (Type v)  Status (int type)  Type type () const"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#enum-velodynetype","title":"enum VelodyneType","text":"<pre><code>enum nebula::VelodyneStatus::VelodyneType {\nINVALID_RPM_ERROR = Type_end_of_Status + 1,\nINVALID_FOV_ERROR,\nINVALID_RETURN_MODE_ERROR,\nType_end_of_Status = INVALID_RPM_ERROR\n};\n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#variable-_velo_type","title":"variable _velo_type","text":"<pre><code>enum nebula::VelodyneStatus::VelodyneType nebula::VelodyneStatus::_velo_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-status-13","title":"function Status [1/3]","text":"<pre><code>inline nebula::VelodyneStatus::Status () </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-status-23","title":"function Status [2/3]","text":"<pre><code>inline nebula::VelodyneStatus::Status (\nType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-status-33","title":"function Status [3/3]","text":"<pre><code>inline nebula::VelodyneStatus::Status (\nint type\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-14","title":"function VelodyneStatus [1/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus () </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-24","title":"function VelodyneStatus [2/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus (\nType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-34","title":"function VelodyneStatus [3/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus (\nVelodyneType v\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-velodynestatus-44","title":"function VelodyneStatus [4/4]","text":"<pre><code>inline nebula::VelodyneStatus::VelodyneStatus (\nint type\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#function-type","title":"function type","text":"<pre><code>inline int nebula::VelodyneStatus::type () const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friend-operator","title":"friend operator!=","text":"<pre><code>inline bool nebula::VelodyneStatus::operator!= (\nconst VelodyneStatus &amp; L,\nconst VelodyneStatus &amp; R\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friend-operator_1","title":"friend operator&lt;&lt;","text":"<p>Convert Status enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::VelodyneStatus::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::VelodyneStatus const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/structnebula_1_1VelodyneStatus/#friend-operator_2","title":"friend operator==","text":"<pre><code>inline bool nebula::VelodyneStatus::operator== (\nconst VelodyneStatus &amp; L,\nconst VelodyneStatus &amp; R\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_status.hpp</code></p>"},{"location":"nebula_common/namespacenebula_1_1drivers/","title":"Namespace nebula::drivers","text":"<p>Namespace List &gt; nebula &gt; drivers</p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#classes","title":"Classes","text":"Type Name struct CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) struct HesaiCalibrationConfiguration struct for Hesai calibration configuration struct HesaiCorrection struct for Hesai correction configuration (for AT) struct HesaiSensorConfiguration struct for Hesai sensor configuration struct PointField not used? struct PointXYZICATR struct PointXYZIR struct PointXYZIRADT struct PointXYZIRCAEDT struct SensorConfigurationBase Base struct for Sensor configuration. class VelodyneCalibration Calibration information for the entire device. struct VelodyneCalibrationConfiguration struct for Velodyne calibration configuration struct VelodyneLaserCorrection struct VelodyneSensorConfiguration struct for Velodyne sensor configuration"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-types","title":"Public Types","text":"Type Name enum CoordinateMode Coordinate mode for Velodyne's setting (need to check) typedef PointXYZIRCAEDT NebulaPoint typedef pcl::PointCloud&lt; NebulaPoint &gt; NebulaPointCloud typedef pcl::PointCloud&lt; NebulaPoint &gt;::Ptr NebulaPointCloudPtr typedef std::shared_ptr&lt; NebulaPoint &gt; NebulaPointPtr enum uint8_t ReturnMode Return mode of each LiDAR. enum uint8_t ReturnType Return type of each scan. enum SensorModel Type of sensor. enum datatype not used?"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-attributes","title":"Public Attributes","text":"Type Name struct nebula::drivers::PointXYZIR EIGEN_ALIGN16"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-functions","title":"Public Functions","text":"Type Name int IntFromReturnModeHesai (const ReturnMode return_mode, const SensorModel &amp; sensor_model) Convert ReturnMode enum to return mode number. ReturnMode ReturnModeFromIntHesai (const int return_mode, const SensorModel &amp; sensor_model) Convert return mode number to ReturnMode enum. ReturnMode ReturnModeFromString (const std::string &amp; return_mode) Convert return mode name to ReturnMode enum. ReturnMode ReturnModeFromStringHesai (const std::string &amp; return_mode, const SensorModel &amp; sensor_model) Convert return mode name to ReturnMode enum (Hesai-specific ReturnModeFromString) ReturnMode ReturnModeFromStringVelodyne (const std::string &amp; return_mode) Convert return mode name to ReturnMode enum (Velodyne-specific ReturnModeFromString) uint8_t ReturnModeToInt (const ReturnMode &amp; mode) Convert ReturnMode enum to integer. ReturnType ReturnModeToReturnType (const ReturnMode &amp; mode) Convert ReturnMode enum to ReturnType enum for Pandar AT, XTM (temporary, not used) SensorModel SensorModelFromString (const std::string &amp; sensor_model) Convert sensor name to SensorModel enum (Upper and lower case letters must match) pcl::PointCloud&lt; PointXYZIR &gt;::Ptr convertPointXYZIRADTToPointXYZIR (const pcl::PointCloud&lt; PointXYZIRADT &gt;::ConstPtr &amp; input_pointcloud)  pcl::PointCloud&lt; PointXYZIR &gt;::Ptr convertPointXYZIRCAEDTToPointXYZIR (const pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud)  pcl::PointCloud&lt; PointXYZIRADT &gt;::Ptr convertPointXYZIRCAEDTToPointXYZIRADT (const pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud, double stamp)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, HesaiSensorConfiguration const &amp; arg) Convert HesaiSensorConfiguration to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::ReturnType const &amp; arg) Convert ReturnType enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::ReturnMode const &amp; arg) Convert ReturnMode enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::SensorModel const &amp; arg) Convert SensorModel enum to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, nebula::drivers::SensorConfigurationBase const &amp; arg) Convert SensorConfigurationBase to string (Overloading the &lt;&lt; operator) std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, VelodyneSensorConfiguration const &amp; arg) Convert VelodyneSensorConfiguration to string (Overloading the &lt;&lt; operator)"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-static-functions","title":"Public Static Functions","text":"Type Name float deg2rad (double degrees) Converts degrees to radians. float rad2deg (double radians) Converts radians to degrees."},{"location":"nebula_common/namespacenebula_1_1drivers/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-coordinatemode","title":"enum CoordinateMode","text":"<pre><code>enum nebula::drivers::CoordinateMode {\nUNKNOWN = 0,\nCARTESIAN,\nSPHERICAL,\nCYLINDRICAL\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapoint","title":"typedef NebulaPoint","text":"<pre><code>using nebula::drivers::NebulaPoint = typedef PointXYZIRCAEDT;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapointcloud","title":"typedef NebulaPointCloud","text":"<pre><code>using nebula::drivers::NebulaPointCloud = typedef pcl::PointCloud&lt;NebulaPoint&gt;;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapointcloudptr","title":"typedef NebulaPointCloudPtr","text":"<pre><code>using nebula::drivers::NebulaPointCloudPtr = typedef pcl::PointCloud&lt;NebulaPoint&gt;::Ptr;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#typedef-nebulapointptr","title":"typedef NebulaPointPtr","text":"<pre><code>using nebula::drivers::NebulaPointPtr = typedef std::shared_ptr&lt;NebulaPoint&gt;;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-returnmode","title":"enum ReturnMode","text":"<pre><code>enum nebula::drivers::ReturnMode {\nUNKNOWN = 0,\nSINGLE_STRONGEST,\nSINGLE_LAST,\nDUAL_FIRST,\nDUAL_LAST,\nDUAL_ONLY,\nSINGLE_FIRST,\nDUAL_STRONGEST_FIRST,\nDUAL_STRONGEST_LAST,\nDUAL_WEAK_FIRST,\nDUAL_WEAK_LAST,\nTRIPLE,\nLAST,\nSTRONGEST,\nDUAL_LAST_STRONGEST,\nFIRST,\nDUAL_LAST_FIRST,\nDUAL_FIRST_STRONGEST,\nDUAL\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-returntype","title":"enum ReturnType","text":"<pre><code>enum nebula::drivers::ReturnType {\nUNKNOWN = 0,\nLAST,\nFIRST,\nSTRONGEST,\nFIRST_WEAK,\nLAST_WEAK,\nIDENTICAL,\nSECOND,\nSECOND_STRONGEST,\nFIRST_STRONGEST,\nLAST_STRONGEST\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-sensormodel","title":"enum SensorModel","text":"<pre><code>enum nebula::drivers::SensorModel {\nUNKNOWN = 0,\nHESAI_PANDAR64,\nHESAI_PANDAR40P,\nHESAI_PANDAR40M,\nHESAI_PANDARQT64,\nHESAI_PANDARQT128,\nHESAI_PANDARXT32,\nHESAI_PANDARXT32M,\nHESAI_PANDARAT128,\nHESAI_PANDAR128_E3X,\nHESAI_PANDAR128_E4X,\nVELODYNE_VLS128,\nVELODYNE_HDL64,\nVELODYNE_VLP32,\nVELODYNE_VLP32MR,\nVELODYNE_HDL32,\nVELODYNE_VLP16\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#enum-datatype","title":"enum datatype","text":"<pre><code>enum nebula::drivers::datatype {\nINT8 = 1,\nUINT8 = 2,\nINT16 = 3,\nUINT16 = 4,\nINT32 = 5,\nUINT32 = 6,\nFLOAT32 = 7,\nFLOAT64 = 8\n};\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#variable-eigen_align16","title":"variable EIGEN_ALIGN16","text":"<pre><code>struct nebula::drivers::PointXYZIRADT nebula::drivers::EIGEN_ALIGN16;\n</code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#function-intfromreturnmodehesai","title":"function IntFromReturnModeHesai","text":"<p>Convert ReturnMode enum to return mode number. <pre><code>inline int nebula::drivers::IntFromReturnModeHesai (\nconst ReturnMode return_mode,\nconst SensorModel &amp; sensor_model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> target ReturnMode </li> <li><code>sensor_model</code> Model for correct conversion </li> </ul> <p>Returns:</p> <p>Corresponding return mode number for the hardware </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefrominthesai","title":"function ReturnModeFromIntHesai","text":"<p>Convert return mode number to ReturnMode enum. <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromIntHesai (\nconst int return_mode,\nconst SensorModel &amp; sensor_model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode number from the hardware response </li> <li><code>sensor_model</code> Model for correct conversion </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstring","title":"function ReturnModeFromString","text":"<p>Convert return mode name to ReturnMode enum. <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromString (\nconst std::string &amp; return_mode\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstringhesai","title":"function ReturnModeFromStringHesai","text":"<p>Convert return mode name to ReturnMode enum (Hesai-specific ReturnModeFromString) <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromStringHesai (\nconst std::string &amp; return_mode,\nconst SensorModel &amp; sensor_model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> <li><code>sensor_model</code> Model for correct conversion </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodefromstringvelodyne","title":"function ReturnModeFromStringVelodyne","text":"<p>Convert return mode name to ReturnMode enum (Velodyne-specific ReturnModeFromString) <pre><code>inline ReturnMode nebula::drivers::ReturnModeFromStringVelodyne (\nconst std::string &amp; return_mode\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding ReturnMode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodetoint","title":"function ReturnModeToInt","text":"<p>Convert ReturnMode enum to integer. <pre><code>inline uint8_t nebula::drivers::ReturnModeToInt (\nconst ReturnMode &amp; mode\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>mode</code> </li> </ul> <p>Returns:</p> <p>Corresponding number </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-returnmodetoreturntype","title":"function ReturnModeToReturnType","text":"<p>Convert ReturnMode enum to ReturnType enum for Pandar AT, XTM (temporary, not used) <pre><code>inline ReturnType nebula::drivers::ReturnModeToReturnType (\nconst ReturnMode &amp; mode\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>mode</code> </li> </ul> <p>Returns:</p> <p>Corresponding mode </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-sensormodelfromstring","title":"function SensorModelFromString","text":"<p>Convert sensor name to SensorModel enum (Upper and lower case letters must match) <pre><code>inline SensorModel nebula::drivers::SensorModelFromString (\nconst std::string &amp; sensor_model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_model</code> Sensor name (Upper and lower case letters must match) </li> </ul> <p>Returns:</p> <p>Corresponding SensorModel </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-convertpointxyziradttopointxyzir","title":"function convertPointXYZIRADTToPointXYZIR","text":"<pre><code>pcl::PointCloud&lt; PointXYZIR &gt;::Ptr nebula::drivers::convertPointXYZIRADTToPointXYZIR (\nconst pcl::PointCloud&lt; PointXYZIRADT &gt;::ConstPtr &amp; input_pointcloud\n) </code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-convertpointxyzircaedttopointxyzir","title":"function convertPointXYZIRCAEDTToPointXYZIR","text":"<pre><code>pcl::PointCloud&lt; PointXYZIR &gt;::Ptr nebula::drivers::convertPointXYZIRCAEDTToPointXYZIR (\nconst pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud\n) </code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-convertpointxyzircaedttopointxyziradt","title":"function convertPointXYZIRCAEDTToPointXYZIRADT","text":"<pre><code>pcl::PointCloud&lt; PointXYZIRADT &gt;::Ptr nebula::drivers::convertPointXYZIRCAEDTToPointXYZIRADT (\nconst pcl::PointCloud&lt; PointXYZIRCAEDT &gt;::ConstPtr &amp; input_pointcloud,\ndouble stamp\n) </code></pre>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator","title":"function operator&lt;&lt;","text":"<p>Convert HesaiSensorConfiguration to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\nstd::ostream &amp; os,\nHesaiSensorConfiguration const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_1","title":"function operator&lt;&lt;","text":"<p>Convert ReturnType enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::drivers::ReturnType const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_2","title":"function operator&lt;&lt;","text":"<p>Convert ReturnMode enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::drivers::ReturnMode const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_3","title":"function operator&lt;&lt;","text":"<p>Convert SensorModel enum to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::drivers::SensorModel const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_4","title":"function operator&lt;&lt;","text":"<p>Convert SensorConfigurationBase to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::drivers::SensorConfigurationBase const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-operator_5","title":"function operator&lt;&lt;","text":"<p>Convert VelodyneSensorConfiguration to string (Overloading the &lt;&lt; operator) <pre><code>inline std::ostream &amp; nebula::drivers::operator&lt;&lt; (\nstd::ostream &amp; os,\nVelodyneSensorConfiguration const &amp; arg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>os</code> </li> <li><code>arg</code> </li> </ul> <p>Returns:</p> <p>stream </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"nebula_common/namespacenebula_1_1drivers/#function-deg2rad","title":"function deg2rad","text":"<p>Converts degrees to radians. <pre><code>static inline float nebula::drivers::deg2rad (\ndouble degrees\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>radians</code> </li> </ul> <p>Returns:</p> <p>degrees </p>"},{"location":"nebula_common/namespacenebula_1_1drivers/#function-rad2deg","title":"function rad2deg","text":"<p>Converts radians to degrees. <pre><code>static inline float nebula::drivers::rad2deg (\ndouble radians\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>radians</code> </li> </ul> <p>Returns:</p> <p>degrees </p> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/","title":"Struct nebula::drivers::CalibrationConfigurationBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; CalibrationConfigurationBase</p> <p>Base struct for Calibration configuration (Requires extensions in child struct) </p> <ul> <li><code>#include &lt;nebula_common.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiCalibrationConfiguration,  nebula::drivers::VelodyneCalibrationConfiguration</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/#public-attributes","title":"Public Attributes","text":"Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1CalibrationConfigurationBase/#variable-calibration_file","title":"variable calibration_file","text":"<pre><code>std::string nebula::drivers::CalibrationConfigurationBase::calibration_file;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/","title":"Struct nebula::drivers::HesaiCalibrationConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiCalibrationConfiguration</p> <p>struct for Hesai calibration configuration </p> <ul> <li><code>#include &lt;hesai_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::CalibrationConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; size_t, float &gt; azimuth_offset_map std::map&lt; size_t, float &gt; elev_angle_map"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-attributes-inherited-from-nebuladriverscalibrationconfigurationbase","title":"Public Attributes inherited from nebula::drivers::CalibrationConfigurationBase","text":"<p>See nebula::drivers::CalibrationConfigurationBase</p> Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-functions","title":"Public Functions","text":"Type Name nebula::Status LoadFromFile (const std::string &amp; calibration_file)  nebula::Status LoadFromString (const std::string &amp; calibration_content) Loading calibration data (not used) nebula::Status SaveFile (const std::string &amp; calibration_file) Saving calibration data (not used)"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#variable-azimuth_offset_map","title":"variable azimuth_offset_map","text":"<pre><code>std::map&lt;size_t, float&gt; nebula::drivers::HesaiCalibrationConfiguration::azimuth_offset_map;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#variable-elev_angle_map","title":"variable elev_angle_map","text":"<pre><code>std::map&lt;size_t, float&gt; nebula::drivers::HesaiCalibrationConfiguration::elev_angle_map;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::LoadFromFile (\nconst std::string &amp; calibration_file\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-loadfromstring","title":"function LoadFromString","text":"<p>Loading calibration data (not used) <pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::LoadFromString (\nconst std::string &amp; calibration_content\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_content</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCalibrationConfiguration/#function-savefile","title":"function SaveFile","text":"<p>Saving calibration data (not used) <pre><code>inline nebula::Status nebula::drivers::HesaiCalibrationConfiguration::SaveFile (\nconst std::string &amp; calibration_file\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_file</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/","title":"Struct nebula::drivers::HesaiCorrection","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiCorrection</p> <p>struct for Hesai correction configuration (for AT) </p> <ul> <li><code>#include &lt;hesai_common.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t SHA256 int32_t azimuth int8_t azimuthOffset uint8_t channelNumber uint16_t delimiter int32_t elevation int8_t elevationOffset uint32_t endFrame uint8_t frameConfig uint8_t frameNumber uint8_t mirrorNumber uint8_t resolution uint32_t startFrame uint8_t versionMajor uint8_t versionMinor"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int STEP3   = = 200 * 256"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-functions","title":"Public Functions","text":"Type Name nebula::Status LoadFromBinary (const std::vector&lt; uint8_t &gt; &amp; buf) Load correction data from file. nebula::Status LoadFromFile (const std::string &amp; correction_file) Load correction data from file. int8_t getAzimuthAdjustV3 (uint8_t ch, uint32_t azi) const int8_t getElevationAdjustV3 (uint8_t ch, uint32_t azi) const"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-sha256","title":"variable SHA256","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::SHA256[32];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-azimuth","title":"variable azimuth","text":"<pre><code>int32_t nebula::drivers::HesaiCorrection::azimuth[128];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-azimuthoffset","title":"variable azimuthOffset","text":"<pre><code>int8_t nebula::drivers::HesaiCorrection::azimuthOffset[36000];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-channelnumber","title":"variable channelNumber","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::channelNumber;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-delimiter","title":"variable delimiter","text":"<pre><code>uint16_t nebula::drivers::HesaiCorrection::delimiter;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-elevation","title":"variable elevation","text":"<pre><code>int32_t nebula::drivers::HesaiCorrection::elevation[128];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-elevationoffset","title":"variable elevationOffset","text":"<pre><code>int8_t nebula::drivers::HesaiCorrection::elevationOffset[36000];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-endframe","title":"variable endFrame","text":"<pre><code>uint32_t nebula::drivers::HesaiCorrection::endFrame[8];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-frameconfig","title":"variable frameConfig","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::frameConfig[8];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-framenumber","title":"variable frameNumber","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::frameNumber;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-mirrornumber","title":"variable mirrorNumber","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::mirrorNumber;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-resolution","title":"variable resolution","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::resolution;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-startframe","title":"variable startFrame","text":"<pre><code>uint32_t nebula::drivers::HesaiCorrection::startFrame[8];\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-versionmajor","title":"variable versionMajor","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::versionMajor;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-versionminor","title":"variable versionMinor","text":"<pre><code>uint8_t nebula::drivers::HesaiCorrection::versionMinor;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#variable-step3","title":"variable STEP3","text":"<pre><code>const int nebula::drivers::HesaiCorrection::STEP3;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-loadfrombinary","title":"function LoadFromBinary","text":"<p>Load correction data from file. <pre><code>inline nebula::Status nebula::drivers::HesaiCorrection::LoadFromBinary (\nconst std::vector&lt; uint8_t &gt; &amp; buf\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> Binary buffer </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-loadfromfile","title":"function LoadFromFile","text":"<p>Load correction data from file. <pre><code>inline nebula::Status nebula::drivers::HesaiCorrection::LoadFromFile (\nconst std::string &amp; correction_file\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>correction_file</code> path </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-getazimuthadjustv3","title":"function getAzimuthAdjustV3","text":"<pre><code>inline int8_t nebula::drivers::HesaiCorrection::getAzimuthAdjustV3 (\nuint8_t ch,\nuint32_t azi\n) const\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiCorrection/#function-getelevationadjustv3","title":"function getElevationAdjustV3","text":"<pre><code>inline int8_t nebula::drivers::HesaiCorrection::getElevationAdjustV3 (\nuint8_t ch,\nuint32_t azi\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/","title":"Struct nebula::drivers::HesaiSensorConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiSensorConfiguration</p> <p>struct for Hesai sensor configuration </p> <ul> <li><code>#include &lt;hesai_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::SensorConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t cloud_max_angle uint16_t cloud_min_angle double dual_return_distance_threshold   = {} uint16_t gnss_port   = {} uint16_t rotation_speed double scan_phase   = {}"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#public-attributes-inherited-from-nebuladriverssensorconfigurationbase","title":"Public Attributes inherited from nebula::drivers::SensorConfigurationBase","text":"<p>See nebula::drivers::SensorConfigurationBase</p> Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-cloud_max_angle","title":"variable cloud_max_angle","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::cloud_max_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-cloud_min_angle","title":"variable cloud_min_angle","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::cloud_min_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-dual_return_distance_threshold","title":"variable dual_return_distance_threshold","text":"<pre><code>double nebula::drivers::HesaiSensorConfiguration::dual_return_distance_threshold;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-gnss_port","title":"variable gnss_port","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::gnss_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-rotation_speed","title":"variable rotation_speed","text":"<pre><code>uint16_t nebula::drivers::HesaiSensorConfiguration::rotation_speed;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1HesaiSensorConfiguration/#variable-scan_phase","title":"variable scan_phase","text":"<pre><code>double nebula::drivers::HesaiSensorConfiguration::scan_phase;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/","title":"Struct nebula::drivers::PointField","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointField</p> <p>not used? </p> <ul> <li><code>#include &lt;nebula_common.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t count uint8_t datatype std::string name uint32_t offset"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-count","title":"variable count","text":"<pre><code>uint32_t nebula::drivers::PointField::count;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-datatype","title":"variable datatype","text":"<pre><code>uint8_t nebula::drivers::PointField::datatype;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-name","title":"variable name","text":"<pre><code>std::string nebula::drivers::PointField::name;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointField/#variable-offset","title":"variable offset","text":"<pre><code>uint32_t nebula::drivers::PointField::offset;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/","title":"Struct nebula::drivers::PointXYZICATR","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZICATR</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#public-attributes","title":"Public Attributes","text":"Type Name PCL_ADD_POINT4D float azimuth std::uint16_t channel std::uint8_t intensity std::uint8_t return_type std::uint32_t time_stamp"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-pcl_add_point4d","title":"variable PCL_ADD_POINT4D","text":"<pre><code>nebula::drivers::PointXYZICATR::PCL_ADD_POINT4D;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::PointXYZICATR::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-channel","title":"variable channel","text":"<pre><code>std::uint16_t nebula::drivers::PointXYZICATR::channel;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-intensity","title":"variable intensity","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZICATR::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-return_type","title":"variable return_type","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZICATR::return_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZICATR/#variable-time_stamp","title":"variable time_stamp","text":"<pre><code>std::uint32_t nebula::drivers::PointXYZICATR::time_stamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/","title":"Struct nebula::drivers::PointXYZIR","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZIR</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#public-attributes","title":"Public Attributes","text":"Type Name PCL_ADD_POINT4D float intensity uint16_t ring"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#variable-pcl_add_point4d","title":"variable PCL_ADD_POINT4D","text":"<pre><code>nebula::drivers::PointXYZIR::PCL_ADD_POINT4D;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#variable-intensity","title":"variable intensity","text":"<pre><code>float nebula::drivers::PointXYZIR::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIR/#variable-ring","title":"variable ring","text":"<pre><code>uint16_t nebula::drivers::PointXYZIR::ring;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/","title":"Struct nebula::drivers::PointXYZIRADT","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZIRADT</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#public-attributes","title":"Public Attributes","text":"Type Name PCL_ADD_POINT4D float azimuth float distance float intensity uint8_t return_type uint16_t ring double time_stamp"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-pcl_add_point4d","title":"variable PCL_ADD_POINT4D","text":"<pre><code>nebula::drivers::PointXYZIRADT::PCL_ADD_POINT4D;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::PointXYZIRADT::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::PointXYZIRADT::distance;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-intensity","title":"variable intensity","text":"<pre><code>float nebula::drivers::PointXYZIRADT::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-return_type","title":"variable return_type","text":"<pre><code>uint8_t nebula::drivers::PointXYZIRADT::return_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-ring","title":"variable ring","text":"<pre><code>uint16_t nebula::drivers::PointXYZIRADT::ring;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRADT/#variable-time_stamp","title":"variable time_stamp","text":"<pre><code>double nebula::drivers::PointXYZIRADT::time_stamp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/","title":"Struct nebula::drivers::PointXYZIRCAEDT","text":"<p>ClassList &gt; nebula &gt; drivers &gt; PointXYZIRCAEDT</p> <p>More...</p> <ul> <li><code>#include &lt;point_types.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#public-attributes","title":"Public Attributes","text":"Type Name float azimuth std::uint16_t channel float distance float elevation std::uint8_t intensity std::uint8_t return_type std::uint32_t time_stamp float x float y float z"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#detailed-description","title":"Detailed Description","text":"<p>This point type is not using PCL_ADD_POINT4D to avoid the addition of a 32-bit dummy word. The fields are ordered to meet the SSE alignment. </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-azimuth","title":"variable azimuth","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::azimuth;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-channel","title":"variable channel","text":"<pre><code>std::uint16_t nebula::drivers::PointXYZIRCAEDT::channel;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::distance;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-elevation","title":"variable elevation","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::elevation;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-intensity","title":"variable intensity","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZIRCAEDT::intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-return_type","title":"variable return_type","text":"<pre><code>std::uint8_t nebula::drivers::PointXYZIRCAEDT::return_type;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-time_stamp","title":"variable time_stamp","text":"<pre><code>std::uint32_t nebula::drivers::PointXYZIRCAEDT::time_stamp;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-x","title":"variable x","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::x;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-y","title":"variable y","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::y;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1PointXYZIRCAEDT/#variable-z","title":"variable z","text":"<pre><code>float nebula::drivers::PointXYZIRCAEDT::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/","title":"Struct nebula::drivers::SensorConfigurationBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; SensorConfigurationBase</p> <p>Base struct for Sensor configuration. </p> <ul> <li><code>#include &lt;nebula_common.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiSensorConfiguration,  nebula::drivers::VelodyneSensorConfiguration</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#public-attributes","title":"Public Attributes","text":"Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-coordinate_mode","title":"variable coordinate_mode","text":"<pre><code>CoordinateMode nebula::drivers::SensorConfigurationBase::coordinate_mode;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-data_port","title":"variable data_port","text":"<pre><code>uint16_t nebula::drivers::SensorConfigurationBase::data_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-fields","title":"variable fields","text":"<pre><code>std::vector&lt;PointField&gt; nebula::drivers::SensorConfigurationBase::fields;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-frame_id","title":"variable frame_id","text":"<pre><code>std::string nebula::drivers::SensorConfigurationBase::frame_id;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-frequency_ms","title":"variable frequency_ms","text":"<pre><code>uint16_t nebula::drivers::SensorConfigurationBase::frequency_ms;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-host_ip","title":"variable host_ip","text":"<pre><code>std::string nebula::drivers::SensorConfigurationBase::host_ip;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-max_range","title":"variable max_range","text":"<pre><code>double nebula::drivers::SensorConfigurationBase::max_range;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-min_range","title":"variable min_range","text":"<pre><code>double nebula::drivers::SensorConfigurationBase::min_range;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-packet_mtu_size","title":"variable packet_mtu_size","text":"<pre><code>uint16_t nebula::drivers::SensorConfigurationBase::packet_mtu_size;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-remove_nans","title":"variable remove_nans","text":"<pre><code>bool nebula::drivers::SensorConfigurationBase::remove_nans;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-return_mode","title":"variable return_mode","text":"<pre><code>ReturnMode nebula::drivers::SensorConfigurationBase::return_mode;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-sensor_ip","title":"variable sensor_ip","text":"<pre><code>std::string nebula::drivers::SensorConfigurationBase::sensor_ip;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1SensorConfigurationBase/#variable-sensor_model","title":"variable sensor_model","text":"<pre><code>SensorModel nebula::drivers::SensorConfigurationBase::sensor_model;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/","title":"Class nebula::drivers::VelodyneCalibration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneCalibration</p> <p>Calibration information for the entire device. </p> <ul> <li><code>#include &lt;velodyne_calibration_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-attributes","title":"Public Attributes","text":"Type Name float distance_resolution_m bool initialized std::vector&lt; VelodyneLaserCorrection &gt; laser_corrections std::map&lt; int, VelodyneLaserCorrection &gt; laser_corrections_map int num_lasers   = {} bool ros_info"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-functions","title":"Public Functions","text":"Type Name VelodyneCalibration (bool info=true)  VelodyneCalibration (const std::string &amp; calibration_file, bool info=true)  void read (const std::string &amp; calibration_file)  void write (const std::string &amp; calibration_file)"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-distance_resolution_m","title":"variable distance_resolution_m","text":"<pre><code>float nebula::drivers::VelodyneCalibration::distance_resolution_m;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-initialized","title":"variable initialized","text":"<pre><code>bool nebula::drivers::VelodyneCalibration::initialized;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-laser_corrections","title":"variable laser_corrections","text":"<pre><code>std::vector&lt;VelodyneLaserCorrection&gt; nebula::drivers::VelodyneCalibration::laser_corrections;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-laser_corrections_map","title":"variable laser_corrections_map","text":"<pre><code>std::map&lt;int, VelodyneLaserCorrection&gt; nebula::drivers::VelodyneCalibration::laser_corrections_map;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-num_lasers","title":"variable num_lasers","text":"<pre><code>int nebula::drivers::VelodyneCalibration::num_lasers;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#variable-ros_info","title":"variable ros_info","text":"<pre><code>bool nebula::drivers::VelodyneCalibration::ros_info;\n</code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-velodynecalibration-12","title":"function VelodyneCalibration [1/2]","text":"<pre><code>inline explicit nebula::drivers::VelodyneCalibration::VelodyneCalibration (\nbool info=true\n) </code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-velodynecalibration-22","title":"function VelodyneCalibration [2/2]","text":"<pre><code>inline explicit nebula::drivers::VelodyneCalibration::VelodyneCalibration (\nconst std::string &amp; calibration_file,\nbool info=true\n) </code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-read","title":"function read","text":"<pre><code>void nebula::drivers::VelodyneCalibration::read (\nconst std::string &amp; calibration_file\n) </code></pre>"},{"location":"nebula_common/classnebula_1_1drivers_1_1VelodyneCalibration/#function-write","title":"function write","text":"<pre><code>void nebula::drivers::VelodyneCalibration::write (\nconst std::string &amp; calibration_file\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_calibration_decoder.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/","title":"Struct nebula::drivers::VelodyneCalibrationConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneCalibrationConfiguration</p> <p>struct for Velodyne calibration configuration </p> <ul> <li><code>#include &lt;velodyne_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::CalibrationConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name VelodyneCalibration velodyne_calibration"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-attributes-inherited-from-nebuladriverscalibrationconfigurationbase","title":"Public Attributes inherited from nebula::drivers::CalibrationConfigurationBase","text":"<p>See nebula::drivers::CalibrationConfigurationBase</p> Type Name std::string calibration_file"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-functions","title":"Public Functions","text":"Type Name nebula::Status LoadFromFile (const std::string &amp; calibration_file)  nebula::Status SaveFile (const std::string &amp; calibration_file)"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#variable-velodyne_calibration","title":"variable velodyne_calibration","text":"<pre><code>VelodyneCalibration nebula::drivers::VelodyneCalibrationConfiguration::velodyne_calibration;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#function-loadfromfile","title":"function LoadFromFile","text":"<pre><code>inline nebula::Status nebula::drivers::VelodyneCalibrationConfiguration::LoadFromFile (\nconst std::string &amp; calibration_file\n) </code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneCalibrationConfiguration/#function-savefile","title":"function SaveFile","text":"<pre><code>inline nebula::Status nebula::drivers::VelodyneCalibrationConfiguration::SaveFile (\nconst std::string &amp; calibration_file\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_common.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/","title":"Struct nebula::drivers::VelodyneLaserCorrection","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneLaserCorrection</p> <ul> <li><code>#include &lt;velodyne_calibration_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#public-attributes","title":"Public Attributes","text":"Type Name float cos_rot_correction cosine of rot_correction float cos_vert_correction cosine of vert_correction float dist_correction float dist_correction_x float dist_correction_y float focal_distance float focal_slope float horiz_offset_correction int laser_ring ring number for this laser int max_intensity int min_intensity float rot_correction float sin_rot_correction sine of rot_correction float sin_vert_correction sine of vert_correction bool two_pt_correction_available float vert_correction float vert_offset_correction"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-cos_rot_correction","title":"variable cos_rot_correction","text":"<p>cosine of rot_correction <pre><code>float nebula::drivers::VelodyneLaserCorrection::cos_rot_correction;\n</code></pre></p> <p>cached values calculated when the calibration file is read </p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-cos_vert_correction","title":"variable cos_vert_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::cos_vert_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-dist_correction","title":"variable dist_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::dist_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-dist_correction_x","title":"variable dist_correction_x","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::dist_correction_x;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-dist_correction_y","title":"variable dist_correction_y","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::dist_correction_y;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-focal_distance","title":"variable focal_distance","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::focal_distance;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-focal_slope","title":"variable focal_slope","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::focal_slope;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-horiz_offset_correction","title":"variable horiz_offset_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::horiz_offset_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-laser_ring","title":"variable laser_ring","text":"<pre><code>int nebula::drivers::VelodyneLaserCorrection::laser_ring;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-max_intensity","title":"variable max_intensity","text":"<pre><code>int nebula::drivers::VelodyneLaserCorrection::max_intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-min_intensity","title":"variable min_intensity","text":"<pre><code>int nebula::drivers::VelodyneLaserCorrection::min_intensity;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-rot_correction","title":"variable rot_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::rot_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-sin_rot_correction","title":"variable sin_rot_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::sin_rot_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-sin_vert_correction","title":"variable sin_vert_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::sin_vert_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-two_pt_correction_available","title":"variable two_pt_correction_available","text":"<pre><code>bool nebula::drivers::VelodyneLaserCorrection::two_pt_correction_available;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-vert_correction","title":"variable vert_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::vert_correction;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneLaserCorrection/#variable-vert_offset_correction","title":"variable vert_offset_correction","text":"<pre><code>float nebula::drivers::VelodyneLaserCorrection::vert_offset_correction;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_calibration_decoder.hpp</code></p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/","title":"Struct nebula::drivers::VelodyneSensorConfiguration","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneSensorConfiguration</p> <p>struct for Velodyne sensor configuration </p> <ul> <li><code>#include &lt;velodyne_common.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::SensorConfigurationBase</p>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t cloud_max_angle uint16_t cloud_min_angle uint16_t gnss_port   = {} uint16_t rotation_speed double scan_phase   = {}"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#public-attributes-inherited-from-nebuladriverssensorconfigurationbase","title":"Public Attributes inherited from nebula::drivers::SensorConfigurationBase","text":"<p>See nebula::drivers::SensorConfigurationBase</p> Type Name CoordinateMode coordinate_mode uint16_t data_port std::vector&lt; PointField &gt; fields todo: consider changing to only_finite std::string frame_id uint16_t frequency_ms std::string host_ip double max_range double min_range uint16_t packet_mtu_size bool remove_nans ReturnMode return_mode std::string sensor_ip SensorModel sensor_model"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-cloud_max_angle","title":"variable cloud_max_angle","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::cloud_max_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-cloud_min_angle","title":"variable cloud_min_angle","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::cloud_min_angle;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-gnss_port","title":"variable gnss_port","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::gnss_port;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-rotation_speed","title":"variable rotation_speed","text":"<pre><code>uint16_t nebula::drivers::VelodyneSensorConfiguration::rotation_speed;\n</code></pre>"},{"location":"nebula_common/structnebula_1_1drivers_1_1VelodyneSensorConfiguration/#variable-scan_phase","title":"variable scan_phase","text":"<pre><code>double nebula::drivers::VelodyneSensorConfiguration::scan_phase;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_common.hpp</code></p>"},{"location":"nebula_common/dir_641be904c0d17ffe4f28a10e8f3d9a52/","title":"Dir nebula_common","text":"<p>FileList &gt; nebula_common</p>"},{"location":"nebula_common/dir_641be904c0d17ffe4f28a10e8f3d9a52/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_common/</code></p>"},{"location":"nebula_common/dir_78168b4d319b5936ba23a59e4e5ed862/","title":"Dir nebula_common/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_common/dir_78168b4d319b5936ba23a59e4e5ed862/#directories","title":"Directories","text":"Type Name dir nebula_common <p>The documentation for this class was generated from the following file <code>nebula_common/include/</code></p>"},{"location":"nebula_common/dir_04479a60c124280b07620829e5c7552c/","title":"Dir nebula_common/include/nebula_common","text":"<p>FileList &gt; include &gt; nebula_common</p>"},{"location":"nebula_common/dir_04479a60c124280b07620829e5c7552c/#files","title":"Files","text":"Type Name file nebula_common.hpp file nebula_status.hpp file point_types.hpp"},{"location":"nebula_common/dir_04479a60c124280b07620829e5c7552c/#directories","title":"Directories","text":"Type Name dir hesai dir velodyne <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/</code></p>"},{"location":"nebula_common/nebula__common_8hpp/","title":"File nebula_common.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; nebula_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;nebula_common/point_types.hpp&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_common/nebula__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/nebula__common_8hpp/#classes","title":"Classes","text":"Type Name struct CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) struct PointField not used? struct SensorConfigurationBase Base struct for Sensor configuration. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_common.hpp</code></p>"},{"location":"nebula_common/nebula__common_8hpp_source/","title":"File nebula_common.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; nebula_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_COMMON_H\n#define NEBULA_COMMON_H\n\n#include &lt;nebula_common/point_types.hpp&gt;\n\n#include &lt;map&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nenum class CoordinateMode { UNKNOWN = 0, CARTESIAN, SPHERICAL, CYLINDRICAL };\n\nenum class ReturnType : uint8_t {\nUNKNOWN = 0,\nLAST,\nFIRST,\nSTRONGEST,\nFIRST_WEAK,\nLAST_WEAK,\nIDENTICAL,\nSECOND,\nSECOND_STRONGEST,\nFIRST_STRONGEST,\nLAST_STRONGEST\n};\n\nenum class ReturnMode : uint8_t {\nUNKNOWN = 0,\nSINGLE_STRONGEST,\nSINGLE_LAST,\nDUAL_FIRST,\nDUAL_LAST,\nDUAL_ONLY,\nSINGLE_FIRST,\nDUAL_STRONGEST_FIRST,\nDUAL_STRONGEST_LAST,\nDUAL_WEAK_FIRST,\nDUAL_WEAK_LAST,\nTRIPLE,\nLAST,\nSTRONGEST,\nDUAL_LAST_STRONGEST,\nFIRST,\nDUAL_LAST_FIRST,\nDUAL_FIRST_STRONGEST,\nDUAL\n};\n\ninline ReturnType ReturnModeToReturnType(const ReturnMode &amp; mode)\n{\nswitch (mode) {\ncase ReturnMode::SINGLE_STRONGEST:\nreturn ReturnType::STRONGEST;\nbreak;\ncase ReturnMode::SINGLE_LAST:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::DUAL_FIRST:\nreturn ReturnType::FIRST;\nbreak;\ncase ReturnMode::DUAL_LAST:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::DUAL_ONLY:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::SINGLE_FIRST:\nreturn ReturnType::FIRST;\nbreak;\ncase ReturnMode::DUAL_STRONGEST_FIRST:\nreturn ReturnType::FIRST;\nbreak;\ncase ReturnMode::DUAL_STRONGEST_LAST:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::DUAL_WEAK_FIRST:\nreturn ReturnType::FIRST_WEAK;\nbreak;\ncase ReturnMode::DUAL_WEAK_LAST:\nreturn ReturnType::LAST_WEAK;\nbreak;\ncase ReturnMode::TRIPLE:\nreturn ReturnType::STRONGEST;\nbreak;\n// for Hesai\ncase ReturnMode::LAST:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::STRONGEST:\nreturn ReturnType::STRONGEST;\nbreak;\ncase ReturnMode::DUAL_LAST_STRONGEST:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::FIRST:\nreturn ReturnType::FIRST;\nbreak;\ncase ReturnMode::DUAL_LAST_FIRST:\nreturn ReturnType::LAST;\nbreak;\ncase ReturnMode::DUAL_FIRST_STRONGEST:\nreturn ReturnType::FIRST;\nbreak;\ncase ReturnMode::DUAL:\nreturn ReturnType::LAST;\nbreak;\ndefault:\ncase ReturnMode::UNKNOWN:\nreturn ReturnType::UNKNOWN;\nbreak;\n}\n}\n\ninline uint8_t ReturnModeToInt(const ReturnMode &amp; mode)\n{\nswitch (mode) {\ncase ReturnMode::SINGLE_STRONGEST:\nreturn 1;\nbreak;\ncase ReturnMode::SINGLE_LAST:\nreturn 2;\nbreak;\ncase ReturnMode::DUAL_FIRST:\nreturn 3;\nbreak;\ncase ReturnMode::DUAL_LAST:\nreturn 4;\nbreak;\ncase ReturnMode::DUAL_ONLY:\nreturn 5;\nbreak;\ncase ReturnMode::SINGLE_FIRST:\nreturn 6;\nbreak;\ncase ReturnMode::DUAL_STRONGEST_FIRST:\nreturn 7;\nbreak;\ncase ReturnMode::DUAL_STRONGEST_LAST:\nreturn 8;\nbreak;\ncase ReturnMode::DUAL_WEAK_FIRST:\nreturn 9;\nbreak;\ncase ReturnMode::DUAL_WEAK_LAST:\nreturn 10;\nbreak;\ncase ReturnMode::TRIPLE:\nreturn 11;\nbreak;\n// for Hesai\ncase ReturnMode::LAST:\nreturn 12;\nbreak;\ncase ReturnMode::STRONGEST:\nreturn 13;\nbreak;\ncase ReturnMode::DUAL_LAST_STRONGEST:\nreturn 14;\nbreak;\ncase ReturnMode::FIRST:\nreturn 15;\nbreak;\ncase ReturnMode::DUAL_LAST_FIRST:\nreturn 16;\nbreak;\ncase ReturnMode::DUAL_FIRST_STRONGEST:\nreturn 17;\nbreak;\ncase ReturnMode::DUAL:\nreturn 18;\nbreak;\ndefault:\ncase ReturnMode::UNKNOWN:\nreturn 0;\nbreak;\n}\n}\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::ReturnType const &amp; arg)\n{\nswitch (arg) {\ncase ReturnType::UNKNOWN:\nos &lt;&lt; \"Unknown\";\nbreak;\ncase ReturnType::LAST:\nos &lt;&lt; \"Last\";\nbreak;\ncase ReturnType::FIRST:\nos &lt;&lt; \"First\";\nbreak;\ncase ReturnType::STRONGEST:\nos &lt;&lt; \"Strongest\";\nbreak;\ncase ReturnType::FIRST_WEAK:\nos &lt;&lt; \"FirstWeak\";\nbreak;\ncase ReturnType::LAST_WEAK:\nos &lt;&lt; \"LastWeak\";\nbreak;\ncase ReturnType::IDENTICAL:\nos &lt;&lt; \"Identical\";\nbreak;\ncase ReturnType::SECOND:\nos &lt;&lt; \"Second\";\nbreak;\ncase ReturnType::SECOND_STRONGEST:\nos &lt;&lt; \"SecondStrongest\";\nbreak;\ncase ReturnType::FIRST_STRONGEST:\nos &lt;&lt; \"FirstStrongest\";\nbreak;\ncase ReturnType::LAST_STRONGEST:\nos &lt;&lt; \"LastStrongest\";\nbreak;\n}\nreturn os;\n}\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::ReturnMode const &amp; arg)\n{\nswitch (arg) {\ncase ReturnMode::SINGLE_FIRST:\nos &lt;&lt; \"SingleFirst\";\nbreak;\ncase ReturnMode::SINGLE_STRONGEST:\nos &lt;&lt; \"SingleStrongest\";\nbreak;\ncase ReturnMode::SINGLE_LAST:\nos &lt;&lt; \"SingleLast\";\nbreak;\ncase ReturnMode::DUAL_ONLY:\nos &lt;&lt; \"Dual\";\nbreak;\ncase ReturnMode::DUAL_FIRST:\nos &lt;&lt; \"DualFirst\";\nbreak;\ncase ReturnMode::DUAL_LAST:\nos &lt;&lt; \"DualLast\";\nbreak;\ncase ReturnMode::DUAL_WEAK_FIRST:\nos &lt;&lt; \"WeakFirst\";\nbreak;\ncase ReturnMode::DUAL_WEAK_LAST:\nos &lt;&lt; \"WeakLast\";\nbreak;\ncase ReturnMode::DUAL_STRONGEST_LAST:\nos &lt;&lt; \"StrongLast\";\nbreak;\ncase ReturnMode::DUAL_STRONGEST_FIRST:\nos &lt;&lt; \"StrongFirst\";\nbreak;\ncase ReturnMode::TRIPLE:\nos &lt;&lt; \"Triple\";\nbreak;\n// for Hesai\ncase ReturnMode::LAST:\nos &lt;&lt; \"Last\";\nbreak;\ncase ReturnMode::STRONGEST:\nos &lt;&lt; \"Strongest\";\nbreak;\ncase ReturnMode::DUAL_LAST_STRONGEST:\nos &lt;&lt; \"LastStrongest\";\nbreak;\ncase ReturnMode::FIRST:\nos &lt;&lt; \"First\";\nbreak;\ncase ReturnMode::DUAL_LAST_FIRST:\nos &lt;&lt; \"LastFirst\";\nbreak;\ncase ReturnMode::DUAL_FIRST_STRONGEST:\nos &lt;&lt; \"FirstStrongest\";\nbreak;\ncase ReturnMode::DUAL:\nos &lt;&lt; \"Dual\";\nbreak;\ncase ReturnMode::UNKNOWN:\nos &lt;&lt; \"Unknown\";\nbreak;\n}\nreturn os;\n}\n\n// SENSOR_CONFIGURATION\n\nenum class SensorModel {\nUNKNOWN = 0,\nHESAI_PANDAR64,\nHESAI_PANDAR40P,\nHESAI_PANDAR40M,\nHESAI_PANDARQT64,\nHESAI_PANDARQT128,\nHESAI_PANDARXT32,\nHESAI_PANDARXT32M,\nHESAI_PANDARAT128,\nHESAI_PANDAR128_E3X,\nHESAI_PANDAR128_E4X,\nVELODYNE_VLS128,\nVELODYNE_HDL64,\nVELODYNE_VLP32,\nVELODYNE_VLP32MR,\nVELODYNE_HDL32,\nVELODYNE_VLP16,\n};\n\nenum class datatype {\nINT8 = 1,\nUINT8 = 2,\nINT16 = 3,\nUINT16 = 4,\nINT32 = 5,\nUINT32 = 6,\nFLOAT32 = 7,\nFLOAT64 = 8\n};\n\nstruct PointField\n{\nstd::string name;\nuint32_t offset;\nuint8_t datatype;\nuint32_t count;\n};\n\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::drivers::SensorModel const &amp; arg)\n{\nswitch (arg) {\ncase SensorModel::HESAI_PANDAR64:\nos &lt;&lt; \"Pandar64\";\nbreak;\ncase SensorModel::HESAI_PANDAR40P:\nos &lt;&lt; \"Pandar40P\";\nbreak;\ncase SensorModel::HESAI_PANDAR40M:\nos &lt;&lt; \"Pandar40M\";\nbreak;\ncase SensorModel::HESAI_PANDARQT64:\nos &lt;&lt; \"PandarQT64\";\nbreak;\ncase SensorModel::HESAI_PANDARQT128:\nos &lt;&lt; \"PandarQT128\";\nbreak;\ncase SensorModel::HESAI_PANDARXT32:\nos &lt;&lt; \"PandarXT32\";\nbreak;\ncase SensorModel::HESAI_PANDARXT32M:\nos &lt;&lt; \"PandarXT32M\";\nbreak;\ncase SensorModel::HESAI_PANDARAT128:\nos &lt;&lt; \"PandarAT128\";\nbreak;\ncase SensorModel::HESAI_PANDAR128_E3X:\nos &lt;&lt; \"Pandar128_E3X\";\nbreak;\ncase SensorModel::HESAI_PANDAR128_E4X:\nos &lt;&lt; \"Pandar128_E4X_OT\";\nbreak;\ncase SensorModel::VELODYNE_VLS128:\nos &lt;&lt; \"VLS128\";\nbreak;\ncase SensorModel::VELODYNE_HDL64:\nos &lt;&lt; \"HDL64\";\nbreak;\ncase SensorModel::VELODYNE_VLP32:\nos &lt;&lt; \"VLP32\";\nbreak;\ncase SensorModel::VELODYNE_VLP32MR:\nos &lt;&lt; \"VLP32MR\";\nbreak;\ncase SensorModel::VELODYNE_HDL32:\nos &lt;&lt; \"HDL32\";\nbreak;\ncase SensorModel::VELODYNE_VLP16:\nos &lt;&lt; \"VLP16\";\nbreak;\ncase SensorModel::UNKNOWN:\nos &lt;&lt; \"Sensor Unknown\";\nbreak;\n}\nreturn os;\n}\n\nstruct SensorConfigurationBase\n{\nSensorModel sensor_model;\nReturnMode return_mode;\nstd::string host_ip;\nstd::string sensor_ip;\nstd::string frame_id;\nuint16_t data_port;\nuint16_t frequency_ms;\nuint16_t packet_mtu_size;\nCoordinateMode coordinate_mode;\ndouble min_range;\ndouble max_range;\nbool remove_nans;  std::vector&lt;PointField&gt; fields;\n};\n\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; os, nebula::drivers::SensorConfigurationBase const &amp; arg)\n{\nos &lt;&lt; \"SensorModel: \" &lt;&lt; arg.sensor_model &lt;&lt; \", ReturnMode: \" &lt;&lt; arg.return_mode\n&lt;&lt; \", HostIP: \" &lt;&lt; arg.host_ip &lt;&lt; \", SensorIP: \" &lt;&lt; arg.sensor_ip\n&lt;&lt; \", FrameID: \" &lt;&lt; arg.frame_id &lt;&lt; \", DataPort: \" &lt;&lt; arg.data_port\n&lt;&lt; \", Frequency: \" &lt;&lt; arg.frequency_ms &lt;&lt; \", MTU: \" &lt;&lt; arg.packet_mtu_size;\nreturn os;\n}\n\nstruct CalibrationConfigurationBase\n{\nstd::string calibration_file;\n};\n\ninline SensorModel SensorModelFromString(const std::string &amp; sensor_model)\n{\n// Hesai\nif (sensor_model == \"Pandar64\") return SensorModel::HESAI_PANDAR64;\nif (sensor_model == \"Pandar40P\") return SensorModel::HESAI_PANDAR40P;\nif (sensor_model == \"Pandar40M\") return SensorModel::HESAI_PANDAR40M;\nif (sensor_model == \"PandarXT32\") return SensorModel::HESAI_PANDARXT32;\nif (sensor_model == \"PandarXT32M\") return SensorModel::HESAI_PANDARXT32M;\nif (sensor_model == \"PandarAT128\") return SensorModel::HESAI_PANDARAT128;\nif (sensor_model == \"PandarQT64\") return SensorModel::HESAI_PANDARQT64;\nif (sensor_model == \"PandarQT128\") return SensorModel::HESAI_PANDARQT128;\nif (sensor_model == \"Pandar128E4X\") return SensorModel::HESAI_PANDAR128_E4X;\n// Velodyne\nif (sensor_model == \"VLS128\") return SensorModel::VELODYNE_VLS128;\nif (sensor_model == \"HDL64\") return SensorModel::VELODYNE_HDL64;\nif (sensor_model == \"VLP32\") return SensorModel::VELODYNE_VLP32;\nif (sensor_model == \"VLP32MR\") return SensorModel::VELODYNE_VLP32MR;\nif (sensor_model == \"HDL32\") return SensorModel::VELODYNE_HDL32;\nif (sensor_model == \"VLP16\") return SensorModel::VELODYNE_VLP16;\nreturn SensorModel::UNKNOWN;\n}\n\ninline ReturnMode ReturnModeFromString(const std::string &amp; return_mode)\n{\nif (return_mode == \"SingleFirst\") return ReturnMode::SINGLE_FIRST;\nif (return_mode == \"SingleStrongest\") return ReturnMode::SINGLE_STRONGEST;\nif (return_mode == \"SingleLast\") return ReturnMode::SINGLE_LAST;\nif (return_mode == \"Dual\") return ReturnMode::DUAL_ONLY;\n\nreturn ReturnMode::UNKNOWN;\n}\n\n[[maybe_unused]] pcl::PointCloud&lt;PointXYZIR&gt;::Ptr convertPointXYZIRADTToPointXYZIR(\nconst pcl::PointCloud&lt;PointXYZIRADT&gt;::ConstPtr &amp; input_pointcloud);\n\n[[maybe_unused]] pcl::PointCloud&lt;PointXYZIR&gt;::Ptr convertPointXYZIRCAEDTToPointXYZIR(\nconst pcl::PointCloud&lt;PointXYZIRCAEDT&gt;::ConstPtr &amp; input_pointcloud);\n\npcl::PointCloud&lt;PointXYZIRADT&gt;::Ptr convertPointXYZIRCAEDTToPointXYZIRADT(\nconst pcl::PointCloud&lt;PointXYZIRCAEDT&gt;::ConstPtr &amp; input_pointcloud, double stamp);\n\nstatic inline float deg2rad(double degrees) { return degrees * M_PI / 180.0; }\n\nstatic inline float rad2deg(double radians) { return radians * 180.0 / M_PI; }\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_CONFIGURATION_BASE_H\n</code></pre>"},{"location":"nebula_common/dir_618777836fb6f6d5617fcbcab933ec7b/","title":"Dir nebula_common/include/nebula_common/hesai","text":"<p>FileList &gt; hesai</p>"},{"location":"nebula_common/dir_618777836fb6f6d5617fcbcab933ec7b/#files","title":"Files","text":"Type Name file hesai_common.hpp file hesai_status.hpp <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/</code></p>"},{"location":"nebula_common/hesai__common_8hpp/","title":"File hesai_common.hpp","text":"<p>FileList &gt; hesai &gt; hesai_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"nebula_common/hesai__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/hesai__common_8hpp/#classes","title":"Classes","text":"Type Name struct HesaiCalibrationConfiguration struct for Hesai calibration configuration struct HesaiCorrection struct for Hesai correction configuration (for AT) struct HesaiSensorConfiguration struct for Hesai sensor configuration <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_common.hpp</code></p>"},{"location":"nebula_common/hesai__common_8hpp_source/","title":"File hesai_common.hpp","text":"<p>File List &gt; hesai &gt; hesai_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HESAI_COMMON_H\n#define NEBULA_HESAI_COMMON_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;bitset&gt;\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\nnamespace nebula\n{\nnamespace drivers\n{\nstruct HesaiSensorConfiguration : SensorConfigurationBase\n{\nuint16_t gnss_port{};\ndouble scan_phase{};\ndouble dual_return_distance_threshold{};\nuint16_t rotation_speed;\nuint16_t cloud_min_angle;\nuint16_t cloud_max_angle;\n};\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, HesaiSensorConfiguration const &amp; arg)\n{\nos &lt;&lt; (SensorConfigurationBase)(arg) &lt;&lt; \", GnssPort: \" &lt;&lt; arg.gnss_port\n&lt;&lt; \", ScanPhase:\" &lt;&lt; arg.scan_phase &lt;&lt; \", RotationSpeed:\" &lt;&lt; arg.rotation_speed\n&lt;&lt; \", FOV(Start):\" &lt;&lt; arg.cloud_min_angle &lt;&lt; \", FOV(End):\" &lt;&lt; arg.cloud_max_angle;\nreturn os;\n}\n\nstruct HesaiCalibrationConfiguration : CalibrationConfigurationBase\n{\nstd::map&lt;size_t, float&gt; elev_angle_map;\nstd::map&lt;size_t, float&gt; azimuth_offset_map;\n\ninline nebula::Status LoadFromFile(const std::string &amp; calibration_file)\n{\nstd::ifstream ifs(calibration_file);\nif (!ifs) {\nreturn Status::INVALID_CALIBRATION_FILE;\n}\n\nstd::string header;\nstd::getline(ifs, header);\n\nchar sep;\nint laser_id;\nfloat elevation;\nfloat azimuth;\nwhile (!ifs.eof()) {\nifs &gt;&gt; laser_id &gt;&gt; sep &gt;&gt; elevation &gt;&gt; sep &gt;&gt; azimuth;\nelev_angle_map[laser_id - 1] = elevation;\nazimuth_offset_map[laser_id - 1] = azimuth;\n}\nifs.close();\nreturn Status::OK;\n}\n\ninline nebula::Status LoadFromString(const std::string &amp; calibration_content)\n{\nstd::stringstream ss;\nss &lt;&lt; calibration_content;\n\nstd::string header;\nstd::getline(ss, header);\n\nchar sep;\nint laser_id;\nfloat elevation;\nfloat azimuth;\nwhile (!ss.eof()) {\nss &gt;&gt; laser_id &gt;&gt; sep &gt;&gt; elevation &gt;&gt; sep &gt;&gt; azimuth;\nelev_angle_map[laser_id - 1] = elevation;\nazimuth_offset_map[laser_id - 1] = azimuth;\n}\nreturn Status::OK;\n}\n\ninline nebula::Status SaveFile(const std::string &amp; calibration_file)\n{\nstd::ofstream ofs(calibration_file);\nif (!ofs) {\nreturn Status::CANNOT_SAVE_FILE;\n}\nofs &lt;&lt; \"Laser id,Elevation,Azimuth\" &lt;&lt; std::endl;\nfor (const auto &amp; pair : elev_angle_map) {\nauto laser_id = pair.first + 1;\nfloat elevation = pair.second;\nfloat azimuth = azimuth_offset_map[pair.first];\nofs &lt;&lt; laser_id &lt;&lt; \",\" &lt;&lt; elevation &lt;&lt; \",\" &lt;&lt; azimuth &lt;&lt; std::endl;\n}\nofs.close();\n\nreturn Status::OK;\n}\n};\n\nstruct HesaiCorrection\n{\nuint16_t delimiter;\nuint8_t versionMajor;\nuint8_t versionMinor;\nuint8_t channelNumber;\nuint8_t mirrorNumber;\nuint8_t frameNumber;\nuint8_t frameConfig[8];\nuint8_t resolution;\n\nuint32_t startFrame[8];\nuint32_t endFrame[8];\nint32_t azimuth[128];\nint32_t elevation[128];\nint8_t azimuthOffset[36000];\nint8_t elevationOffset[36000];\nuint8_t SHA256[32];\n\ninline nebula::Status LoadFromBinary(const std::vector&lt;uint8_t&gt; &amp; buf)\n{\nsize_t index = 0;\ndelimiter = (buf[index] &amp; 0xff) &lt;&lt; 8 | ((buf[index + 1] &amp; 0xff));\nversionMajor = buf[index + 2] &amp; 0xff;\nversionMinor = buf[index + 3] &amp; 0xff;\nstd::cout &lt;&lt; \"versionMajor=\" &lt;&lt; static_cast&lt;int&gt;(versionMajor) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"versionMinor=\" &lt;&lt; static_cast&lt;int&gt;(versionMinor) &lt;&lt; std::endl;\nchannelNumber = buf[index + 4] &amp; 0xff;\nstd::cout &lt;&lt; \"channelNumber=\" &lt;&lt; static_cast&lt;int&gt;(channelNumber) &lt;&lt; std::endl;\nmirrorNumber = buf[index + 5] &amp; 0xff;\nstd::cout &lt;&lt; \"mirrorNumber=\" &lt;&lt; static_cast&lt;int&gt;(mirrorNumber) &lt;&lt; std::endl;\nframeNumber = buf[index + 6] &amp; 0xff;\nstd::cout &lt;&lt; \"frameNumber=\" &lt;&lt; static_cast&lt;int&gt;(frameNumber) &lt;&lt; std::endl;\nindex += 7;\nfor (uint8_t i = 0; i &lt; 8; i++) {\nframeConfig[i] = buf[index] &amp; 0xff;\nindex++;\n}\nresolution = buf[index] &amp; 0xff;\nstd::cout &lt;&lt; \"resolution=\" &lt;&lt; static_cast&lt;int&gt;(resolution) &lt;&lt; std::endl;\nindex++;\nswitch (versionMinor) {\ncase 5:\nfor (uint8_t i = 0; i &lt; mirrorNumber; i++) {\nstartFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\nindex += 4;\n}\nfor (uint8_t i = 0; i &lt; mirrorNumber; i++) {\nendFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\nindex += 4;\n}\nfor (uint8_t i = 0; i &lt; channelNumber; i++) {\nazimuth[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\nindex += 4;\n}\nfor (uint8_t i = 0; i &lt; channelNumber; i++) {\nelevation[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8 |\n((buf[index + 2] &amp; 0xff) &lt;&lt; 16) | ((buf[index + 3] &amp; 0xff) &lt;&lt; 24);\nindex += 4;\n}\nfor (int i = 0; i &lt; channelNumber * 180; i++) {\nazimuthOffset[i] = buf[index] &amp; 0xff;\nindex++;\n}\nfor (int i = 0; i &lt; channelNumber * 180; i++) {\nelevationOffset[i] = buf[index] &amp; 0xff;\nindex++;\n}\n\n// 230328 add\nfor (uint8_t i = 0; i &lt; mirrorNumber; i++) {\nstartFrame[i] *= resolution;\nendFrame[i] *= resolution;\nstd::cout &lt;&lt; \"startFrame[\" &lt;&lt; static_cast&lt;int&gt;(i)\n&lt;&lt; \"]=\" &lt;&lt; static_cast&lt;int&gt;(startFrame[i]) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"endFrame[\" &lt;&lt; static_cast&lt;int&gt;(i) &lt;&lt; \"]=\" &lt;&lt; static_cast&lt;int&gt;(endFrame[i])\n&lt;&lt; std::endl;\n}\nfor (uint8_t i = 0; i &lt; channelNumber; i++) {\nazimuth[i] *= resolution;\nelevation[i] *= resolution;\n}\nfor (int i = 0; i &lt; channelNumber * 180; i++) {\nazimuthOffset[i] *= resolution;\nelevationOffset[i] *= resolution;\n}\nbreak;\n\ncase 3:  // not worked...\nfor (uint8_t i = 0; i &lt; mirrorNumber; i++) {\nstartFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\nindex += 2;\n}\nfor (uint8_t i = 0; i &lt; mirrorNumber; i++) {\nendFrame[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\nindex += 2;\n}\nfor (uint8_t i = 0; i &lt; channelNumber; i++) {\nazimuth[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\nindex += 2;\n}\nfor (uint8_t i = 0; i &lt; channelNumber; i++) {\nelevation[i] = (buf[index] &amp; 0xff) | (buf[index + 1] &amp; 0xff) &lt;&lt; 8;\nindex += 2;\n}\nfor (int i = 0; i &lt; 36000; i++) {\nazimuthOffset[i] = buf[index] &amp; 0xff;\nindex++;\n}\nfor (int i = 0; i &lt; 36000; i++) {\nelevationOffset[i] = buf[index] &amp; 0xff;\nindex++;\n}\n\nfor (uint8_t i = 0; i &lt; mirrorNumber; i++) {\nstd::cout &lt;&lt; \"startFrame[\" &lt;&lt; static_cast&lt;int&gt;(i)\n&lt;&lt; \"]=\" &lt;&lt; static_cast&lt;int&gt;(startFrame[i]) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"endFrame[\" &lt;&lt; static_cast&lt;int&gt;(i) &lt;&lt; \"]=\" &lt;&lt; static_cast&lt;int&gt;(endFrame[i])\n&lt;&lt; std::endl;\n/*\n        startFrame[i] *= 2.56;\n        endFrame[i] *= 2.56;\n        std::cout &lt;&lt; \"startFrame[\" &lt;&lt; static_cast&lt;int&gt;(i) &lt;&lt; \"]=\" &lt;&lt; static_cast&lt;int&gt;(startFrame[i])\n        &lt;&lt; std::endl; std::cout &lt;&lt; \"endFrame[\" &lt;&lt; static_cast&lt;int&gt;(i) &lt;&lt; \"]=\" &lt;&lt;\n        static_cast&lt;int&gt;(endFrame[i]) &lt;&lt; std::endl;\n        */\n}\n\nbreak;\n\ndefault:\nbreak;\n}\nreturn Status::OK;\n}\n\ninline nebula::Status LoadFromFile(const std::string &amp; correction_file)\n{\nstd::ifstream ifs(correction_file, std::ios::in | std::ios::binary);\nif (!ifs) {\nreturn Status::INVALID_CALIBRATION_FILE;\n}\nstd::vector&lt;unsigned char&gt; buf;\n//    int cnt = 0;\nwhile (!ifs.eof()) {\nunsigned char c;\nifs.read((char *)&amp;c, sizeof(unsigned char));\nbuf.emplace_back(c);\n}\nLoadFromBinary(buf);\n\nifs.close();\nreturn Status::OK;\n}\n\nstatic const int STEP3 = 200 * 256;\nint8_t getAzimuthAdjustV3(uint8_t ch, uint32_t azi) const\n{\nunsigned int i = std::floor(1.f * azi / STEP3);\nunsigned int l = azi - i * STEP3;\nfloat k = 1.f * l / STEP3;\nreturn round((1 - k) * azimuthOffset[ch * 180 + i] + k * azimuthOffset[ch * 180 + i + 1]);\n}\nint8_t getElevationAdjustV3(uint8_t ch, uint32_t azi) const\n{\nunsigned int i = std::floor(1.f * azi / STEP3);\nunsigned int l = azi - i * STEP3;\nfloat k = 1.f * l / STEP3;\nreturn round((1 - k) * elevationOffset[ch * 180 + i] + k * elevationOffset[ch * 180 + i + 1]);\n}\n};\n\n/*\n&lt;option value=\"0\"&gt;Last Return&lt;/option&gt;\n&lt;option value=\"1\"&gt;Strongest Return&lt;/option&gt;\n&lt;option value=\"3\"&gt;First Return&lt;/option&gt;\n&lt;option value=\"2\"&gt;Last Return + Strongest Return&lt;/option&gt;\n&lt;option value=\"4\"&gt;First Return + Last Return&lt;/option&gt;\n&lt;option value=\"5\"&gt;First Return + Strongest Return&lt;/option&gt;\n*/\n/*\n&lt;option value=\"0\"&gt;Last Return&lt;/option&gt;\n&lt;option value=\"1\"&gt;Strongest Return&lt;/option&gt;\n&lt;option value=\"3\"&gt;First Return&lt;/option&gt;\n&lt;option value=\"2\"&gt;Last Return + Strongest Return&lt;/option&gt;\n&lt;option value=\"4\"&gt;First Return + Strongest Return&lt;/option&gt;\n&lt;option value=\"5\"&gt;First Return + Last Return&lt;/option&gt;\n&lt;option value=\"6\"&gt;First Return + Last Return + Strongest Return&lt;/option&gt;\n*/\n\ninline ReturnMode ReturnModeFromStringHesai(\nconst std::string &amp; return_mode, const SensorModel &amp; sensor_model)\n{\nswitch (sensor_model) {\ncase SensorModel::HESAI_PANDARXT32M:\ncase SensorModel::HESAI_PANDARAT128:\nif (return_mode == \"Last\") return ReturnMode::LAST;\nif (return_mode == \"Strongest\") return ReturnMode::STRONGEST;\nif (return_mode == \"LastStrongest\") return ReturnMode::DUAL_LAST_STRONGEST;\nif (return_mode == \"First\") return ReturnMode::FIRST;\nif (return_mode == \"LastFirst\") return ReturnMode::DUAL_LAST_FIRST;\nif (return_mode == \"FirstStrongest\") return ReturnMode::DUAL_FIRST_STRONGEST;\nif (return_mode == \"Dual\") return ReturnMode::DUAL;\nbreak;\ncase SensorModel::HESAI_PANDARQT64:\nif (return_mode == \"Last\") return ReturnMode::LAST;\nif (return_mode == \"Dual\") return ReturnMode::DUAL;\nif (return_mode == \"First\") return ReturnMode::FIRST;\nbreak;\ndefault:\nif (return_mode == \"Last\") return ReturnMode::LAST;\nif (return_mode == \"Strongest\") return ReturnMode::STRONGEST;\nif (return_mode == \"Dual\") return ReturnMode::DUAL;\nbreak;\n}\n\nreturn ReturnMode::UNKNOWN;\n}\n\ninline ReturnMode ReturnModeFromIntHesai(const int return_mode, const SensorModel &amp; sensor_model)\n{\nswitch (sensor_model) {\ncase SensorModel::HESAI_PANDARXT32M:\ncase SensorModel::HESAI_PANDARAT128:\nif (return_mode == 0) return ReturnMode::LAST;\nif (return_mode == 1) return ReturnMode::STRONGEST;\nif (return_mode == 2) return ReturnMode::DUAL_LAST_STRONGEST;\nif (return_mode == 3) return ReturnMode::FIRST;\nif (return_mode == 4) return ReturnMode::DUAL_LAST_FIRST;\nif (return_mode == 5) return ReturnMode::DUAL_FIRST_STRONGEST;\nbreak;\ncase SensorModel::HESAI_PANDARQT64:\nif (return_mode == 0) return ReturnMode::LAST;\nif (return_mode == 2) return ReturnMode::DUAL;\nif (return_mode == 3) return ReturnMode::FIRST;\nbreak;\ndefault:\nif (return_mode == 0) return ReturnMode::LAST;\nif (return_mode == 1) return ReturnMode::STRONGEST;\nif (return_mode == 2) return ReturnMode::DUAL;\nbreak;\n}\n\nreturn ReturnMode::UNKNOWN;\n}\n\ninline int IntFromReturnModeHesai(const ReturnMode return_mode, const SensorModel &amp; sensor_model)\n{\nswitch (sensor_model) {\ncase SensorModel::HESAI_PANDARXT32M:\ncase SensorModel::HESAI_PANDARAT128:\nif (return_mode == ReturnMode::LAST) return 0;\nif (return_mode == ReturnMode::STRONGEST) return 1;\nif (return_mode == ReturnMode::DUAL_LAST_STRONGEST) return 2;\nif (return_mode == ReturnMode::FIRST) return 3;\nif (return_mode == ReturnMode::DUAL_LAST_FIRST) return 4;\nif (return_mode == ReturnMode::DUAL_FIRST_STRONGEST) return 5;\nbreak;\ncase SensorModel::HESAI_PANDARQT64:\nif (return_mode == ReturnMode::LAST) return 0;\nif (return_mode == ReturnMode::DUAL) return 2;\nif (return_mode == ReturnMode::FIRST) return 3;\nbreak;\ndefault:\nif (return_mode == ReturnMode::LAST) return 0;\nif (return_mode == ReturnMode::STRONGEST) return 1;\nif (return_mode == ReturnMode::DUAL) return 2;\nbreak;\n}\n\nreturn -1;\n}\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HESAI_COMMON_H\n</code></pre>"},{"location":"nebula_common/hesai__status_8hpp/","title":"File hesai_status.hpp","text":"<p>FileList &gt; hesai &gt; hesai_status.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_common/hesai__status_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_common/hesai__status_8hpp/#classes","title":"Classes","text":"Type Name struct HesaiStatus Status definition for Hesai. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/hesai/hesai_status.hpp</code></p>"},{"location":"nebula_common/hesai__status_8hpp_source/","title":"File hesai_status.hpp","text":"<p>File List &gt; hesai &gt; hesai_status.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HESAI_STATUS_HPP\n#define HESAI_STATUS_HPP\n\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\n// from https://marycore.jp/prog/cpp/extends-enum/\n\nstruct HesaiStatus : Status\n{\nusing Status::Status;\n\nprivate:\nint _type_num;\n\npublic:\nenum HesaiType {\nINVALID_RPM_ERROR = Type_end_of_Status + 1,\nINVALID_FOV_ERROR,\nINVALID_RETURN_MODE_ERROR,\nType_end_of_Status = INVALID_RPM_ERROR\n} _hesai_type;\nHesaiStatus() : _type_num(static_cast&lt;int&gt;(Status::OK)) { _type = static_cast&lt;Type&gt;(type()); }\nHesaiStatus(Type v) : _type_num(static_cast&lt;int&gt;(v)) { _type = v; }\nHesaiStatus(HesaiType v) : _type_num(static_cast&lt;int&gt;(v)), _hesai_type(v)\n{\n_type = Type::Type_end_of_Status;\n}\nHesaiStatus(int type) : _type_num(type) {}\nint type() const { return _type_num; }\nfriend bool operator==(const HesaiStatus &amp; L, const HesaiStatus &amp; R)\n{\nreturn L.type() == R.type();\n}\nfriend bool operator!=(const HesaiStatus &amp; L, const HesaiStatus &amp; R)\n{\nreturn L.type() != R.type();\n}\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiStatus const &amp; arg)\n{\nswitch (arg.type()) {\n// Velodyne\ncase HesaiStatus::INVALID_RPM_ERROR:\nos &lt;&lt; \"Invalid rotation speed value(range from 300 to 1200, in increments of 60)\";\nbreak;\ncase HesaiStatus::INVALID_FOV_ERROR:\nos &lt;&lt; \"Invalid fov value(0 to 359)\";\nbreak;\ncase HesaiStatus::INVALID_RETURN_MODE_ERROR:\nos &lt;&lt; \"Invalid return mode(only SINGLE_STRONGEST, SINGLE_LAST, DUAL_ONLY)\";\nbreak;\ndefault:\nos &lt;&lt; Status(arg._type);\n}\nreturn os;\n}\n};\n}  // namespace nebula\n#endif  // HESAI_STATUS_HPP\n</code></pre>"},{"location":"nebula_common/dir_a9be73d3a179cc984b65f35408b847b4/","title":"Dir nebula_common/include/nebula_common/velodyne","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne</p>"},{"location":"nebula_common/dir_a9be73d3a179cc984b65f35408b847b4/#files","title":"Files","text":"Type Name file velodyne_calibration_decoder.hpp file velodyne_common.hpp file velodyne_status.hpp <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/</code></p>"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp/","title":"File velodyne_calibration_decoder.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_calibration_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;yaml-cpp/yaml.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneCalibration Calibration information for the entire device. struct VelodyneLaserCorrection <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_calibration_decoder.hpp</code></p>"},{"location":"nebula_common/velodyne__calibration__decoder_8hpp_source/","title":"File velodyne_calibration_decoder.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_calibration_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_CALIBRATION_DECODER_H\n#define NEBULA_VELODYNE_CALIBRATION_DECODER_H\n\n#include &lt;yaml-cpp/yaml.h&gt;\n\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nstruct VelodyneLaserCorrection\n{\nfloat rot_correction;\nfloat vert_correction;\nfloat dist_correction;\nbool two_pt_correction_available;\nfloat dist_correction_x;\nfloat dist_correction_y;\nfloat vert_offset_correction;\nfloat horiz_offset_correction;\nint max_intensity;\nint min_intensity;\nfloat focal_distance;\nfloat focal_slope;\n\nfloat cos_rot_correction;   float sin_rot_correction;   float cos_vert_correction;  float sin_vert_correction;  int laser_ring;  };\n\nclass VelodyneCalibration\n{\npublic:\nfloat distance_resolution_m;\nstd::map&lt;int, VelodyneLaserCorrection&gt; laser_corrections_map;\nstd::vector&lt;VelodyneLaserCorrection&gt; laser_corrections;\nint num_lasers{};\nbool initialized;\nbool ros_info;\n\npublic:\nexplicit VelodyneCalibration(bool info = true)\n: distance_resolution_m(0.002f), initialized(false), ros_info(info)\n{\n}\nexplicit VelodyneCalibration(const std::string &amp; calibration_file, bool info = true)\n: distance_resolution_m(0.002f), ros_info(info)\n{\nread(calibration_file);\n}\n\nvoid read(const std::string &amp; calibration_file);\nvoid write(const std::string &amp; calibration_file);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_CALIBRATION_DECODER_H\n</code></pre>"},{"location":"nebula_common/velodyne__common_8hpp/","title":"File velodyne_common.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_common.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> </ul>"},{"location":"nebula_common/velodyne__common_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/velodyne__common_8hpp/#classes","title":"Classes","text":"Type Name struct VelodyneCalibrationConfiguration struct for Velodyne calibration configuration struct VelodyneSensorConfiguration struct for Velodyne sensor configuration <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_common.hpp</code></p>"},{"location":"nebula_common/velodyne__common_8hpp_source/","title":"File velodyne_common.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_common.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_COMMON_H\n#define NEBULA_VELODYNE_COMMON_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"\n\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\nnamespace nebula\n{\nnamespace drivers\n{\nstruct VelodyneSensorConfiguration : SensorConfigurationBase\n{\nuint16_t gnss_port{};\ndouble scan_phase{};\nuint16_t rotation_speed;\nuint16_t cloud_min_angle;\nuint16_t cloud_max_angle;\n};\ninline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, VelodyneSensorConfiguration const &amp; arg)\n{\nos &lt;&lt; (SensorConfigurationBase)(arg) &lt;&lt; \", GnssPort: \" &lt;&lt; arg.gnss_port\n&lt;&lt; \", ScanPhase:\" &lt;&lt; arg.scan_phase &lt;&lt; \", RotationSpeed:\" &lt;&lt; arg.rotation_speed\n&lt;&lt; \", FOV(Start):\" &lt;&lt; arg.cloud_min_angle &lt;&lt; \", FOV(End):\" &lt;&lt; arg.cloud_max_angle;\nreturn os;\n}\n\nstruct VelodyneCalibrationConfiguration : CalibrationConfigurationBase\n{\nVelodyneCalibration velodyne_calibration;\ninline nebula::Status LoadFromFile(const std::string &amp; calibration_file)\n{\nvelodyne_calibration.read(calibration_file);\nif (!velodyne_calibration.initialized) {\nreturn Status::INVALID_CALIBRATION_FILE;\n} else {\nreturn Status::OK;\n}\n}\ninline nebula::Status SaveFile(const std::string &amp; calibration_file)\n{\nvelodyne_calibration.write(calibration_file);\nreturn Status::OK;\n}\n};\n\ninline ReturnMode ReturnModeFromStringVelodyne(const std::string &amp; return_mode)\n{\nif (return_mode == \"Strongest\") return ReturnMode::SINGLE_STRONGEST;\nif (return_mode == \"Last\") return ReturnMode::SINGLE_LAST;\nif (return_mode == \"Dual\") return ReturnMode::DUAL_ONLY;\n\nreturn ReturnMode::UNKNOWN;\n}\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_COMMON_H\n</code></pre>"},{"location":"nebula_common/velodyne__status_8hpp/","title":"File velodyne_status.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_status.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_common/velodyne__status_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_common/velodyne__status_8hpp/#classes","title":"Classes","text":"Type Name struct VelodyneStatus Status definition for Velodyne. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/velodyne/velodyne_status.hpp</code></p>"},{"location":"nebula_common/velodyne__status_8hpp_source/","title":"File velodyne_status.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; velodyne &gt; velodyne_status.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef VELODYNE_STATUS_HPP\n#define VELODYNE_STATUS_HPP\n\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\n// from https://marycore.jp/prog/cpp/extends-enum/\n\nstruct VelodyneStatus : Status\n{\nusing Status::Status;\n\nprivate:\nint _type_num;\n\npublic:\nenum VelodyneType {\nINVALID_RPM_ERROR = Type_end_of_Status + 1,\nINVALID_FOV_ERROR,\nINVALID_RETURN_MODE_ERROR,\nType_end_of_Status = INVALID_RPM_ERROR\n} _velo_type;\nVelodyneStatus() : _type_num(static_cast&lt;int&gt;(Status::OK)) { _type = static_cast&lt;Type&gt;(type()); }\nVelodyneStatus(Type v) : _type_num(static_cast&lt;int&gt;(v)) { _type = v; }\nVelodyneStatus(VelodyneType v) : _type_num(static_cast&lt;int&gt;(v)), _velo_type(v)\n{\n_type = Type::Type_end_of_Status;\n}\nVelodyneStatus(int type) : _type_num(type) {}\nint type() const { return _type_num; }\nfriend bool operator==(const VelodyneStatus &amp; L, const VelodyneStatus &amp; R)\n{\nreturn L.type() == R.type();\n}\nfriend bool operator!=(const VelodyneStatus &amp; L, const VelodyneStatus &amp; R)\n{\nreturn L.type() != R.type();\n}\n//  friend VelodyneStatus operator VelodyneStatus(const Status &amp; s) {return VelodyneStatus(s);}\n// implicit\n//  operator Status() const {std::cout &lt;&lt; \"implicit\" &lt;&lt; std::endl; return Status(type());}\n//  operator const Status() {std::cout &lt;&lt; \"implicit\" &lt;&lt; std::endl; return Status(type());}\n//  explicit operator Status() const {std::cout &lt;&lt; \"explicit\" &lt;&lt; std::endl; return\n//  Status(type());} Status Status::operator=(const VelodyneStatus&amp;) {std::cout &lt;&lt; \"implicit = \"\n//  &lt;&lt; std::endl; return Status(type());} Status operator=(const VelodyneStatus) {std::cout &lt;&lt;\n//  \"implicit = \" &lt;&lt; std::endl; return Status(type());} Status&amp; operator=(const VelodyneStatus&amp;)\n//  {std::cout &lt;&lt; \"implicit = \" &lt;&lt; std::endl; Status rt = Status(type()); return rt;}\n//  Status::Status(const VelodyneStatus&amp; vs) {_type = v;}\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::VelodyneStatus const &amp; arg)\n{\nswitch (arg.type()) {\n/*\n      // in nebula_status.hpp\n      case Status::OK:\n        os &lt;&lt; \"OK\";\n        break;\n      case Status::UDP_CONNECTION_ERROR:\n        os &lt;&lt; \"Udp Connection Error\";\n        break;\n      case Status::SENSOR_CONFIG_ERROR:\n        os &lt;&lt; \"Could not set SensorConfiguration\";\n        break;\n      case Status::INVALID_SENSOR_MODEL:\n        os &lt;&lt; \"Invalid sensor model provided\";\n        break;\n      case Status::INVALID_ECHO_MODE:\n        os &lt;&lt; \"Invalid echo model provided\";\n        break;\n      case Status::NOT_IMPLEMENTED:\n        os &lt;&lt; \"Not Implemented\";\n        break;\n      case Status::NOT_INITIALIZED:\n        os &lt;&lt; \"Not Initialized\";\n        break;\n      case Status::INVALID_CALIBRATION_FILE:\n        os &lt;&lt; \"Invalid Calibration File\";\n        break;\n      case Status::CANNOT_SAVE_FILE:\n        os &lt;&lt; \"Cannot Save File\";\n        break;\n      case Status::HTTP_CONNECTION_ERROR:\n        os &lt;&lt; \"Http Connection Error\";\n        break;\n      */\n// Velodyne\ncase VelodyneStatus::INVALID_RPM_ERROR:\nos &lt;&lt; \"Invalid rotation speed value(range from 300 to 1200, in increments of 60)\";\nbreak;\ncase VelodyneStatus::INVALID_FOV_ERROR:\nos &lt;&lt; \"Invalid fov value(0 to 359)\";\nbreak;\ncase VelodyneStatus::INVALID_RETURN_MODE_ERROR:\nos &lt;&lt; \"Invalid return mode(only SINGLE_STRONGEST, SINGLE_LAST, DUAL_ONLY)\";\nbreak;\ndefault:\nos &lt;&lt; Status(arg._type);\n}\nreturn os;\n}\n};\n}  // namespace nebula\n#endif  // VELODYNE_STATUS_HPP\n</code></pre>"},{"location":"nebula_common/nebula__status_8hpp/","title":"File nebula_status.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; nebula_status.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_common/nebula__status_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_common/nebula__status_8hpp/#classes","title":"Classes","text":"Type Name struct Status Status definition. <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/nebula_status.hpp</code></p>"},{"location":"nebula_common/nebula__status_8hpp_source/","title":"File nebula_status.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; nebula_status.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_STATUS_HPP\n#define NEBULA_STATUS_HPP\n\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\n// from https://marycore.jp/prog/cpp/extends-enum/\n\nstruct Status\n{\nenum Type {\nOK = 0,\nUDP_CONNECTION_ERROR,\nSENSOR_CONFIG_ERROR,\nINVALID_SENSOR_MODEL,\nINVALID_ECHO_MODE,\nNOT_IMPLEMENTED,\nNOT_INITIALIZED,\nINVALID_CALIBRATION_FILE,\nCANNOT_SAVE_FILE,\nHTTP_CONNECTION_ERROR,\nWAITING_FOR_SENSOR_RESPONSE,\nERROR_1,\nType_end_of_Status = ERROR_1\n} _type;\nStatus() : _type(Type::OK) {}\nStatus(Type v) : _type(v) {}\nStatus(int type) : _type(static_cast&lt;Type&gt;(type)) {}\nType type() const { return _type; }\nfriend bool operator==(const Status &amp; L, const Status &amp; R) { return L.type() == R.type(); }\nfriend bool operator!=(const Status &amp; L, const Status &amp; R) { return L.type() != R.type(); }\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::Status const &amp; arg)\n{\nswitch (arg.type()) {\ncase Status::OK:\nos &lt;&lt; \"OK\";\nbreak;\ncase Status::UDP_CONNECTION_ERROR:\nos &lt;&lt; \"Udp Connection Error\";\nbreak;\ncase Status::SENSOR_CONFIG_ERROR:\nos &lt;&lt; \"Could not set SensorConfiguration\";\nbreak;\ncase Status::INVALID_SENSOR_MODEL:\nos &lt;&lt; \"Invalid sensor model provided\";\nbreak;\ncase Status::INVALID_ECHO_MODE:\nos &lt;&lt; \"Invalid echo model provided\";\nbreak;\ncase Status::NOT_IMPLEMENTED:\nos &lt;&lt; \"Not Implemented\";\nbreak;\ncase Status::NOT_INITIALIZED:\nos &lt;&lt; \"Not Initialized\";\nbreak;\ncase Status::INVALID_CALIBRATION_FILE:\nos &lt;&lt; \"Invalid Calibration File\";\nbreak;\ncase Status::CANNOT_SAVE_FILE:\nos &lt;&lt; \"Cannot Save File\";\nbreak;\ncase Status::HTTP_CONNECTION_ERROR:\nos &lt;&lt; \"Http Connection Error\";\nbreak;\ncase Status::WAITING_FOR_SENSOR_RESPONSE:\nos &lt;&lt; \"Waiting for Sensor Response\";\nbreak;\ncase Status::ERROR_1:\ndefault:\nos &lt;&lt; \"Generic Error\";\n}\nreturn os;\n}\n};\n\n}  // namespace nebula\n#endif  // NEBULA_STATUS_HPP\n</code></pre>"},{"location":"nebula_common/point__types_8hpp/","title":"File point_types.hpp","text":"<p>FileList &gt; include &gt; nebula_common &gt; point_types.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;pcl/point_cloud.h&gt;</code></li> <li><code>#include &lt;pcl/point_types.h&gt;</code></li> </ul>"},{"location":"nebula_common/point__types_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_common/point__types_8hpp/#classes","title":"Classes","text":"Type Name struct PointXYZICATR struct PointXYZIR struct PointXYZIRADT struct PointXYZIRCAEDT <p>The documentation for this class was generated from the following file <code>nebula_common/include/nebula_common/point_types.hpp</code></p>"},{"location":"nebula_common/point__types_8hpp_source/","title":"File point_types.hpp","text":"<p>File List &gt; include &gt; nebula_common &gt; point_types.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_POINT_TYPES_H\n#define NEBULA_POINT_TYPES_H\n\n#include &lt;pcl/point_cloud.h&gt;\n#include &lt;pcl/point_types.h&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nstruct PointXYZIR\n{\nPCL_ADD_POINT4D;\nfloat intensity;\nuint16_t ring;\nEIGEN_MAKE_ALIGNED_OPERATOR_NEW\n} EIGEN_ALIGN16;\n\nstruct PointXYZICATR\n{\nPCL_ADD_POINT4D;\nstd::uint8_t intensity;\nstd::uint16_t channel;\nfloat azimuth;\nstd::uint32_t time_stamp;\nstd::uint8_t return_type;\n};\nstruct PointXYZIRCAEDT\n{\nfloat x;\nfloat y;\nfloat z;\nstd::uint8_t intensity;\nstd::uint8_t return_type;\nstd::uint16_t channel;\nfloat azimuth;\nfloat elevation;\nfloat distance;\nstd::uint32_t time_stamp;\n};\n\nstruct PointXYZIRADT\n{\nPCL_ADD_POINT4D;\nfloat intensity;\nuint16_t ring;\nfloat azimuth;\nfloat distance;\nuint8_t return_type;\ndouble time_stamp;\nEIGEN_MAKE_ALIGNED_OPERATOR_NEW\n} EIGEN_ALIGN16;\n\nusing NebulaPoint = PointXYZIRCAEDT;\nusing NebulaPointPtr = std::shared_ptr&lt;NebulaPoint&gt;;\nusing NebulaPointCloud = pcl::PointCloud&lt;NebulaPoint&gt;;\nusing NebulaPointCloudPtr = pcl::PointCloud&lt;NebulaPoint&gt;::Ptr;\n\n}  // namespace drivers\n}  // namespace nebula\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(nebula::drivers::PointXYZIR,\n(float, x, x)(float, y, y)(float, z, z)(float, intensity, intensity)(std::uint16_t,\nring, ring))\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(nebula::drivers::PointXYZIRADT,\n(float, x, x)\n(float, y, y)\n(float, z, z)\n(float, intensity, intensity)\n(std::uint16_t, ring, ring)\n(float, azimuth, azimuth)\n(float, distance, distance)\n(std::uint8_t, return_type, return_type)\n(double, time_stamp, time_stamp))\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(\nnebula::drivers::PointXYZICATR,\n(float, x, x)(float, y, y)(float, z, z)(std::uint8_t, intensity, intensity)(\nstd::uint16_t, channel, channel)(float, azimuth, azimuth)(\nstd::uint32_t, time_stamp, time_stamp)(std::uint8_t, return_type, return_type))\n\nPOINT_CLOUD_REGISTER_POINT_STRUCT(\nnebula::drivers::PointXYZIRCAEDT,\n(float, x, x)(float, y, y)(float, z, z)(std::uint8_t, intensity, intensity)(\nstd::uint8_t, return_type,\nreturn_type)(std::uint16_t, channel, channel)(float, azimuth, azimuth)(\nfloat, elevation, elevation)(float, distance, distance)(std::uint32_t, time_stamp, time_stamp))\n\n#endif\n</code></pre>"},{"location":"nebula_common/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace drivers </li> </ul> </li> </ul>"},{"location":"nebula_common/classes/","title":"Class Index","text":""},{"location":"nebula_common/classes/#c","title":"c","text":"<ul> <li>CalibrationConfigurationBase (nebula::drivers)</li> </ul>"},{"location":"nebula_common/classes/#h","title":"h","text":"<ul> <li>HesaiCalibrationConfiguration (nebula::drivers)</li> <li>HesaiCorrection (nebula::drivers)</li> <li>HesaiSensorConfiguration (nebula::drivers)</li> <li>HesaiStatus (nebula)</li> </ul>"},{"location":"nebula_common/classes/#p","title":"p","text":"<ul> <li>PointField (nebula::drivers)</li> <li>PointXYZICATR (nebula::drivers)</li> <li>PointXYZIR (nebula::drivers)</li> <li>PointXYZIRADT (nebula::drivers)</li> <li>PointXYZIRCAEDT (nebula::drivers)</li> </ul>"},{"location":"nebula_common/classes/#s","title":"s","text":"<ul> <li>SensorConfigurationBase (nebula::drivers)</li> <li>Status (nebula)</li> </ul>"},{"location":"nebula_common/classes/#v","title":"v","text":"<ul> <li>VelodyneCalibration (nebula::drivers)</li> <li>VelodyneCalibrationConfiguration (nebula::drivers)</li> <li>VelodyneLaserCorrection (nebula::drivers)</li> <li>VelodyneSensorConfiguration (nebula::drivers)</li> <li>VelodyneStatus (nebula)</li> </ul>"},{"location":"nebula_common/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::drivers::VelodyneCalibration Calibration information for the entire device. </li> <li>struct nebula::Status Status definition. <ul> <li>struct nebula::HesaiStatus Status definition for Hesai.</li> <li>struct nebula::VelodyneStatus Status definition for Velodyne.</li> </ul> </li> <li>struct nebula::drivers::CalibrationConfigurationBase Base struct for Calibration configuration (Requires extensions in child struct) <ul> <li>struct nebula::drivers::HesaiCalibrationConfiguration struct for Hesai calibration configuration </li> <li>struct nebula::drivers::VelodyneCalibrationConfiguration struct for Velodyne calibration configuration </li> </ul> </li> <li>struct nebula::drivers::HesaiCorrection struct for Hesai correction configuration (for AT) </li> <li>struct nebula::drivers::SensorConfigurationBase Base struct for Sensor configuration. <ul> <li>struct nebula::drivers::HesaiSensorConfiguration struct for Hesai sensor configuration </li> <li>struct nebula::drivers::VelodyneSensorConfiguration struct for Velodyne sensor configuration </li> </ul> </li> <li>struct nebula::drivers::PointField not used? </li> <li>struct nebula::drivers::PointXYZICATR </li> <li>struct nebula::drivers::PointXYZIR </li> <li>struct nebula::drivers::PointXYZIRADT </li> <li>struct nebula::drivers::PointXYZIRCAEDT </li> <li>struct nebula::drivers::VelodyneLaserCorrection </li> </ul>"},{"location":"nebula_common/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_common/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"nebula_common/class_members/","title":"Class Members","text":""},{"location":"nebula_common/class_members/#a","title":"a","text":"<ul> <li>azimuth_offset_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>azimuth (nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>azimuthOffset (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#c","title":"c","text":"<ul> <li>calibration_file (nebula::drivers::CalibrationConfigurationBase)</li> <li>channelNumber (nebula::drivers::HesaiCorrection)</li> <li>cloud_max_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>cloud_min_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>count (nebula::drivers::PointField)</li> <li>channel (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRCAEDT)</li> <li>coordinate_mode (nebula::drivers::SensorConfigurationBase)</li> <li>cos_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>cos_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#d","title":"d","text":"<ul> <li>delimiter (nebula::drivers::HesaiCorrection)</li> <li>dual_return_distance_threshold (nebula::drivers::HesaiSensorConfiguration)</li> <li>datatype (nebula::drivers::PointField)</li> <li>distance (nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>data_port (nebula::drivers::SensorConfigurationBase)</li> <li>distance_resolution_m (nebula::drivers::VelodyneCalibration)</li> <li>dist_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_x (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_y (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#e","title":"e","text":"<ul> <li>elev_angle_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>elevation (nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZIRCAEDT)</li> <li>elevationOffset (nebula::drivers::HesaiCorrection)</li> <li>endFrame (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#f","title":"f","text":"<ul> <li>frameConfig (nebula::drivers::HesaiCorrection)</li> <li>frameNumber (nebula::drivers::HesaiCorrection)</li> <li>fields (nebula::drivers::SensorConfigurationBase)</li> <li>frame_id (nebula::drivers::SensorConfigurationBase)</li> <li>frequency_ms (nebula::drivers::SensorConfigurationBase)</li> <li>focal_distance (nebula::drivers::VelodyneLaserCorrection)</li> <li>focal_slope (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#g","title":"g","text":"<ul> <li>getAzimuthAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>getElevationAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>gnss_port (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> </ul>"},{"location":"nebula_common/class_members/#h","title":"h","text":"<ul> <li>HesaiStatus (nebula::HesaiStatus)</li> <li>HesaiType (nebula::HesaiStatus)</li> <li>host_ip (nebula::drivers::SensorConfigurationBase)</li> <li>horiz_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#i","title":"i","text":"<ul> <li>intensity (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>initialized (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_members/#l","title":"l","text":"<ul> <li>LoadFromFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::HesaiCorrection, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>LoadFromString (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>LoadFromBinary (nebula::drivers::HesaiCorrection)</li> <li>laser_corrections (nebula::drivers::VelodyneCalibration)</li> <li>laser_corrections_map (nebula::drivers::VelodyneCalibration)</li> <li>laser_ring (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#m","title":"m","text":"<ul> <li>mirrorNumber (nebula::drivers::HesaiCorrection)</li> <li>max_range (nebula::drivers::SensorConfigurationBase)</li> <li>min_range (nebula::drivers::SensorConfigurationBase)</li> <li>max_intensity (nebula::drivers::VelodyneLaserCorrection)</li> <li>min_intensity (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#n","title":"n","text":"<ul> <li>name (nebula::drivers::PointField)</li> <li>num_lasers (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_members/#o","title":"o","text":"<ul> <li>offset (nebula::drivers::PointField)</li> </ul>"},{"location":"nebula_common/class_members/#p","title":"p","text":"<ul> <li>PCL_ADD_POINT4D (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>packet_mtu_size (nebula::drivers::SensorConfigurationBase)</li> </ul>"},{"location":"nebula_common/class_members/#r","title":"r","text":"<ul> <li>resolution (nebula::drivers::HesaiCorrection)</li> <li>rotation_speed (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>return_type (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>ring (nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>remove_nans (nebula::drivers::SensorConfigurationBase)</li> <li>return_mode (nebula::drivers::SensorConfigurationBase)</li> <li>read (nebula::drivers::VelodyneCalibration)</li> <li>ros_info (nebula::drivers::VelodyneCalibration)</li> <li>rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#s","title":"s","text":"<ul> <li>Status (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> <li>SaveFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>SHA256 (nebula::drivers::HesaiCorrection)</li> <li>STEP3 (nebula::drivers::HesaiCorrection)</li> <li>startFrame (nebula::drivers::HesaiCorrection)</li> <li>scan_phase (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>sensor_ip (nebula::drivers::SensorConfigurationBase)</li> <li>sensor_model (nebula::drivers::SensorConfigurationBase)</li> <li>sin_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>sin_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#t","title":"t","text":"<ul> <li>type (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> <li>Type (nebula::Status)</li> <li>time_stamp (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>two_pt_correction_available (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#v","title":"v","text":"<ul> <li>VelodyneStatus (nebula::VelodyneStatus)</li> <li>VelodyneType (nebula::VelodyneStatus)</li> <li>versionMajor (nebula::drivers::HesaiCorrection)</li> <li>versionMinor (nebula::drivers::HesaiCorrection)</li> <li>VelodyneCalibration (nebula::drivers::VelodyneCalibration)</li> <li>velodyne_calibration (nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>vert_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_members/#w","title":"w","text":"<ul> <li>write (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_members/#x","title":"x","text":"<ul> <li>x (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_members/#y","title":"y","text":"<ul> <li>y (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_members/#z","title":"z","text":"<ul> <li>z (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_members/#_","title":"_","text":"<ul> <li>_hesai_type (nebula::HesaiStatus)</li> <li>_type_num (nebula::HesaiStatus, nebula::VelodyneStatus)</li> <li>_type (nebula::Status)</li> <li>_velo_type (nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_common/class_member_functions/#g","title":"g","text":"<ul> <li>getAzimuthAdjustV3 (nebula::drivers::HesaiCorrection)</li> <li>getElevationAdjustV3 (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiStatus (nebula::HesaiStatus)</li> </ul>"},{"location":"nebula_common/class_member_functions/#l","title":"l","text":"<ul> <li>LoadFromFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::HesaiCorrection, nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>LoadFromString (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>LoadFromBinary (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_member_functions/#r","title":"r","text":"<ul> <li>read (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#s","title":"s","text":"<ul> <li>Status (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> <li>SaveFile (nebula::drivers::HesaiCalibrationConfiguration, nebula::drivers::VelodyneCalibrationConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#t","title":"t","text":"<ul> <li>type (nebula::HesaiStatus, nebula::Status, nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneStatus (nebula::VelodyneStatus)</li> <li>VelodyneCalibration (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_functions/#w","title":"w","text":"<ul> <li>write (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_common/class_member_variables/#a","title":"a","text":"<ul> <li>azimuth_offset_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>azimuth (nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>azimuthOffset (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#c","title":"c","text":"<ul> <li>calibration_file (nebula::drivers::CalibrationConfigurationBase)</li> <li>channelNumber (nebula::drivers::HesaiCorrection)</li> <li>cloud_max_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>cloud_min_angle (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>count (nebula::drivers::PointField)</li> <li>channel (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRCAEDT)</li> <li>coordinate_mode (nebula::drivers::SensorConfigurationBase)</li> <li>cos_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>cos_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#d","title":"d","text":"<ul> <li>delimiter (nebula::drivers::HesaiCorrection)</li> <li>dual_return_distance_threshold (nebula::drivers::HesaiSensorConfiguration)</li> <li>datatype (nebula::drivers::PointField)</li> <li>distance (nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>data_port (nebula::drivers::SensorConfigurationBase)</li> <li>distance_resolution_m (nebula::drivers::VelodyneCalibration)</li> <li>dist_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_x (nebula::drivers::VelodyneLaserCorrection)</li> <li>dist_correction_y (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#e","title":"e","text":"<ul> <li>elev_angle_map (nebula::drivers::HesaiCalibrationConfiguration)</li> <li>elevation (nebula::drivers::HesaiCorrection, nebula::drivers::PointXYZIRCAEDT)</li> <li>elevationOffset (nebula::drivers::HesaiCorrection)</li> <li>endFrame (nebula::drivers::HesaiCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#f","title":"f","text":"<ul> <li>frameConfig (nebula::drivers::HesaiCorrection)</li> <li>frameNumber (nebula::drivers::HesaiCorrection)</li> <li>fields (nebula::drivers::SensorConfigurationBase)</li> <li>frame_id (nebula::drivers::SensorConfigurationBase)</li> <li>frequency_ms (nebula::drivers::SensorConfigurationBase)</li> <li>focal_distance (nebula::drivers::VelodyneLaserCorrection)</li> <li>focal_slope (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#g","title":"g","text":"<ul> <li>gnss_port (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> </ul>"},{"location":"nebula_common/class_member_variables/#h","title":"h","text":"<ul> <li>host_ip (nebula::drivers::SensorConfigurationBase)</li> <li>horiz_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#i","title":"i","text":"<ul> <li>intensity (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>initialized (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_variables/#l","title":"l","text":"<ul> <li>laser_corrections (nebula::drivers::VelodyneCalibration)</li> <li>laser_corrections_map (nebula::drivers::VelodyneCalibration)</li> <li>laser_ring (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#m","title":"m","text":"<ul> <li>mirrorNumber (nebula::drivers::HesaiCorrection)</li> <li>max_range (nebula::drivers::SensorConfigurationBase)</li> <li>min_range (nebula::drivers::SensorConfigurationBase)</li> <li>max_intensity (nebula::drivers::VelodyneLaserCorrection)</li> <li>min_intensity (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#n","title":"n","text":"<ul> <li>name (nebula::drivers::PointField)</li> <li>num_lasers (nebula::drivers::VelodyneCalibration)</li> </ul>"},{"location":"nebula_common/class_member_variables/#o","title":"o","text":"<ul> <li>offset (nebula::drivers::PointField)</li> </ul>"},{"location":"nebula_common/class_member_variables/#p","title":"p","text":"<ul> <li>PCL_ADD_POINT4D (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>packet_mtu_size (nebula::drivers::SensorConfigurationBase)</li> </ul>"},{"location":"nebula_common/class_member_variables/#r","title":"r","text":"<ul> <li>resolution (nebula::drivers::HesaiCorrection)</li> <li>rotation_speed (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>return_type (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>ring (nebula::drivers::PointXYZIR, nebula::drivers::PointXYZIRADT)</li> <li>remove_nans (nebula::drivers::SensorConfigurationBase)</li> <li>return_mode (nebula::drivers::SensorConfigurationBase)</li> <li>ros_info (nebula::drivers::VelodyneCalibration)</li> <li>rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#s","title":"s","text":"<ul> <li>SHA256 (nebula::drivers::HesaiCorrection)</li> <li>STEP3 (nebula::drivers::HesaiCorrection)</li> <li>startFrame (nebula::drivers::HesaiCorrection)</li> <li>scan_phase (nebula::drivers::HesaiSensorConfiguration, nebula::drivers::VelodyneSensorConfiguration)</li> <li>sensor_ip (nebula::drivers::SensorConfigurationBase)</li> <li>sensor_model (nebula::drivers::SensorConfigurationBase)</li> <li>sin_rot_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>sin_vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#t","title":"t","text":"<ul> <li>time_stamp (nebula::drivers::PointXYZICATR, nebula::drivers::PointXYZIRADT, nebula::drivers::PointXYZIRCAEDT)</li> <li>two_pt_correction_available (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#v","title":"v","text":"<ul> <li>versionMajor (nebula::drivers::HesaiCorrection)</li> <li>versionMinor (nebula::drivers::HesaiCorrection)</li> <li>velodyne_calibration (nebula::drivers::VelodyneCalibrationConfiguration)</li> <li>vert_correction (nebula::drivers::VelodyneLaserCorrection)</li> <li>vert_offset_correction (nebula::drivers::VelodyneLaserCorrection)</li> </ul>"},{"location":"nebula_common/class_member_variables/#x","title":"x","text":"<ul> <li>x (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_member_variables/#y","title":"y","text":"<ul> <li>y (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_member_variables/#z","title":"z","text":"<ul> <li>z (nebula::drivers::PointXYZIRCAEDT)</li> </ul>"},{"location":"nebula_common/class_member_variables/#_","title":"_","text":"<ul> <li>_hesai_type (nebula::HesaiStatus)</li> <li>_type_num (nebula::HesaiStatus, nebula::VelodyneStatus)</li> <li>_type (nebula::Status)</li> <li>_velo_type (nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_common/class_member_enums/","title":"Class Member Enums","text":""},{"location":"nebula_common/class_member_enums/#h","title":"h","text":"<ul> <li>HesaiType (nebula::HesaiStatus)</li> </ul>"},{"location":"nebula_common/class_member_enums/#t","title":"t","text":"<ul> <li>Type (nebula::Status)</li> </ul>"},{"location":"nebula_common/class_member_enums/#v","title":"v","text":"<ul> <li>VelodyneType (nebula::VelodyneStatus)</li> </ul>"},{"location":"nebula_common/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_common/namespace_members/#c","title":"c","text":"<ul> <li>CoordinateMode (nebula::drivers)</li> <li>convertPointXYZIRADTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIRADT (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#d","title":"d","text":"<ul> <li>datatype (nebula::drivers)</li> <li>deg2rad (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#e","title":"e","text":"<ul> <li>EIGEN_ALIGN16 (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#i","title":"i","text":"<ul> <li>IntFromReturnModeHesai (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#n","title":"n","text":"<ul> <li>NebulaPoint (nebula::drivers)</li> <li>NebulaPointCloud (nebula::drivers)</li> <li>NebulaPointCloudPtr (nebula::drivers)</li> <li>NebulaPointPtr (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#r","title":"r","text":"<ul> <li>ReturnMode (nebula::drivers)</li> <li>ReturnModeFromIntHesai (nebula::drivers)</li> <li>ReturnModeFromString (nebula::drivers)</li> <li>ReturnModeFromStringHesai (nebula::drivers)</li> <li>ReturnModeFromStringVelodyne (nebula::drivers)</li> <li>ReturnModeToInt (nebula::drivers)</li> <li>ReturnModeToReturnType (nebula::drivers)</li> <li>ReturnType (nebula::drivers)</li> <li>rad2deg (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_members/#s","title":"s","text":"<ul> <li>SensorModel (nebula::drivers)</li> <li>SensorModelFromString (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"nebula_common/namespace_member_functions/#c","title":"c","text":"<ul> <li>convertPointXYZIRADTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIR (nebula::drivers)</li> <li>convertPointXYZIRCAEDTToPointXYZIRADT (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#d","title":"d","text":"<ul> <li>deg2rad (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#i","title":"i","text":"<ul> <li>IntFromReturnModeHesai (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#r","title":"r","text":"<ul> <li>ReturnModeFromIntHesai (nebula::drivers)</li> <li>ReturnModeFromString (nebula::drivers)</li> <li>ReturnModeFromStringHesai (nebula::drivers)</li> <li>ReturnModeFromStringVelodyne (nebula::drivers)</li> <li>ReturnModeToInt (nebula::drivers)</li> <li>ReturnModeToReturnType (nebula::drivers)</li> <li>rad2deg (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_functions/#s","title":"s","text":"<ul> <li>SensorModelFromString (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"nebula_common/namespace_member_variables/#e","title":"e","text":"<ul> <li>EIGEN_ALIGN16 (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"nebula_common/namespace_member_typedefs/#n","title":"n","text":"<ul> <li>NebulaPoint (nebula::drivers)</li> <li>NebulaPointCloud (nebula::drivers)</li> <li>NebulaPointCloudPtr (nebula::drivers)</li> <li>NebulaPointPtr (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"nebula_common/namespace_member_enums/#c","title":"c","text":"<ul> <li>CoordinateMode (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#d","title":"d","text":"<ul> <li>datatype (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#r","title":"r","text":"<ul> <li>ReturnMode (nebula::drivers)</li> <li>ReturnType (nebula::drivers)</li> </ul>"},{"location":"nebula_common/namespace_member_enums/#s","title":"s","text":"<ul> <li>SensorModel (nebula::drivers)</li> </ul>"},{"location":"nebula_common/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_common/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_common/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_common/links/","title":"Nebula Common","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"nebula_decoders/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace drivers <ul> <li>class HesaiDriver Hesai driver. </li> <li>class HesaiScanDecoder Base class for Hesai LiDAR decoder. </li> <li>class NebulaDriverBase Base class for each sensor driver. </li> <li>class VelodyneDriver Velodyne driver. </li> <li>class VelodyneScanDecoder Base class for Velodyne LiDAR decoder. </li> <li>namespace pandar_128_e4x <ul> <li>struct Block </li> <li>struct BlockExtended </li> <li>struct Body </li> <li>struct BodyExtended </li> <li>struct DateTime </li> <li>struct FunctionalSafety </li> <li>struct Header </li> <li>struct Packet </li> <li>struct PacketExtended </li> <li>class Pandar128E4XDecoder </li> <li>struct Tail </li> </ul> </li> <li>namespace pandar_40 <ul> <li>struct Block </li> <li>struct Packet </li> <li>class Pandar40Decoder Hesai LiDAR decoder (Pandar40) </li> <li>struct Unit </li> </ul> </li> <li>namespace pandar_64 <ul> <li>struct Block </li> <li>struct Header </li> <li>struct Packet </li> <li>class Pandar64Decoder Hesai LiDAR decoder (Pandar64) </li> <li>struct Unit </li> </ul> </li> <li>namespace pandar_at <ul> <li>struct Block </li> <li>struct Header </li> <li>struct Packet </li> <li>class PandarATDecoder Hesai LiDAR decoder (AT128) </li> <li>struct Unit </li> </ul> </li> <li>namespace pandar_qt_128 <ul> <li>struct Block </li> <li>struct Header </li> <li>struct Packet </li> <li>class PandarQT128Decoder Hesai LiDAR decoder (QT128) </li> <li>struct Unit </li> </ul> </li> <li>namespace pandar_qt_64 <ul> <li>struct Block </li> <li>struct Header </li> <li>struct Packet </li> <li>class PandarQT64Decoder Hesai LiDAR decoder (QT64) </li> <li>struct Unit </li> </ul> </li> <li>namespace pandar_xt <ul> <li>struct Block </li> <li>struct Header </li> <li>struct Packet </li> <li>class PandarXTDecoder Hesai LiDAR decoder (XT32) </li> <li>struct Unit </li> </ul> </li> <li>namespace pandar_xtm <ul> <li>struct Block </li> <li>struct Header </li> <li>struct Packet </li> <li>class PandarXTMDecoder Hesai LiDAR decoder (XT32M) </li> <li>struct Unit </li> </ul> </li> <li>struct raw_block Raw Velodyne data block. </li> <li>struct raw_packet Raw Velodyne packet. </li> <li>union two_bytes </li> <li>namespace vlp16 <ul> <li>class Vlp16Decoder Velodyne LiDAR decoder (VLP16) </li> </ul> </li> <li>namespace vlp32 <ul> <li>class Vlp32Decoder Velodyne LiDAR decoder (VLP32) </li> </ul> </li> <li>namespace vls128 <ul> <li>class Vls128Decoder Velodyne LiDAR decoder (VLS128) </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_decoders/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_decoders <ul> <li>dir include <ul> <li>dir nebula_decoders <ul> <li>dir nebula_decoders_common <ul> <li>file nebula_driver_base.hpp </li> </ul> </li> <li>dir nebula_decoders_hesai <ul> <li>file hesai_driver.hpp </li> <li>dir decoders <ul> <li>file hesai_scan_decoder.hpp </li> <li>file pandar_128_e4x.hpp </li> <li>file pandar_128_e4x_decoder.hpp </li> <li>file pandar_40.hpp </li> <li>file pandar_40_decoder.hpp </li> <li>file pandar_64.hpp </li> <li>file pandar_64_decoder.hpp </li> <li>file pandar_at.hpp </li> <li>file pandar_at_decoder.hpp </li> <li>file pandar_qt_128.hpp </li> <li>file pandar_qt_128_decoder.hpp </li> <li>file pandar_qt_64.hpp </li> <li>file pandar_qt_64_decoder.hpp </li> <li>file pandar_xt.hpp </li> <li>file pandar_xt_decoder.hpp </li> <li>file pandar_xtm.hpp </li> <li>file pandar_xtm_decoder.hpp </li> </ul> </li> </ul> </li> <li>dir nebula_decoders_velodyne <ul> <li>dir decoders <ul> <li>file velodyne_scan_decoder.hpp </li> <li>file vlp16_decoder.hpp </li> <li>file vlp32_decoder.hpp </li> <li>file vls128_decoder.hpp </li> </ul> </li> <li>file velodyne_driver.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_decoders/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p> <p>More...</p>"},{"location":"nebula_decoders/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace drivers"},{"location":"nebula_decoders/namespacenebula/#detailed-description","title":"Detailed Description","text":"<p>Pandar 128 E4X</p> <p>Pandar 40P</p> <p>Pandar 64</p> <p>Pandar XT-AT128</p> <p>Pandar QT128</p> <p>Pandar QT64</p> <p>Pandar XT-32</p> <p>Pandar XT-32M </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/","title":"Namespace nebula::drivers","text":"<p>Namespace List &gt; nebula &gt; drivers</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#namespaces","title":"Namespaces","text":"Type Name namespace pandar_128_e4x namespace pandar_40 namespace pandar_64 namespace pandar_at namespace pandar_qt_128 namespace pandar_qt_64 namespace pandar_xt namespace pandar_xtm namespace vlp16 namespace vlp32 namespace vls128"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#classes","title":"Classes","text":"Type Name class HesaiDriver Hesai driver. class HesaiScanDecoder Base class for Hesai LiDAR decoder. class NebulaDriverBase Base class for each sensor driver. class VelodyneDriver Velodyne driver. class VelodyneScanDecoder Base class for Velodyne LiDAR decoder. struct raw_block Raw Velodyne data block. struct raw_packet Raw Velodyne packet."},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-types","title":"Public Types","text":"Type Name enum RETURN_TYPE Velodyne echo types. union two_bytes typedef struct nebula::drivers::raw_block raw_block_t Raw Velodyne data block. typedef struct nebula::drivers::raw_packet raw_packet_t Raw Velodyne packet."},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int BLOCKS_PER_PACKET   = = 12 const int BLOCK_DATA_SIZE   = = (SCANS_PER_BLOCK * RAW_SCAN_SIZE) const uint16_t LOWER_BANK   = = 0xddff const int PACKET_SIZE   = = 1206 const int PACKET_STATUS_SIZE   = = 4 const int RAW_SCAN_SIZE   = = 3 const uint16_t RETURN_MODE_DUAL   = = 57 const size_t RETURN_MODE_INDEX   = = 1204 const uint16_t RETURN_MODE_LAST   = = 56 const uint16_t RETURN_MODE_STRONGEST   = = 55 const uint16_t ROTATION_MAX_UNITS   = = 36000u const double ROTATION_RESOLUTION   = = 0.01 const int SCANS_PER_BLOCK   = = 32 const int SCANS_PER_PACKET   = = (SCANS_PER_BLOCK * BLOCKS_PER_PACKET) const int SIZE_BLOCK   = = 100 const uint16_t UPPER_BANK   = = 0xeeff const float VLP128_DISTANCE_RESOLUTION   = = 0.004f const float VLP16_BLOCK_DURATION   = = 110.592f const float VLP16_DSR_TOFFSET   = = 2.304f const int VLP16_FIRINGS_PER_BLOCK   = = 2 const float VLP16_FIRING_TOFFSET   = = 55.296f const int VLP16_SCANS_PER_FIRING   = = 16 const uint16_t VLS128_BANK_1   = = 0xeeff const uint16_t VLS128_BANK_2   = = 0xddff const uint16_t VLS128_BANK_3   = = 0xccff const uint16_t VLS128_BANK_4   = = 0xbbff const float VLS128_CHANNEL_DURATION   = = 2.665f const float VLS128_SEQ_DURATION   = = 53.3f"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers/#enum-return_type","title":"enum RETURN_TYPE","text":"<pre><code>enum nebula::drivers::RETURN_TYPE {\nINVALID = 0,\nSINGLE_STRONGEST = 1,\nSINGLE_LAST = 2,\nDUAL_STRONGEST_FIRST = 3,\nDUAL_STRONGEST_LAST = 4,\nDUAL_WEAK_FIRST = 5,\nDUAL_WEAK_LAST = 6,\nDUAL_ONLY = 7\n};\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#union-two_bytes","title":"union two_bytes","text":"<p>used for unpacking the first two data bytes in a block</p> <p>They are packed into the actual data stream misaligned. I doubt this works on big endian machines. </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#typedef-raw_block_t","title":"typedef raw_block_t","text":"<p>Raw Velodyne data block. <pre><code>typedef struct nebula::drivers::raw_block nebula::drivers::raw_block_t;\n</code></pre></p> <p>Each block contains data from either the upper or lower laser bank. The device returns three times as many upper bank blocks.</p> <p>use stdint.h types, so things work with both 64 and 32-bit machines </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#typedef-raw_packet_t","title":"typedef raw_packet_t","text":"<p>Raw Velodyne packet. <pre><code>typedef struct nebula::drivers::raw_packet nebula::drivers::raw_packet_t;\n</code></pre></p> <p>revolution is described in the device manual as incrementing (mod 65536) for each physical turn of the device. Our device seems to alternate between two different values every third packet. One value increases, the other decreases.</p> <p>Todo</p> <p>figure out if revolution is only present for one of the two types of status fields</p> <p>status has either a temperature encoding or the microcode level </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>const int nebula::drivers::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-block_data_size","title":"variable BLOCK_DATA_SIZE","text":"<pre><code>const int nebula::drivers::BLOCK_DATA_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-lower_bank","title":"variable LOWER_BANK","text":"<pre><code>const uint16_t nebula::drivers::LOWER_BANK;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>const int nebula::drivers::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-packet_status_size","title":"variable PACKET_STATUS_SIZE","text":"<pre><code>const int nebula::drivers::PACKET_STATUS_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-raw_scan_size","title":"variable RAW_SCAN_SIZE","text":"<pre><code>const int nebula::drivers::RAW_SCAN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_dual","title":"variable RETURN_MODE_DUAL","text":"<pre><code>const uint16_t nebula::drivers::RETURN_MODE_DUAL;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_index","title":"variable RETURN_MODE_INDEX","text":"<pre><code>const size_t nebula::drivers::RETURN_MODE_INDEX;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_last","title":"variable RETURN_MODE_LAST","text":"<pre><code>const uint16_t nebula::drivers::RETURN_MODE_LAST;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-return_mode_strongest","title":"variable RETURN_MODE_STRONGEST","text":"<pre><code>const uint16_t nebula::drivers::RETURN_MODE_STRONGEST;\n</code></pre> <p>Return Modes </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-rotation_max_units","title":"variable ROTATION_MAX_UNITS","text":"<pre><code>const uint16_t nebula::drivers::ROTATION_MAX_UNITS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-rotation_resolution","title":"variable ROTATION_RESOLUTION","text":"<pre><code>const double nebula::drivers::ROTATION_RESOLUTION;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-scans_per_block","title":"variable SCANS_PER_BLOCK","text":"<pre><code>const int nebula::drivers::SCANS_PER_BLOCK;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-scans_per_packet","title":"variable SCANS_PER_PACKET","text":"<pre><code>const int nebula::drivers::SCANS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-size_block","title":"variable SIZE_BLOCK","text":"<pre><code>const int nebula::drivers::SIZE_BLOCK;\n</code></pre> <p>Raw Velodyne packet constants and structures. </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-upper_bank","title":"variable UPPER_BANK","text":"<pre><code>const uint16_t nebula::drivers::UPPER_BANK;\n</code></pre> <p>Todo</p> <p>make this work for both big and little-endian machines </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp128_distance_resolution","title":"variable VLP128_DISTANCE_RESOLUTION","text":"<pre><code>const float nebula::drivers::VLP128_DISTANCE_RESOLUTION;\n</code></pre> <p>Special Definitions for VLS128 support </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_block_duration","title":"variable VLP16_BLOCK_DURATION","text":"<pre><code>const float nebula::drivers::VLP16_BLOCK_DURATION;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_dsr_toffset","title":"variable VLP16_DSR_TOFFSET","text":"<pre><code>const float nebula::drivers::VLP16_DSR_TOFFSET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_firings_per_block","title":"variable VLP16_FIRINGS_PER_BLOCK","text":"<pre><code>const int nebula::drivers::VLP16_FIRINGS_PER_BLOCK;\n</code></pre> <p>Special Defines for VLP16 support </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_firing_toffset","title":"variable VLP16_FIRING_TOFFSET","text":"<pre><code>const float nebula::drivers::VLP16_FIRING_TOFFSET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vlp16_scans_per_firing","title":"variable VLP16_SCANS_PER_FIRING","text":"<pre><code>const int nebula::drivers::VLP16_SCANS_PER_FIRING;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_1","title":"variable VLS128_BANK_1","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_1;\n</code></pre> <p>Special Definitions for VLS128 support </p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_2","title":"variable VLS128_BANK_2","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_2;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_3","title":"variable VLS128_BANK_3","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_3;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_bank_4","title":"variable VLS128_BANK_4","text":"<pre><code>const uint16_t nebula::drivers::VLS128_BANK_4;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_channel_duration","title":"variable VLS128_CHANNEL_DURATION","text":"<pre><code>const float nebula::drivers::VLS128_CHANNEL_DURATION;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers/#variable-vls128_seq_duration","title":"variable VLS128_SEQ_DURATION","text":"<pre><code>const float nebula::drivers::VLS128_SEQ_DURATION;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/","title":"Class nebula::drivers::HesaiDriver","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiDriver</p> <p>Hesai driver. </p> <ul> <li><code>#include &lt;hesai_driver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaDriverBase</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#public-functions","title":"Public Functions","text":"Type Name std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; ConvertScanToPointcloud (const std::shared_ptr&lt; pandar_msgs::msg::PandarScan &gt; &amp; pandar_scan) Convert PandarScan message to point cloud. Status GetStatus () Get current status of this driver. HesaiDriver () = delete HesaiDriver (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration, const std::shared_ptr&lt; drivers::HesaiCorrection &gt; &amp; correction_configuration=nullptr) Constructor. virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) overrideSetting CalibrationConfiguration (not used)"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#public-functions-inherited-from-nebuladriversnebuladriverbase","title":"Public Functions inherited from nebula::drivers::NebulaDriverBase","text":"<p>See nebula::drivers::NebulaDriverBase</p> Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-convertscantopointcloud","title":"function ConvertScanToPointcloud","text":"<p>Convert PandarScan message to point cloud. <pre><code>std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::HesaiDriver::ConvertScanToPointcloud (\nconst std::shared_ptr&lt; pandar_msgs::msg::PandarScan &gt; &amp; pandar_scan\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_scan</code> Message </li> </ul> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::drivers::HesaiDriver::GetStatus () </code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-hesaidriver-12","title":"function HesaiDriver [1/2]","text":"<pre><code>nebula::drivers::HesaiDriver::HesaiDriver () = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-hesaidriver-22","title":"function HesaiDriver [2/2]","text":"<p>Constructor. <pre><code>explicit nebula::drivers::HesaiDriver::HesaiDriver (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCorrection &gt; &amp; correction_configuration=nullptr\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> <li><code>calibration_configuration</code> CalibrationConfiguration for this driver </li> <li><code>correction_configuration</code> CorrectionConfiguration for this driver (for AT) </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiDriver/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Setting CalibrationConfiguration (not used) <pre><code>virtual Status nebula::drivers::HesaiDriver::SetCalibrationConfiguration (\nconst CalibrationConfigurationBase &amp; calibration_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/","title":"Class nebula::drivers::HesaiScanDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiScanDecoder</p> <p>Base class for Hesai LiDAR decoder. </p> <ul> <li><code>#include &lt;hesai_scan_decoder.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder,  nebula::drivers::pandar_40::Pandar40Decoder,  nebula::drivers::pandar_64::Pandar64Decoder,  nebula::drivers::pandar_at::PandarATDecoder,  nebula::drivers::pandar_qt_128::PandarQT128Decoder,  nebula::drivers::pandar_qt_64::PandarQT64Decoder,  nebula::drivers::pandar_xt::PandarXTDecoder,  nebula::drivers::pandar_xtm::PandarXTMDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#public-functions","title":"Public Functions","text":"Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#protected-attributes","title":"Protected Attributes","text":"Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder-13","title":"function HesaiScanDecoder [1/3]","text":"<pre><code>nebula::drivers::HesaiScanDecoder::HesaiScanDecoder (\nHesaiScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder-23","title":"function HesaiScanDecoder [2/3]","text":"<pre><code>nebula::drivers::HesaiScanDecoder::HesaiScanDecoder (\nconst HesaiScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder-33","title":"function HesaiScanDecoder [3/3]","text":"<pre><code>nebula::drivers::HesaiScanDecoder::HesaiScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-convert","title":"function convert","text":"<p>Virtual function for converting to point cloud. <pre><code>virtual drivers::NebulaPointCloudPtr nebula::drivers::HesaiScanDecoder::convert (\nsize_t block_id\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> target block </li> </ul> <p>Returns:</p> <p>Point cloud </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-convert_dual","title":"function convert_dual","text":"<p>Virtual function for converting to point cloud for dual return. <pre><code>virtual drivers::NebulaPointCloudPtr nebula::drivers::HesaiScanDecoder::convert_dual (\nsize_t block_id\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>block_id</code> target block </li> </ul> <p>Returns:</p> <p>Point cloud </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Virtual function for getting the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::HesaiScanDecoder::get_pointcloud () = 0\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Virtual function for getting the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::HesaiScanDecoder::hasScanned () = 0\n</code></pre></p> <p>Returns:</p> <p>Readied </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-operator","title":"function operator=","text":"<pre><code>HesaiScanDecoder &amp; nebula::drivers::HesaiScanDecoder::operator= (\nHesaiScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-operator_1","title":"function operator=","text":"<pre><code>HesaiScanDecoder &amp; nebula::drivers::HesaiScanDecoder::operator= (\nconst HesaiScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-parsepacket","title":"function parsePacket","text":"<p>Virtual function for parsing PandarPacket based on packet structure. <pre><code>virtual bool nebula::drivers::HesaiScanDecoder::parsePacket (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Returns:</p> <p>Resulting flag </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-unpack","title":"function unpack","text":"<p>Virtual function for parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::HesaiScanDecoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#function-hesaiscandecoder","title":"function ~HesaiScanDecoder","text":"<pre><code>virtual nebula::drivers::HesaiScanDecoder::~HesaiScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-dual_return_distance_threshold_","title":"variable dual_return_distance_threshold_","text":"<pre><code>double nebula::drivers::HesaiScanDecoder::dual_return_distance_threshold_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-has_scanned_","title":"variable has_scanned_","text":"<pre><code>bool nebula::drivers::HesaiScanDecoder::has_scanned_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-last_phase_","title":"variable last_phase_","text":"<pre><code>int nebula::drivers::HesaiScanDecoder::last_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-overflow_pc_","title":"variable overflow_pc_","text":"<pre><code>drivers::NebulaPointCloudPtr nebula::drivers::HesaiScanDecoder::overflow_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-scan_pc_","title":"variable scan_pc_","text":"<pre><code>drivers::NebulaPointCloudPtr nebula::drivers::HesaiScanDecoder::scan_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-scan_phase_","title":"variable scan_phase_","text":"<pre><code>uint16_t nebula::drivers::HesaiScanDecoder::scan_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-scan_timestamp_","title":"variable scan_timestamp_","text":"<pre><code>double nebula::drivers::HesaiScanDecoder::scan_timestamp_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-sensor_calibration_","title":"variable sensor_calibration_","text":"<pre><code>std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; nebula::drivers::HesaiScanDecoder::sensor_calibration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1HesaiScanDecoder/#variable-sensor_configuration_","title":"variable sensor_configuration_","text":"<pre><code>std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; nebula::drivers::HesaiScanDecoder::sensor_configuration_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/","title":"Class nebula::drivers::NebulaDriverBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; NebulaDriverBase</p> <p>Base class for each sensor driver. </p> <ul> <li><code>#include &lt;nebula_driver_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiDriver,  nebula::drivers::VelodyneDriver</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#public-functions","title":"Public Functions","text":"Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-nebuladriverbase-13","title":"function NebulaDriverBase [1/3]","text":"<pre><code>nebula::drivers::NebulaDriverBase::NebulaDriverBase (\nNebulaDriverBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-nebuladriverbase-23","title":"function NebulaDriverBase [2/3]","text":"<pre><code>nebula::drivers::NebulaDriverBase::NebulaDriverBase (\nconst NebulaDriverBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-nebuladriverbase-33","title":"function NebulaDriverBase [3/3]","text":"<pre><code>nebula::drivers::NebulaDriverBase::NebulaDriverBase () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Virtual function for setting calibration configuration. <pre><code>virtual Status nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration (\nconst CalibrationConfigurationBase &amp; calibration_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration including file path </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaDriverBase &amp; nebula::drivers::NebulaDriverBase::operator= (\nNebulaDriverBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1NebulaDriverBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaDriverBase &amp; nebula::drivers::NebulaDriverBase::operator= (\nconst NebulaDriverBase &amp; c\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/","title":"Class nebula::drivers::VelodyneDriver","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneDriver</p> <p>Velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_driver.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaDriverBase</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#public-functions","title":"Public Functions","text":"Type Name std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; ConvertScanToPointcloud (const std::shared_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt; &amp; velodyne_scan) Convert VelodyneScan message to point cloud. Status GetStatus () Get current status of this driver. virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) overrideSetting CalibrationConfiguration (not used) VelodyneDriver () = delete VelodyneDriver (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#public-functions-inherited-from-nebuladriversnebuladriverbase","title":"Public Functions inherited from nebula::drivers::NebulaDriverBase","text":"<p>See nebula::drivers::NebulaDriverBase</p> Type Name NebulaDriverBase (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase (const NebulaDriverBase &amp; c) = delete NebulaDriverBase () = default virtual Status SetCalibrationConfiguration (const CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for setting calibration configuration. NebulaDriverBase &amp; operator= (NebulaDriverBase &amp;&amp; c) = delete NebulaDriverBase &amp; operator= (const NebulaDriverBase &amp; c) = delete"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-convertscantopointcloud","title":"function ConvertScanToPointcloud","text":"<p>Convert VelodyneScan message to point cloud. <pre><code>std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::VelodyneDriver::ConvertScanToPointcloud (\nconst std::shared_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt; &amp; velodyne_scan\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_scan</code> Message </li> </ul> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::drivers::VelodyneDriver::GetStatus () </code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-setcalibrationconfiguration","title":"function SetCalibrationConfiguration","text":"<p>Setting CalibrationConfiguration (not used) <pre><code>virtual Status nebula::drivers::VelodyneDriver::SetCalibrationConfiguration (\nconst CalibrationConfigurationBase &amp; calibration_configuration\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaDriverBase::SetCalibrationConfiguration</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-velodynedriver-12","title":"function VelodyneDriver [1/2]","text":"<pre><code>nebula::drivers::VelodyneDriver::VelodyneDriver () = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneDriver/#function-velodynedriver-22","title":"function VelodyneDriver [2/2]","text":"<p>Constructor. <pre><code>nebula::drivers::VelodyneDriver::VelodyneDriver (\nconst std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> <li><code>calibration_configuration</code> CalibrationConfiguration for this driver </li> </ul> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/","title":"Class nebula::drivers::VelodyneScanDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneScanDecoder</p> <p>Base class for Velodyne LiDAR decoder. </p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::vlp16::Vlp16Decoder,  nebula::drivers::vlp32::Vlp32Decoder,  nebula::drivers::vls128::Vls128Decoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#public-functions","title":"Public Functions","text":"Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow () = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#protected-attributes","title":"Protected Attributes","text":"Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder-13","title":"function VelodyneScanDecoder [1/3]","text":"<pre><code>nebula::drivers::VelodyneScanDecoder::VelodyneScanDecoder (\nVelodyneScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder-23","title":"function VelodyneScanDecoder [2/3]","text":"<pre><code>nebula::drivers::VelodyneScanDecoder::VelodyneScanDecoder (\nconst VelodyneScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder-33","title":"function VelodyneScanDecoder [3/3]","text":"<pre><code>nebula::drivers::VelodyneScanDecoder::VelodyneScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Virtual function for getting the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::VelodyneScanDecoder::get_pointcloud () = 0\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Virtual function for getting the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::VelodyneScanDecoder::hasScanned () = 0\n</code></pre></p> <p>Returns:</p> <p>Readied </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-operator","title":"function operator=","text":"<pre><code>VelodyneScanDecoder &amp; nebula::drivers::VelodyneScanDecoder::operator= (\nVelodyneScanDecoder &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-operator_1","title":"function operator=","text":"<pre><code>VelodyneScanDecoder &amp; nebula::drivers::VelodyneScanDecoder::operator= (\nconst VelodyneScanDecoder &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-parsepacket","title":"function parsePacket","text":"<p>Virtual function for parsing VelodynePacket based on packet structure. <pre><code>virtual bool nebula::drivers::VelodyneScanDecoder::parsePacket (\nconst velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Returns:</p> <p>Resulting flag </p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::VelodyneScanDecoder::pointsPerPacket () = 0\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#of-points","title":"of points","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::VelodyneScanDecoder::reset_overflow () = 0\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::VelodyneScanDecoder::reset_pointcloud (\nsize_t n_pts\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-unpack","title":"function unpack","text":"<p>Virtual function for parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::VelodyneScanDecoder::unpack (\nconst velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#function-velodynescandecoder","title":"function ~VelodyneScanDecoder","text":"<pre><code>virtual nebula::drivers::VelodyneScanDecoder::~VelodyneScanDecoder () = default\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-calibration_configuration_","title":"variable calibration_configuration_","text":"<pre><code>std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; nebula::drivers::VelodyneScanDecoder::calibration_configuration_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-dual_return_distance_threshold_","title":"variable dual_return_distance_threshold_","text":"<pre><code>double nebula::drivers::VelodyneScanDecoder::dual_return_distance_threshold_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-has_scanned_","title":"variable has_scanned_","text":"<pre><code>bool nebula::drivers::VelodyneScanDecoder::has_scanned_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-last_phase_","title":"variable last_phase_","text":"<pre><code>uint16_t nebula::drivers::VelodyneScanDecoder::last_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-overflow_pc_","title":"variable overflow_pc_","text":"<pre><code>drivers::NebulaPointCloudPtr nebula::drivers::VelodyneScanDecoder::overflow_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-scan_pc_","title":"variable scan_pc_","text":"<pre><code>drivers::NebulaPointCloudPtr nebula::drivers::VelodyneScanDecoder::scan_pc_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-scan_phase_","title":"variable scan_phase_","text":"<pre><code>uint16_t nebula::drivers::VelodyneScanDecoder::scan_phase_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-scan_timestamp_","title":"variable scan_timestamp_","text":"<pre><code>double nebula::drivers::VelodyneScanDecoder::scan_timestamp_;\n</code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1VelodyneScanDecoder/#variable-sensor_configuration_","title":"variable sensor_configuration_","text":"<pre><code>std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; nebula::drivers::VelodyneScanDecoder::sensor_configuration_;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/","title":"Namespace nebula::drivers::pandar_128_e4x","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_128_e4x</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#classes","title":"Classes","text":"Type Name struct Block struct BlockExtended struct Body struct BodyExtended struct DateTime struct FunctionalSafety struct Header struct Packet struct PacketExtended class Pandar128E4XDecoder struct Tail"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint16_t BODY_SIZE   = = 776 constexpr float DISTANCE_UNIT   = = 0.004f constexpr uint8_t DUAL_FIRST_STRONGEST_RETURN   = = 0x3C constexpr uint8_t DUAL_LAST_FIRST_RETURN   = = 0x3B constexpr uint8_t DUAL_LAST_STRONGEST_RETURN   = = 0x39 constexpr uint8_t FUNCTIONAL_SAFETY_SIZE   = = 17 constexpr uint8_t HEADER_SIZE   = = 12 constexpr uint8_t HIGH_RES_STATE   = = 0x00 constexpr size_t LASER_COUNT   = = 128 constexpr uint16_t MAX_AZIMUTH_STEPS   = = 3600 constexpr float MAX_RANGE   = = 230.0 constexpr float MIN_RANGE   = = 0.1 constexpr size_t NUM_BLOCKS   = = 2 constexpr uint16_t PACKET_SIZE   = = HEADER_SIZE + BODY_SIZE + FUNCTIONAL_SAFETY_SIZE + TAIL_SIZE constexpr uint8_t SINGLE_FIRST_RETURN   = = 0x33 constexpr uint8_t SINGLE_LAST_RETURN   = = 0x38 constexpr uint8_t SINGLE_STRONGEST_RETURN   = = 0x37 constexpr uint8_t STANDARD_RES_STATE   = = 0x01 constexpr uint8_t TAIL_SIZE   = = 56 constexpr uint16_t THREE_SIXTY   = = 360 constexpr size_t UNUSED_INT   = = 0"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::pandar_128_e4x::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-distance_unit","title":"variable DISTANCE_UNIT","text":"<pre><code>constexpr float nebula::drivers::pandar_128_e4x::DISTANCE_UNIT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-dual_first_strongest_return","title":"variable DUAL_FIRST_STRONGEST_RETURN","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::DUAL_FIRST_STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-dual_last_first_return","title":"variable DUAL_LAST_FIRST_RETURN","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::DUAL_LAST_FIRST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-dual_last_strongest_return","title":"variable DUAL_LAST_STRONGEST_RETURN","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::DUAL_LAST_STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-functional_safety_size","title":"variable FUNCTIONAL_SAFETY_SIZE","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::FUNCTIONAL_SAFETY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-header_size","title":"variable HEADER_SIZE","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-high_res_state","title":"variable HIGH_RES_STATE","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::HIGH_RES_STATE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_128_e4x::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint16_t nebula::drivers::pandar_128_e4x::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_128_e4x::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_128_e4x::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-num_blocks","title":"variable NUM_BLOCKS","text":"<pre><code>constexpr size_t nebula::drivers::pandar_128_e4x::NUM_BLOCKS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr uint16_t nebula::drivers::pandar_128_e4x::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-single_first_return","title":"variable SINGLE_FIRST_RETURN","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::SINGLE_FIRST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-single_last_return","title":"variable SINGLE_LAST_RETURN","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::SINGLE_LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-single_strongest_return","title":"variable SINGLE_STRONGEST_RETURN","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::SINGLE_STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-standard_res_state","title":"variable STANDARD_RES_STATE","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::STANDARD_RES_STATE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-tail_size","title":"variable TAIL_SIZE","text":"<pre><code>constexpr uint8_t nebula::drivers::pandar_128_e4x::TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-three_sixty","title":"variable THREE_SIXTY","text":"<pre><code>constexpr uint16_t nebula::drivers::pandar_128_e4x::THREE_SIXTY;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__128__e4x/#variable-unused_int","title":"variable UNUSED_INT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_128_e4x::UNUSED_INT;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Block/","title":"Struct nebula::drivers::pandar_128_e4x::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; Block</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t distance uint8_t reflectivity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Block/#variable-distance","title":"variable distance","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Block::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Block/#variable-reflectivity","title":"variable reflectivity","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Block::reflectivity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BlockExtended/","title":"Struct nebula::drivers::pandar_128_e4x::BlockExtended","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; BlockExtended</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BlockExtended/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t distance uint8_t reflectivity uint8_t reserved"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BlockExtended/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BlockExtended/#variable-distance","title":"variable distance","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::BlockExtended::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BlockExtended/#variable-reflectivity","title":"variable reflectivity","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::BlockExtended::reflectivity;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BlockExtended/#variable-reserved","title":"variable reserved","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::BlockExtended::reserved;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/","title":"Struct nebula::drivers::pandar_128_e4x::Body","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; Body</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth_1 uint16_t azimuth_2 Block block_01 Block block_02 uint32_t crc_1"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#variable-azimuth_1","title":"variable azimuth_1","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Body::azimuth_1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#variable-azimuth_2","title":"variable azimuth_2","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Body::azimuth_2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#variable-block_01","title":"variable block_01","text":"<pre><code>Block nebula::drivers::pandar_128_e4x::Body::block_01[LASER_COUNT];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#variable-block_02","title":"variable block_02","text":"<pre><code>Block nebula::drivers::pandar_128_e4x::Body::block_02[LASER_COUNT];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Body/#variable-crc_1","title":"variable crc_1","text":"<pre><code>uint32_t nebula::drivers::pandar_128_e4x::Body::crc_1;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/","title":"Struct nebula::drivers::pandar_128_e4x::BodyExtended","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; BodyExtended</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth_1 uint16_t azimuth_2 BlockExtended block_01 BlockExtended block_02 uint32_t crc_1"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#variable-azimuth_1","title":"variable azimuth_1","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::BodyExtended::azimuth_1;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#variable-azimuth_2","title":"variable azimuth_2","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::BodyExtended::azimuth_2;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#variable-block_01","title":"variable block_01","text":"<pre><code>BlockExtended nebula::drivers::pandar_128_e4x::BodyExtended::block_01[LASER_COUNT];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#variable-block_02","title":"variable block_02","text":"<pre><code>BlockExtended nebula::drivers::pandar_128_e4x::BodyExtended::block_02[LASER_COUNT];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1BodyExtended/#variable-crc_1","title":"variable crc_1","text":"<pre><code>uint32_t nebula::drivers::pandar_128_e4x::BodyExtended::crc_1;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/","title":"Struct nebula::drivers::pandar_128_e4x::DateTime","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; DateTime</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t day uint8_t hour uint8_t minute uint8_t month uint8_t second uint8_t year"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#variable-day","title":"variable day","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::DateTime::day;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#variable-hour","title":"variable hour","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::DateTime::hour;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#variable-minute","title":"variable minute","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::DateTime::minute;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#variable-month","title":"variable month","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::DateTime::month;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#variable-second","title":"variable second","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::DateTime::second;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1DateTime/#variable-year","title":"variable year","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::DateTime::year;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1FunctionalSafety/","title":"Struct nebula::drivers::pandar_128_e4x::FunctionalSafety","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; FunctionalSafety</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1FunctionalSafety/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t reserved"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1FunctionalSafety/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1FunctionalSafety/#variable-reserved","title":"variable reserved","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::FunctionalSafety::reserved[17];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/","title":"Struct nebula::drivers::pandar_128_e4x::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; Header</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t BlockNum uint8_t DistanceUnitMm uint8_t FirstBlockReturn uint8_t Flags uint8_t LaserNum uint8_t ProtocolMajor uint8_t ProtocolMinor uint16_t Reserved uint8_t ReturnNum uint16_t SOP"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-blocknum","title":"variable BlockNum","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::BlockNum;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-distanceunitmm","title":"variable DistanceUnitMm","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::DistanceUnitMm;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-firstblockreturn","title":"variable FirstBlockReturn","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::FirstBlockReturn;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-flags","title":"variable Flags","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::Flags;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-lasernum","title":"variable LaserNum","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::LaserNum;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-protocolmajor","title":"variable ProtocolMajor","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::ProtocolMajor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-protocolminor","title":"variable ProtocolMinor","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::ProtocolMinor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-reserved","title":"variable Reserved","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Header::Reserved;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-returnnum","title":"variable ReturnNum","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Header::ReturnNum;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Header/#variable-sop","title":"variable SOP","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Header::SOP;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/","title":"Struct nebula::drivers::pandar_128_e4x::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; Packet</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Body body FunctionalSafety functional_safety Header header Tail tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/#variable-body","title":"variable body","text":"<pre><code>Body nebula::drivers::pandar_128_e4x::Packet::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/#variable-functional_safety","title":"variable functional_safety","text":"<pre><code>FunctionalSafety nebula::drivers::pandar_128_e4x::Packet::functional_safety;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_128_e4x::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Packet/#variable-tail","title":"variable tail","text":"<pre><code>Tail nebula::drivers::pandar_128_e4x::Packet::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/","title":"Struct nebula::drivers::pandar_128_e4x::PacketExtended","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; PacketExtended</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/#public-attributes","title":"Public Attributes","text":"Type Name BodyExtended body FunctionalSafety functional_safety Header header Tail tail"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/#variable-body","title":"variable body","text":"<pre><code>BodyExtended nebula::drivers::pandar_128_e4x::PacketExtended::body;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/#variable-functional_safety","title":"variable functional_safety","text":"<pre><code>FunctionalSafety nebula::drivers::pandar_128_e4x::PacketExtended::functional_safety;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_128_e4x::PacketExtended::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1PacketExtended/#variable-tail","title":"variable tail","text":"<pre><code>Tail nebula::drivers::pandar_128_e4x::PacketExtended::tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/","title":"Class nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; Pandar128E4XDecoder</p> <ul> <li><code>#include &lt;pandar_128_e4x_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#public-functions","title":"Public Functions","text":"Type Name Pandar128E4XDecoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration)  virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideVirtual function for getting the constructed point cloud. virtual bool hasScanned () overrideVirtual function for getting the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) overrideVirtual function for parsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#function-pandar128e4xdecoder","title":"function Pandar128E4XDecoder","text":"<pre><code>explicit nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder::Pandar128E4XDecoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Virtual function for getting the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Virtual function for getting the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__128__e4x_1_1Pandar128E4XDecoder/#function-unpack","title":"function unpack","text":"<p>Virtual function for parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/","title":"Struct nebula::drivers::pandar_128_e4x::Tail","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_128_e4x &gt; Tail</p> <ul> <li><code>#include &lt;pandar_128_e4x.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth_state uint32_t crc_32 DateTime date_time uint8_t factory_info uint16_t motor_speed_rpm uint8_t operational_state uint8_t reserved_01 uint8_t reserved_02 uint8_t return_mode uint32_t timestamp_us uint32_t udp_sequence"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-azimuth_state","title":"variable azimuth_state","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Tail::azimuth_state;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-crc_32","title":"variable crc_32","text":"<pre><code>uint32_t nebula::drivers::pandar_128_e4x::Tail::crc_32;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-date_time","title":"variable date_time","text":"<pre><code>DateTime nebula::drivers::pandar_128_e4x::Tail::date_time;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-factory_info","title":"variable factory_info","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Tail::factory_info;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-motor_speed_rpm","title":"variable motor_speed_rpm","text":"<pre><code>uint16_t nebula::drivers::pandar_128_e4x::Tail::motor_speed_rpm;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-operational_state","title":"variable operational_state","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Tail::operational_state;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-reserved_01","title":"variable reserved_01","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Tail::reserved_01[9];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-reserved_02","title":"variable reserved_02","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Tail::reserved_02[22];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint8_t nebula::drivers::pandar_128_e4x::Tail::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-timestamp_us","title":"variable timestamp_us","text":"<pre><code>uint32_t nebula::drivers::pandar_128_e4x::Tail::timestamp_us;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__128__e4x_1_1Tail/#variable-udp_sequence","title":"variable udp_sequence","text":"<pre><code>uint32_t nebula::drivers::pandar_128_e4x::Tail::udp_sequence;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/","title":"Namespace nebula::drivers::pandar_40","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_40</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#classes","title":"Classes","text":"Type Name struct Block struct Packet class Pandar40Decoder Hesai LiDAR decoder (Pandar40) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 10 constexpr size_t BLOCK_SIZE   = = RAW_MEASURE_SIZE * LASER_COUNT + SOB_ANGLE_SIZE constexpr uint32_t DUAL_RETURN   = = 0x39 constexpr size_t FACTORY_INFO_SIZE   = = 1 constexpr size_t INFO_SIZE   = = TIMESTAMP_SIZE + FACTORY_INFO_SIZE + RETURN_SIZE + RESERVE_SIZE + REVOLUTION_SIZE constexpr size_t LASER_COUNT   = = 40 constexpr float LASER_RETURN_TO_DISTANCE_RATE   = = 0.004 constexpr uint32_t LAST_RETURN   = = 0x38 constexpr uint32_t MAX_AZIMUTH_STEPS   = = 360 * 100 constexpr double MAX_RANGE   = = 200.f constexpr double MIN_RANGE   = = 0.3f constexpr size_t PACKET_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET + INFO_SIZE + UTC_TIME constexpr size_t RAW_MEASURE_SIZE   = = 3 constexpr size_t RESERVE_SIZE   = = 8 constexpr size_t RETURN_SIZE   = = 1 constexpr size_t REVOLUTION_SIZE   = = 2 constexpr size_t SEQ_NUM_SIZE   = = 4 constexpr size_t SOB_ANGLE_SIZE   = = 4 constexpr uint32_t STRONGEST_RETURN   = = 0x37 constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr size_t UTC_TIME   = = 6"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-dual_return","title":"variable DUAL_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_40::DUAL_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-factory_info_size","title":"variable FACTORY_INFO_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::FACTORY_INFO_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-info_size","title":"variable INFO_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::INFO_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-laser_return_to_distance_rate","title":"variable LASER_RETURN_TO_DISTANCE_RATE","text":"<pre><code>constexpr float nebula::drivers::pandar_40::LASER_RETURN_TO_DISTANCE_RATE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-last_return","title":"variable LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_40::LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_40::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_40::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_40::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-raw_measure_size","title":"variable RAW_MEASURE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::RAW_MEASURE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-reserve_size","title":"variable RESERVE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::RESERVE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-return_size","title":"variable RETURN_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::RETURN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-revolution_size","title":"variable REVOLUTION_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::REVOLUTION_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-seq_num_size","title":"variable SEQ_NUM_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::SEQ_NUM_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-sob_angle_size","title":"variable SOB_ANGLE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::SOB_ANGLE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-strongest_return","title":"variable STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_40::STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__40/#variable-utc_time","title":"variable UTC_TIME","text":"<pre><code>constexpr size_t nebula::drivers::pandar_40::UTC_TIME;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Block/","title":"Struct nebula::drivers::pandar_40::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_40 &gt; Block</p> <ul> <li><code>#include &lt;pandar_40.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth uint16_t sob Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_40::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Block/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_40::Block::sob;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_40::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/","title":"Struct nebula::drivers::pandar_40::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_40 &gt; Packet</p> <ul> <li><code>#include &lt;pandar_40.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks uint32_t return_mode struct tm t uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_40::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_40::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>struct tm nebula::drivers::pandar_40::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_40::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/","title":"Class nebula::drivers::pandar_40::Pandar40Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_40 &gt; Pandar40Decoder</p> <p>Hesai LiDAR decoder (Pandar40) </p> <ul> <li><code>#include &lt;pandar_40_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#public-functions","title":"Public Functions","text":"Type Name Pandar40Decoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#function-pandar40decoder","title":"function Pandar40Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_40::Pandar40Decoder::Pandar40Decoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_40::Pandar40Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_40::Pandar40Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__40_1_1Pandar40Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_40::Pandar40Decoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Unit/","title":"Struct nebula::drivers::pandar_40::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_40 &gt; Unit</p> <ul> <li><code>#include &lt;pandar_40.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name float distance uint8_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_40::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__40_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint8_t nebula::drivers::pandar_40::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/","title":"Namespace nebula::drivers::pandar_64","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_64</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet class Pandar64Decoder Hesai LiDAR decoder (Pandar64) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 6 constexpr size_t BLOCK_HEADER_AZIMUTH   = = 2 constexpr size_t BLOCK_SIZE   = = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH constexpr size_t BODY_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET constexpr uint32_t DUAL_RETURN   = = 0x39 constexpr size_t ENGINE_VELOCITY   = = 2 constexpr size_t FACTORY_SIZE   = = 1 constexpr size_t HEAD_SIZE   = = 8 constexpr size_t HIGH_TEMPERATURE   = = 1 constexpr size_t LASER_COUNT   = = 64 constexpr uint32_t LAST_RETURN   = = 0x38 constexpr uint32_t MAX_AZIMUTH_STEPS   = = 360 * 100 constexpr double MAX_RANGE   = = 200.f constexpr double MIN_RANGE   = = 0.3f constexpr size_t PACKET_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_SIZE constexpr size_t PACKET_TAIL_SIZE   = = 26 constexpr size_t PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE   = = 22 constexpr size_t PACKET_WITHOUT_UDP_SEQ_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE constexpr size_t RESERVED_SIZE   = = 8 constexpr size_t RETURN_SIZE   = = 1 constexpr uint32_t STRONGEST_RETURN   = = 0x37 constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr size_t UNIT_SIZE   = = 3 constexpr size_t UTC_SIZE   = = 6"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-block_header_azimuth","title":"variable BLOCK_HEADER_AZIMUTH","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::BLOCK_HEADER_AZIMUTH;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-dual_return","title":"variable DUAL_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_64::DUAL_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-engine_velocity","title":"variable ENGINE_VELOCITY","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::ENGINE_VELOCITY;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-factory_size","title":"variable FACTORY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::FACTORY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-head_size","title":"variable HEAD_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::HEAD_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-high_temperature","title":"variable HIGH_TEMPERATURE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::HIGH_TEMPERATURE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-last_return","title":"variable LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_64::LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_64::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_64::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_64::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-packet_tail_size","title":"variable PACKET_TAIL_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::PACKET_TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-packet_tail_without_udp_seq_size","title":"variable PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-packet_without_udp_seq_size","title":"variable PACKET_WITHOUT_UDP_SEQ_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::PACKET_WITHOUT_UDP_SEQ_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-reserved_size","title":"variable RESERVED_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::RESERVED_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-return_size","title":"variable RETURN_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::RETURN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-strongest_return","title":"variable STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_64::STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-unit_size","title":"variable UNIT_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::UNIT_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__64/#variable-utc_size","title":"variable UTC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_64::UTC_SIZE;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Block/","title":"Struct nebula::drivers::pandar_64::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_64 &gt; Block</p> <ul> <li><code>#include &lt;pandar_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_64::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_64::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/","title":"Struct nebula::drivers::pandar_64::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_64 &gt; Header</p> <ul> <li><code>#include &lt;pandar_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name int8_t chBlockNumber int8_t chDisUnit int8_t chLaserNumber int8_t chReturnType uint16_t sob"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#variable-chblocknumber","title":"variable chBlockNumber","text":"<pre><code>int8_t nebula::drivers::pandar_64::Header::chBlockNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#variable-chdisunit","title":"variable chDisUnit","text":"<pre><code>int8_t nebula::drivers::pandar_64::Header::chDisUnit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#variable-chlasernumber","title":"variable chLaserNumber","text":"<pre><code>int8_t nebula::drivers::pandar_64::Header::chLaserNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#variable-chreturntype","title":"variable chReturnType","text":"<pre><code>int8_t nebula::drivers::pandar_64::Header::chReturnType;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Header/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_64::Header::sob;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/","title":"Struct nebula::drivers::pandar_64::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_64 &gt; Packet</p> <ul> <li><code>#include &lt;pandar_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks Header header uint32_t return_mode tm t uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_64::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_64::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_64::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>tm nebula::drivers::pandar_64::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_64::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/","title":"Class nebula::drivers::pandar_64::Pandar64Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_64 &gt; Pandar64Decoder</p> <p>Hesai LiDAR decoder (Pandar64) </p> <ul> <li><code>#include &lt;pandar_64_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#public-functions","title":"Public Functions","text":"Type Name Pandar64Decoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#function-pandar64decoder","title":"function Pandar64Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_64::Pandar64Decoder::Pandar64Decoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_64::Pandar64Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_64::Pandar64Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__64_1_1Pandar64Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_64::Pandar64Decoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Unit/","title":"Struct nebula::drivers::pandar_64::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_64 &gt; Unit</p> <ul> <li><code>#include &lt;pandar_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name float distance uint16_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_64::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__64_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint16_t nebula::drivers::pandar_64::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/","title":"Namespace nebula::drivers::pandar_at","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_at</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet class PandarATDecoder Hesai LiDAR decoder (AT128) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 2 constexpr size_t BLOCK_HEADER_AZIMUTH   = = 3 constexpr size_t BLOCK_SIZE   = = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH constexpr size_t BODY_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET + CRC_SIZE constexpr size_t CRC_SIZE   = = 4 constexpr uint32_t DUAL_RETURN   = = 0x39 constexpr uint32_t DUAL_RETURN_B   = = 0x3b constexpr uint32_t DUAL_RETURN_C   = = 0x3c constexpr size_t FACTORY_SIZE   = = 1 constexpr uint32_t FIRST_RETURN   = = 0x33 constexpr size_t HEADER_SIZE   = = 6 constexpr size_t HEAD_SIZE   = = 12 constexpr size_t HIGH_TEMP_SHUTDOWN_FLAG_SIZE   = = 1 constexpr size_t LASER_COUNT   = = 128 constexpr uint32_t LAST_RETURN   = = 0x38 const uint16_t LIDAR_AZIMUTH_UNIT   = = 256 const uint16_t MAX_AZIMUTH_DEGREE_NUM   = = 36000 const uint32_t MAX_AZI_LEN   = = 36000 * 256 constexpr float MAX_RANGE   = = 180.0f const uint16_t MAX_RETURN_COUNT   = = 2This sensor supports a maximum of 2 returns (= dual return) constexpr float MIN_RANGE   = = 1.f constexpr size_t MOTOR_SPEED_SIZE   = = 2 constexpr size_t PACKET_SIZE   = = 1118 constexpr size_t PACKET_TAIL_SIZE   = = 40 constexpr size_t PRE_HEADER_SIZE   = = 6 constexpr size_t RESERVED1_SIZE   = = 6 constexpr size_t RESERVED2_SIZE   = = 11 constexpr size_t RETURN_SIZE   = = 1 const uint32_t SCAN_POINTS_NUM   = = 1200 * LASER_COUNTThe resolution of one scan (in single return mode) constexpr size_t SEQUENCE_SIZE   = = 4 constexpr uint32_t STRONGEST_RETURN   = = 0x37 constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr uint32_t TRIPLE_RETURN   = = 0x3d constexpr size_t UNIT_SIZE   = = 4 constexpr size_t UTC_SIZE   = = 6 const uint32_t channel_firing_ns   = = { 0,     0,     8240,  4112,  4144,  8240,  0,     0,     12424, 4144,  4112,  8264,  12376, 12376, 8264,  12424, 0,     0,     4112,  8240,  4144,  0,     0,     4144,  12424, 8264, 4112,  12376, 12376, 12424, 8264,  848,   2504,  4976,  6616,  6616,  9112,  2504,  848, 10768, 13280, 13280, 4976,  9112,  14928, 14928, 10768, 2504,  848,   6616,  4976,  9112, 6616,  848,   2504,  13280, 10768, 4976,  13280, 14928, 9112,  10768, 14928, 13280, 848, 9112,  13280, 2504,  4976,  848,   2504,  14928, 10768, 10768, 14928, 4976,  6616,  6616, 9112,  848,   13280, 13280, 9112,  4976,  2504,  2504,  848,   10768, 14928, 14928, 10768, 6616,  4976,  9112,  6616,  4112,  1242,  0,     4144,  0,     0,     12424, 0,     8264, 4112,  4144,  8240,  8240,  8264,  12376, 12376, 12424, 4112,  4144,  0,     0,     0, 0,     0,     12424, 8264,  8240,  4144,  8264,  8240,  12376, 12376, 8264}"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-block_header_azimuth","title":"variable BLOCK_HEADER_AZIMUTH","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::BLOCK_HEADER_AZIMUTH;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-crc_size","title":"variable CRC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::CRC_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-dual_return","title":"variable DUAL_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::DUAL_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-dual_return_b","title":"variable DUAL_RETURN_B","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::DUAL_RETURN_B;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-dual_return_c","title":"variable DUAL_RETURN_C","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::DUAL_RETURN_C;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-factory_size","title":"variable FACTORY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::FACTORY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-first_return","title":"variable FIRST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::FIRST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-header_size","title":"variable HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-head_size","title":"variable HEAD_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::HEAD_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-high_temp_shutdown_flag_size","title":"variable HIGH_TEMP_SHUTDOWN_FLAG_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::HIGH_TEMP_SHUTDOWN_FLAG_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-last_return","title":"variable LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-lidar_azimuth_unit","title":"variable LIDAR_AZIMUTH_UNIT","text":"<pre><code>const uint16_t nebula::drivers::pandar_at::LIDAR_AZIMUTH_UNIT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-max_azimuth_degree_num","title":"variable MAX_AZIMUTH_DEGREE_NUM","text":"<pre><code>const uint16_t nebula::drivers::pandar_at::MAX_AZIMUTH_DEGREE_NUM;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-max_azi_len","title":"variable MAX_AZI_LEN","text":"<pre><code>const uint32_t nebula::drivers::pandar_at::MAX_AZI_LEN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_at::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-max_return_count","title":"variable MAX_RETURN_COUNT","text":"<pre><code>const uint16_t nebula::drivers::pandar_at::MAX_RETURN_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_at::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-motor_speed_size","title":"variable MOTOR_SPEED_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::MOTOR_SPEED_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-packet_tail_size","title":"variable PACKET_TAIL_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::PACKET_TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-pre_header_size","title":"variable PRE_HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::PRE_HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-reserved1_size","title":"variable RESERVED1_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::RESERVED1_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-reserved2_size","title":"variable RESERVED2_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::RESERVED2_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-return_size","title":"variable RETURN_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::RETURN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-scan_points_num","title":"variable SCAN_POINTS_NUM","text":"<pre><code>const uint32_t nebula::drivers::pandar_at::SCAN_POINTS_NUM;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-sequence_size","title":"variable SEQUENCE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::SEQUENCE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-strongest_return","title":"variable STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-triple_return","title":"variable TRIPLE_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_at::TRIPLE_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-unit_size","title":"variable UNIT_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::UNIT_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-utc_size","title":"variable UTC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_at::UTC_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__at/#variable-channel_firing_ns","title":"variable channel_firing_ns","text":"<pre><code>const uint32_t nebula::drivers::pandar_at::channel_firing_ns[];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Block/","title":"Struct nebula::drivers::pandar_at::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_at &gt; Block</p> <ul> <li><code>#include &lt;pandar_at.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth uint16_t fine_azimuth Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_at::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Block/#variable-fine_azimuth","title":"variable fine_azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_at::Block::fine_azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_at::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/","title":"Struct nebula::drivers::pandar_at::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_at &gt; Header</p> <ul> <li><code>#include &lt;pandar_at.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name int8_t chBlockNumber int8_t chDisUnit int chLaserNumber int8_t chProtocolMajor int8_t chProtocolMinor int8_t chReturnType uint16_t sob"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-chblocknumber","title":"variable chBlockNumber","text":"<pre><code>int8_t nebula::drivers::pandar_at::Header::chBlockNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-chdisunit","title":"variable chDisUnit","text":"<pre><code>int8_t nebula::drivers::pandar_at::Header::chDisUnit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-chlasernumber","title":"variable chLaserNumber","text":"<pre><code>int nebula::drivers::pandar_at::Header::chLaserNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-chprotocolmajor","title":"variable chProtocolMajor","text":"<pre><code>int8_t nebula::drivers::pandar_at::Header::chProtocolMajor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-chprotocolminor","title":"variable chProtocolMinor","text":"<pre><code>int8_t nebula::drivers::pandar_at::Header::chProtocolMinor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-chreturntype","title":"variable chReturnType","text":"<pre><code>int8_t nebula::drivers::pandar_at::Header::chReturnType;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Header/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_at::Header::sob;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/","title":"Struct nebula::drivers::pandar_at::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_at &gt; Packet</p> <ul> <li><code>#include &lt;pandar_at.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks Header header uint32_t motor_speed uint32_t return_mode uint32_t shutdown_flg tm t double unix_second uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_at::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_at::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>uint32_t nebula::drivers::pandar_at::Packet::motor_speed;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_at::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-shutdown_flg","title":"variable shutdown_flg","text":"<pre><code>uint32_t nebula::drivers::pandar_at::Packet::shutdown_flg;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>tm nebula::drivers::pandar_at::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-unix_second","title":"variable unix_second","text":"<pre><code>double nebula::drivers::pandar_at::Packet::unix_second;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_at::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/","title":"Class nebula::drivers::pandar_at::PandarATDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_at &gt; PandarATDecoder</p> <p>Hesai LiDAR decoder (AT128) </p> <ul> <li><code>#include &lt;pandar_at_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#public-functions","title":"Public Functions","text":"Type Name PandarATDecoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration, const std::shared_ptr&lt; drivers::HesaiCorrection &gt; &amp; correction_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; raw_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#function-pandaratdecoder","title":"function PandarATDecoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_at::PandarATDecoder::PandarATDecoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCorrection &gt; &amp; correction_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> <li><code>correction_configuration</code> Correction for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_at::PandarATDecoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_at::PandarATDecoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__at_1_1PandarATDecoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_at::PandarATDecoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; raw_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Unit/","title":"Struct nebula::drivers::pandar_at::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_at &gt; Unit</p> <ul> <li><code>#include &lt;pandar_at.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t confidence float distance uint16_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Unit/#variable-confidence","title":"variable confidence","text":"<pre><code>uint16_t nebula::drivers::pandar_at::Unit::confidence;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_at::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__at_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint16_t nebula::drivers::pandar_at::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/","title":"Namespace nebula::drivers::pandar_qt_128","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_qt_128</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet class PandarQT128Decoder Hesai LiDAR decoder (QT128) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 2 constexpr size_t BLOCK_HEADER_AZIMUTH   = = 2 constexpr size_t BLOCK_SIZE   = = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH constexpr size_t BODY_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET + CRC_SIZE constexpr size_t CRC_SIZE   = = 4 constexpr uint32_t DUAL_FIRST_LAST_RETURN   = = 0x3B constexpr uint32_t DUAL_FIRST_SECOND_RETURN   = = 0x3A constexpr uint32_t DUAL_FIRST_STRONGEST_RETURN   = = 0x3C constexpr uint32_t DUAL_LAST_STRONGEST_RETURN   = = 0x39 constexpr uint32_t DUAL_STRONGEST_2ndSTRONGEST_RETURN   = = 0x3E constexpr size_t FACTORY_SIZE   = = 1 constexpr size_t HEAD_SIZE   = = 12 constexpr size_t LASER_COUNT   = = 128 constexpr uint16_t MAX_AZIMUTH_STEPS   = = 36000 constexpr double MAX_RANGE   = = 50.0 constexpr double MIN_RANGE   = = 0.05 constexpr size_t MODE_FLAG_SIZE   = = 1 constexpr size_t PACKET_FS_SIZE   = = 17 constexpr size_t PACKET_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_FS_SIZE + PACKET_TAIL_SIZE + SIGNATURE_SIZE constexpr size_t PACKET_TAIL_SIZE   = = 34 constexpr size_t PACKET_TAIL_TIMESTAMP_OFFSET   = = 1076 constexpr size_t PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE   = = 26 constexpr size_t PACKET_WITHOUT_UDP_SEQ_CRC_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_FS_SIZE + PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE const std::string PandarQT128_TL1 const std::string PandarQT128_TL2 constexpr size_t RESERVED2_SIZE   = = 5 constexpr size_t RESERVED3_SIZE   = = 6 constexpr size_t SIGNATURE_SIZE   = = 32 constexpr uint32_t SINGLE_FIRST_RETURN   = = 0x33 constexpr uint32_t SINGLE_LAST_RETURN   = = 0x38 constexpr uint32_t SINGLE_SECOND_RETURN   = = 0x34 constexpr uint32_t SINGLE_STRONGEST_RETURN   = = 0x37 constexpr size_t SKIP_SIZE   = = PACKET_FS_SIZE + RESERVED2_SIZE constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr size_t UNIT_SIZE   = = 4 constexpr size_t UTC_SIZE   = = 6"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-block_header_azimuth","title":"variable BLOCK_HEADER_AZIMUTH","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::BLOCK_HEADER_AZIMUTH;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-crc_size","title":"variable CRC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::CRC_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-dual_first_last_return","title":"variable DUAL_FIRST_LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::DUAL_FIRST_LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-dual_first_second_return","title":"variable DUAL_FIRST_SECOND_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::DUAL_FIRST_SECOND_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-dual_first_strongest_return","title":"variable DUAL_FIRST_STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::DUAL_FIRST_STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-dual_last_strongest_return","title":"variable DUAL_LAST_STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::DUAL_LAST_STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-dual_strongest_2ndstrongest_return","title":"variable DUAL_STRONGEST_2ndSTRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::DUAL_STRONGEST_2ndSTRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-factory_size","title":"variable FACTORY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::FACTORY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-head_size","title":"variable HEAD_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::HEAD_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint16_t nebula::drivers::pandar_qt_128::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_qt_128::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_qt_128::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-mode_flag_size","title":"variable MODE_FLAG_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::MODE_FLAG_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-packet_fs_size","title":"variable PACKET_FS_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::PACKET_FS_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-packet_tail_size","title":"variable PACKET_TAIL_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::PACKET_TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-packet_tail_timestamp_offset","title":"variable PACKET_TAIL_TIMESTAMP_OFFSET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::PACKET_TAIL_TIMESTAMP_OFFSET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-packet_tail_without_udp_seq_crc_size","title":"variable PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-packet_without_udp_seq_crc_size","title":"variable PACKET_WITHOUT_UDP_SEQ_CRC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::PACKET_WITHOUT_UDP_SEQ_CRC_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-pandarqt128_tl1","title":"variable PandarQT128_TL1","text":"<pre><code>const std::string nebula::drivers::pandar_qt_128::PandarQT128_TL1;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-pandarqt128_tl2","title":"variable PandarQT128_TL2","text":"<pre><code>const std::string nebula::drivers::pandar_qt_128::PandarQT128_TL2;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-reserved2_size","title":"variable RESERVED2_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::RESERVED2_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-reserved3_size","title":"variable RESERVED3_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::RESERVED3_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-signature_size","title":"variable SIGNATURE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::SIGNATURE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-single_first_return","title":"variable SINGLE_FIRST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::SINGLE_FIRST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-single_last_return","title":"variable SINGLE_LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::SINGLE_LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-single_second_return","title":"variable SINGLE_SECOND_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::SINGLE_SECOND_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-single_strongest_return","title":"variable SINGLE_STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_128::SINGLE_STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-skip_size","title":"variable SKIP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::SKIP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-unit_size","title":"variable UNIT_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::UNIT_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__128/#variable-utc_size","title":"variable UTC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_128::UTC_SIZE;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Block/","title":"Struct nebula::drivers::pandar_qt_128::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_128 &gt; Block</p> <ul> <li><code>#include &lt;pandar_qt_128.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_128::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_qt_128::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/","title":"Struct nebula::drivers::pandar_qt_128::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_128 &gt; Header</p> <ul> <li><code>#include &lt;pandar_qt_128.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t chBlockNumber uint8_t chDisUnit uint8_t chFlags uint8_t chLaserNumber uint8_t chProtocolMajor uint8_t chProtocolMinor uint8_t chReturnType uint16_t sob"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chblocknumber","title":"variable chBlockNumber","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chBlockNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chdisunit","title":"variable chDisUnit","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chDisUnit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chflags","title":"variable chFlags","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chFlags;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chlasernumber","title":"variable chLaserNumber","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chLaserNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chprotocolmajor","title":"variable chProtocolMajor","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chProtocolMajor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chprotocolminor","title":"variable chProtocolMinor","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chProtocolMinor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-chreturntype","title":"variable chReturnType","text":"<pre><code>uint8_t nebula::drivers::pandar_qt_128::Header::chReturnType;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Header/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_128::Header::sob;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/","title":"Struct nebula::drivers::pandar_qt_128::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_128 &gt; Packet</p> <ul> <li><code>#include &lt;pandar_qt_128.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks Header header uint32_t mode_flag uint32_t return_mode tm t uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_qt_128::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_qt_128::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#variable-mode_flag","title":"variable mode_flag","text":"<pre><code>uint32_t nebula::drivers::pandar_qt_128::Packet::mode_flag;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_qt_128::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>tm nebula::drivers::pandar_qt_128::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_qt_128::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/","title":"Class nebula::drivers::pandar_qt_128::PandarQT128Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_128 &gt; PandarQT128Decoder</p> <p>Hesai LiDAR decoder (QT128) </p> <ul> <li><code>#include &lt;pandar_qt_128_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#public-functions","title":"Public Functions","text":"Type Name PandarQT128Decoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#function-pandarqt128decoder","title":"function PandarQT128Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_qt_128::PandarQT128Decoder::PandarQT128Decoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_qt_128::PandarQT128Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_qt_128::PandarQT128Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__128_1_1PandarQT128Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_qt_128::PandarQT128Decoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Unit/","title":"Struct nebula::drivers::pandar_qt_128::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_128 &gt; Unit</p> <ul> <li><code>#include &lt;pandar_qt_128.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t confidence float distance uint16_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Unit/#variable-confidence","title":"variable confidence","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_128::Unit::confidence;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_qt_128::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__128_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_128::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/","title":"Namespace nebula::drivers::pandar_qt_64","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_qt_64</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet class PandarQT64Decoder Hesai LiDAR decoder (QT64) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 4 constexpr size_t BLOCK_HEADER_AZIMUTH   = = 2 constexpr size_t BLOCK_SIZE   = = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH constexpr size_t BODY_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET constexpr uint32_t DUAL_RETURN_B   = = 0x3b constexpr size_t ENGINE_VELOCITY   = = 2 constexpr size_t FACTORY_SIZE   = = 1 constexpr uint32_t FIRST_RETURN   = = 0x33 constexpr size_t HEADER_SIZE   = = 6 constexpr size_t HEAD_SIZE   = = 12 constexpr size_t LASER_COUNT   = = 64 constexpr uint32_t LAST_RETURN   = = 0x38 constexpr uint32_t MAX_AZIMUTH_STEPS   = = 360 * 100 constexpr double MAX_RANGE   = = 60.f constexpr double MIN_RANGE   = = 0.1f constexpr size_t PACKET_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_SIZE constexpr size_t PACKET_TAIL_SIZE   = = 28 constexpr size_t PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE   = = 24 constexpr size_t PACKET_WITHOUT_UDP_SEQ_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE constexpr size_t PRE_HEADER_SIZE   = = 6 constexpr size_t RESERVED_SIZE   = = 10 constexpr size_t RETURN_SIZE   = = 1 constexpr size_t SEQUENCE_SIZE   = = 4 constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr size_t UNIT_SIZE   = = 4 constexpr size_t UTC_SIZE   = = 6"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-block_header_azimuth","title":"variable BLOCK_HEADER_AZIMUTH","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::BLOCK_HEADER_AZIMUTH;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-dual_return_b","title":"variable DUAL_RETURN_B","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_64::DUAL_RETURN_B;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-engine_velocity","title":"variable ENGINE_VELOCITY","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::ENGINE_VELOCITY;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-factory_size","title":"variable FACTORY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::FACTORY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-first_return","title":"variable FIRST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_64::FIRST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-header_size","title":"variable HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-head_size","title":"variable HEAD_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::HEAD_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-last_return","title":"variable LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_64::LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_qt_64::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_qt_64::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr double nebula::drivers::pandar_qt_64::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-packet_tail_size","title":"variable PACKET_TAIL_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::PACKET_TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-packet_tail_without_udp_seq_size","title":"variable PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-packet_without_udp_seq_size","title":"variable PACKET_WITHOUT_UDP_SEQ_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::PACKET_WITHOUT_UDP_SEQ_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-pre_header_size","title":"variable PRE_HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::PRE_HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-reserved_size","title":"variable RESERVED_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::RESERVED_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-return_size","title":"variable RETURN_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::RETURN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-sequence_size","title":"variable SEQUENCE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::SEQUENCE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-unit_size","title":"variable UNIT_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::UNIT_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__qt__64/#variable-utc_size","title":"variable UTC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_qt_64::UTC_SIZE;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Block/","title":"Struct nebula::drivers::pandar_qt_64::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_64 &gt; Block</p> <ul> <li><code>#include &lt;pandar_qt_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_64::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_qt_64::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/","title":"Struct nebula::drivers::pandar_qt_64::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_64 &gt; Header</p> <ul> <li><code>#include &lt;pandar_qt_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name int8_t chBlockNumber int8_t chDisUnit int8_t chLaserNumber int8_t chProtocolMajor int8_t chProtocolMinor int8_t chReturnType uint16_t sob"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-chblocknumber","title":"variable chBlockNumber","text":"<pre><code>int8_t nebula::drivers::pandar_qt_64::Header::chBlockNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-chdisunit","title":"variable chDisUnit","text":"<pre><code>int8_t nebula::drivers::pandar_qt_64::Header::chDisUnit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-chlasernumber","title":"variable chLaserNumber","text":"<pre><code>int8_t nebula::drivers::pandar_qt_64::Header::chLaserNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-chprotocolmajor","title":"variable chProtocolMajor","text":"<pre><code>int8_t nebula::drivers::pandar_qt_64::Header::chProtocolMajor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-chprotocolminor","title":"variable chProtocolMinor","text":"<pre><code>int8_t nebula::drivers::pandar_qt_64::Header::chProtocolMinor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-chreturntype","title":"variable chReturnType","text":"<pre><code>int8_t nebula::drivers::pandar_qt_64::Header::chReturnType;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Header/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_64::Header::sob;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/","title":"Struct nebula::drivers::pandar_qt_64::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_64 &gt; Packet</p> <ul> <li><code>#include &lt;pandar_qt_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks Header header uint32_t return_mode tm t uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_qt_64::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_qt_64::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_qt_64::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>tm nebula::drivers::pandar_qt_64::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_qt_64::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/","title":"Class nebula::drivers::pandar_qt_64::PandarQT64Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_64 &gt; PandarQT64Decoder</p> <p>Hesai LiDAR decoder (QT64) </p> <ul> <li><code>#include &lt;pandar_qt_64_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#public-functions","title":"Public Functions","text":"Type Name PandarQT64Decoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#function-pandarqt64decoder","title":"function PandarQT64Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_qt_64::PandarQT64Decoder::PandarQT64Decoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_qt_64::PandarQT64Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_qt_64::PandarQT64Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__qt__64_1_1PandarQT64Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_qt_64::PandarQT64Decoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; pandar_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Unit/","title":"Struct nebula::drivers::pandar_qt_64::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_qt_64 &gt; Unit</p> <ul> <li><code>#include &lt;pandar_qt_64.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t confidence float distance uint16_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Unit/#variable-confidence","title":"variable confidence","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_64::Unit::confidence;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_qt_64::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__qt__64_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint16_t nebula::drivers::pandar_qt_64::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/","title":"Namespace nebula::drivers::pandar_xt","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_xt</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet class PandarXTDecoder Hesai LiDAR decoder (XT32) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 8 constexpr size_t BLOCK_HEADER_AZIMUTH   = = 2 constexpr size_t BLOCK_SIZE   = = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH constexpr size_t BODY_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET constexpr uint32_t DUAL_RETURN   = = 0x39 constexpr size_t ENGINE_VELOCITY   = = 2 constexpr size_t FACTORY_SIZE   = = 1 constexpr size_t HEADER_SIZE   = = 6 constexpr size_t HEAD_SIZE   = = 12 constexpr size_t LASER_COUNT   = = 32 constexpr uint32_t LAST_RETURN   = = 0x38 constexpr uint32_t MAX_AZIMUTH_STEPS   = = 360 * 100 constexpr float MAX_RANGE   = = 120.0f constexpr float MIN_RANGE   = = 0.05f constexpr size_t PACKET_SIZE   = = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_SIZE constexpr size_t PACKET_TAIL_SIZE   = = 28 constexpr size_t PRE_HEADER_SIZE   = = 6 constexpr size_t RESERVED_SIZE   = = 10 constexpr size_t RETURN_SIZE   = = 1 constexpr size_t SEQUENCE_SIZE   = = 4 constexpr uint32_t STRONGEST_RETURN   = = 0x37 constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr size_t UNIT_SIZE   = = 4 constexpr size_t UTC_SIZE   = = 6"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-block_header_azimuth","title":"variable BLOCK_HEADER_AZIMUTH","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::BLOCK_HEADER_AZIMUTH;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-dual_return","title":"variable DUAL_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xt::DUAL_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-engine_velocity","title":"variable ENGINE_VELOCITY","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::ENGINE_VELOCITY;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-factory_size","title":"variable FACTORY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::FACTORY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-header_size","title":"variable HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-head_size","title":"variable HEAD_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::HEAD_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-last_return","title":"variable LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xt::LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xt::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_xt::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_xt::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-packet_tail_size","title":"variable PACKET_TAIL_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::PACKET_TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-pre_header_size","title":"variable PRE_HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::PRE_HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-reserved_size","title":"variable RESERVED_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::RESERVED_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-return_size","title":"variable RETURN_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::RETURN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-sequence_size","title":"variable SEQUENCE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::SEQUENCE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-strongest_return","title":"variable STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xt::STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-unit_size","title":"variable UNIT_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::UNIT_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xt/#variable-utc_size","title":"variable UTC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xt::UTC_SIZE;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Block/","title":"Struct nebula::drivers::pandar_xt::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xt &gt; Block</p> <ul> <li><code>#include &lt;pandar_xt.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_xt::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_xt::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/","title":"Struct nebula::drivers::pandar_xt::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xt &gt; Header</p> <ul> <li><code>#include &lt;pandar_xt.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name int8_t chBlockNumber int8_t chDisUnit int8_t chLaserNumber int8_t chProtocolMajor int8_t chProtocolMinor int8_t chReturnType uint16_t sob"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-chblocknumber","title":"variable chBlockNumber","text":"<pre><code>int8_t nebula::drivers::pandar_xt::Header::chBlockNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-chdisunit","title":"variable chDisUnit","text":"<pre><code>int8_t nebula::drivers::pandar_xt::Header::chDisUnit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-chlasernumber","title":"variable chLaserNumber","text":"<pre><code>int8_t nebula::drivers::pandar_xt::Header::chLaserNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-chprotocolmajor","title":"variable chProtocolMajor","text":"<pre><code>int8_t nebula::drivers::pandar_xt::Header::chProtocolMajor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-chprotocolminor","title":"variable chProtocolMinor","text":"<pre><code>int8_t nebula::drivers::pandar_xt::Header::chProtocolMinor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-chreturntype","title":"variable chReturnType","text":"<pre><code>int8_t nebula::drivers::pandar_xt::Header::chReturnType;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Header/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_xt::Header::sob;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/","title":"Struct nebula::drivers::pandar_xt::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xt &gt; Packet</p> <ul> <li><code>#include &lt;pandar_xt.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks Header header uint32_t return_mode tm t uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_xt::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_xt::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_xt::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>tm nebula::drivers::pandar_xt::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_xt::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/","title":"Class nebula::drivers::pandar_xt::PandarXTDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xt &gt; PandarXTDecoder</p> <p>Hesai LiDAR decoder (XT32) </p> <ul> <li><code>#include &lt;pandar_xt_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#public-functions","title":"Public Functions","text":"Type Name PandarXTDecoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; raw_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#function-pandarxtdecoder","title":"function PandarXTDecoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_xt::PandarXTDecoder::PandarXTDecoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_xt::PandarXTDecoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_xt::PandarXTDecoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xt_1_1PandarXTDecoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_xt::PandarXTDecoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; raw_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Unit/","title":"Struct nebula::drivers::pandar_xt::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xt &gt; Unit</p> <ul> <li><code>#include &lt;pandar_xt.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t confidence float distance uint16_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Unit/#variable-confidence","title":"variable confidence","text":"<pre><code>uint16_t nebula::drivers::pandar_xt::Unit::confidence;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_xt::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xt_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint16_t nebula::drivers::pandar_xt::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/","title":"Namespace nebula::drivers::pandar_xtm","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; pandar_xtm</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet class PandarXTMDecoder Hesai LiDAR decoder (XT32M) struct Unit"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t BLOCKS_PER_PACKET   = = 8 constexpr size_t BLOCK_HEADER_AZIMUTH   = = 2 constexpr size_t BLOCK_SIZE   = = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH constexpr size_t BODY_SIZE   = = BLOCK_SIZE * BLOCKS_PER_PACKET constexpr uint32_t DUAL_RETURN   = = 0x39 constexpr uint32_t DUAL_RETURN_B   = = 0x3b constexpr uint32_t DUAL_RETURN_C   = = 0x3c constexpr size_t ENGINE_VELOCITY   = = 2 constexpr size_t FACTORY_SIZE   = = 1 constexpr uint32_t FIRST_RETURN   = = 0x33 constexpr size_t HEADER_SIZE   = = 6 constexpr size_t HEAD_SIZE   = = 12 constexpr size_t LASER_COUNT   = = 32 constexpr uint32_t LAST_RETURN   = = 0x38 const uint16_t MAX_AZIMUTH_DEGREE_NUM   = = 36000 constexpr uint32_t MAX_AZIMUTH_STEPS   = = 360 * 100 constexpr float MAX_RANGE   = = 300.0f constexpr float MIN_RANGE   = = 0.5f constexpr size_t PACKET_SIZE   = = 820 constexpr size_t PACKET_TAIL_SIZE   = = 28 constexpr size_t PRE_HEADER_SIZE   = = 6 constexpr size_t RESERVED_SIZE   = = 10 constexpr size_t RETURN_SIZE   = = 1 constexpr size_t SEQUENCE_SIZE   = = 4 constexpr uint32_t STRONGEST_RETURN   = = 0x37 constexpr size_t TIMESTAMP_SIZE   = = 4 constexpr uint32_t TRIPLE_RETURN   = = 0x3d constexpr size_t UNIT_SIZE   = = 4 constexpr size_t UTC_SIZE   = = 6 const float blockXTMOffsetDual   = = { 5.632f - 50.0f * 2.0f, 5.632f - 50.0f * 2.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f} const float blockXTMOffsetSingle   = = { 5.632f - 50.0f * 5.0f, 5.632f - 50.0f * 4.0f, 5.632f - 50.0f * 3.0f, 5.632f - 50.0f * 2.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f} const float blockXTMOffsetTriple   = = { 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f} const float laserXTMOffset   = = { 2.856f * 0.0f + 0.368f,  2.856f * 1.0f + 0.368f,  2.856f * 2.0f + 0.368f, 2.856f * 3.0f + 0.368f,  2.856f * 4.0f + 0.368f,  2.856f * 5.0f + 0.368f, 2.856f * 6.0f + 0.368f,  2.856f * 7.0f + 0.368f, <p>2.856f * 8.0f + 0.368f,  2.856f * 9.0f + 0.368f,  2.856f * 10.0f + 0.368f,   2.856f * 11.0f + 0.368f, 2.856f * 12.0f + 0.368f, 2.856f * 13.0f + 0.368f,   2.856f * 14.0f + 0.368f, 2.856f * 15.0f + 0.368f,</p> <p>2.856f * 0.0f + 0.368f,  2.856f * 1.0f + 0.368f,  2.856f * 2.0f + 0.368f,   2.856f * 3.0f + 0.368f,  2.856f * 4.0f + 0.368f,  2.856f * 5.0f + 0.368f,   2.856f * 6.0f + 0.368f,  2.856f * 7.0f + 0.368f,</p> <p>2.856f * 8.0f + 0.368f,  2.856f * 9.0f + 0.368f,  2.856f * 10.0f + 0.368f,   2.856f * 11.0f + 0.368f, 2.856f * 12.0f + 0.368f, 2.856f * 13.0f + 0.368f,   2.856f * 14.0f + 0.368f, 2.856f * 15.0f + 0.368f} |</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-blocks_per_packet","title":"variable BLOCKS_PER_PACKET","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::BLOCKS_PER_PACKET;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-block_header_azimuth","title":"variable BLOCK_HEADER_AZIMUTH","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::BLOCK_HEADER_AZIMUTH;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-block_size","title":"variable BLOCK_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::BLOCK_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-body_size","title":"variable BODY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::BODY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-dual_return","title":"variable DUAL_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::DUAL_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-dual_return_b","title":"variable DUAL_RETURN_B","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::DUAL_RETURN_B;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-dual_return_c","title":"variable DUAL_RETURN_C","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::DUAL_RETURN_C;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-engine_velocity","title":"variable ENGINE_VELOCITY","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::ENGINE_VELOCITY;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-factory_size","title":"variable FACTORY_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::FACTORY_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-first_return","title":"variable FIRST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::FIRST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-header_size","title":"variable HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-head_size","title":"variable HEAD_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::HEAD_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-laser_count","title":"variable LASER_COUNT","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::LASER_COUNT;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-last_return","title":"variable LAST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::LAST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-max_azimuth_degree_num","title":"variable MAX_AZIMUTH_DEGREE_NUM","text":"<pre><code>const uint16_t nebula::drivers::pandar_xtm::MAX_AZIMUTH_DEGREE_NUM;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-max_azimuth_steps","title":"variable MAX_AZIMUTH_STEPS","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::MAX_AZIMUTH_STEPS;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-max_range","title":"variable MAX_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_xtm::MAX_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-min_range","title":"variable MIN_RANGE","text":"<pre><code>constexpr float nebula::drivers::pandar_xtm::MIN_RANGE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-packet_size","title":"variable PACKET_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::PACKET_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-packet_tail_size","title":"variable PACKET_TAIL_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::PACKET_TAIL_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-pre_header_size","title":"variable PRE_HEADER_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::PRE_HEADER_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-reserved_size","title":"variable RESERVED_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::RESERVED_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-return_size","title":"variable RETURN_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::RETURN_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-sequence_size","title":"variable SEQUENCE_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::SEQUENCE_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-strongest_return","title":"variable STRONGEST_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::STRONGEST_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-timestamp_size","title":"variable TIMESTAMP_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::TIMESTAMP_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-triple_return","title":"variable TRIPLE_RETURN","text":"<pre><code>constexpr uint32_t nebula::drivers::pandar_xtm::TRIPLE_RETURN;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-unit_size","title":"variable UNIT_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::UNIT_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-utc_size","title":"variable UTC_SIZE","text":"<pre><code>constexpr size_t nebula::drivers::pandar_xtm::UTC_SIZE;\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-blockxtmoffsetdual","title":"variable blockXTMOffsetDual","text":"<pre><code>const float nebula::drivers::pandar_xtm::blockXTMOffsetDual[];\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-blockxtmoffsetsingle","title":"variable blockXTMOffsetSingle","text":"<pre><code>const float nebula::drivers::pandar_xtm::blockXTMOffsetSingle[];\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-blockxtmoffsettriple","title":"variable blockXTMOffsetTriple","text":"<pre><code>const float nebula::drivers::pandar_xtm::blockXTMOffsetTriple[];\n</code></pre>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1pandar__xtm/#variable-laserxtmoffset","title":"variable laserXTMOffset","text":"<pre><code>const float nebula::drivers::pandar_xtm::laserXTMOffset[];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Block/","title":"Struct nebula::drivers::pandar_xtm::Block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xtm &gt; Block</p> <ul> <li><code>#include &lt;pandar_xtm.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Block/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t azimuth Unit units"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Block/#variable-azimuth","title":"variable azimuth","text":"<pre><code>uint16_t nebula::drivers::pandar_xtm::Block::azimuth;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Block/#variable-units","title":"variable units","text":"<pre><code>Unit nebula::drivers::pandar_xtm::Block::units[LASER_COUNT];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/","title":"Struct nebula::drivers::pandar_xtm::Header","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xtm &gt; Header</p> <ul> <li><code>#include &lt;pandar_xtm.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name int8_t chBlockNumber int8_t chDisUnit int8_t chLaserNumber int8_t chProtocolMajor int8_t chProtocolMinor int8_t chReturnType uint16_t sob"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-chblocknumber","title":"variable chBlockNumber","text":"<pre><code>int8_t nebula::drivers::pandar_xtm::Header::chBlockNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-chdisunit","title":"variable chDisUnit","text":"<pre><code>int8_t nebula::drivers::pandar_xtm::Header::chDisUnit;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-chlasernumber","title":"variable chLaserNumber","text":"<pre><code>int8_t nebula::drivers::pandar_xtm::Header::chLaserNumber;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-chprotocolmajor","title":"variable chProtocolMajor","text":"<pre><code>int8_t nebula::drivers::pandar_xtm::Header::chProtocolMajor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-chprotocolminor","title":"variable chProtocolMinor","text":"<pre><code>int8_t nebula::drivers::pandar_xtm::Header::chProtocolMinor;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-chreturntype","title":"variable chReturnType","text":"<pre><code>int8_t nebula::drivers::pandar_xtm::Header::chReturnType;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Header/#variable-sob","title":"variable sob","text":"<pre><code>uint16_t nebula::drivers::pandar_xtm::Header::sob;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/","title":"Struct nebula::drivers::pandar_xtm::Packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xtm &gt; Packet</p> <ul> <li><code>#include &lt;pandar_xtm.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#public-attributes","title":"Public Attributes","text":"Type Name Block blocks Header header uint32_t return_mode tm t uint32_t usec"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#variable-blocks","title":"variable blocks","text":"<pre><code>Block nebula::drivers::pandar_xtm::Packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#variable-header","title":"variable header","text":"<pre><code>Header nebula::drivers::pandar_xtm::Packet::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#variable-return_mode","title":"variable return_mode","text":"<pre><code>uint32_t nebula::drivers::pandar_xtm::Packet::return_mode;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#variable-t","title":"variable t","text":"<pre><code>tm nebula::drivers::pandar_xtm::Packet::t;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Packet/#variable-usec","title":"variable usec","text":"<pre><code>uint32_t nebula::drivers::pandar_xtm::Packet::usec;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/","title":"Class nebula::drivers::pandar_xtm::PandarXTMDecoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xtm &gt; PandarXTMDecoder</p> <p>Hesai LiDAR decoder (XT32M) </p> <ul> <li><code>#include &lt;pandar_xtm_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::HesaiScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#public-functions","title":"Public Functions","text":"Type Name PandarXTMDecoder (const std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; raw_packet) overrideParsing and shaping PandarPacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#public-functions-inherited-from-nebuladrivershesaiscandecoder","title":"Public Functions inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name HesaiScanDecoder (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder (const HesaiScanDecoder &amp; c) = delete HesaiScanDecoder () = default virtual drivers::NebulaPointCloudPtr convert (size_t block_id) = 0Virtual function for converting to point cloud. virtual drivers::NebulaPointCloudPtr convert_dual (size_t block_id) = 0Virtual function for converting to point cloud for dual return. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. HesaiScanDecoder &amp; operator= (HesaiScanDecoder &amp;&amp; c) = delete HesaiScanDecoder &amp; operator= (const HesaiScanDecoder &amp; c) = delete virtual bool parsePacket (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing PandarPacket based on packet structure. virtual int unpack (const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0Virtual function for parsing and shaping PandarPacket. virtual ~HesaiScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#protected-attributes-inherited-from-nebuladrivershesaiscandecoder","title":"Protected Attributes inherited from nebula::drivers::HesaiScanDecoder","text":"<p>See nebula::drivers::HesaiScanDecoder</p> Type Name double dual_return_distance_threshold_   = {} bool has_scanned_   = {} int last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; sensor_calibration_ Calibration for this decoder. std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#function-pandarxtmdecoder","title":"function PandarXTMDecoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::pandar_xtm::PandarXTMDecoder::PandarXTMDecoder (\nconst std::shared_ptr&lt; drivers::HesaiSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::HesaiCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::pandar_xtm::PandarXTMDecoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::HesaiScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::pandar_xtm::PandarXTMDecoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::HesaiScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1pandar__xtm_1_1PandarXTMDecoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping PandarPacket. <pre><code>virtual int nebula::drivers::pandar_xtm::PandarXTMDecoder::unpack (\nconst pandar_msgs::msg::PandarPacket &amp; raw_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pandar_packet</code> </li> </ul> <p>Implements nebula::drivers::HesaiScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Unit/","title":"Struct nebula::drivers::pandar_xtm::Unit","text":"<p>ClassList &gt; nebula &gt; drivers &gt; pandar_xtm &gt; Unit</p> <ul> <li><code>#include &lt;pandar_xtm.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Unit/#public-attributes","title":"Public Attributes","text":"Type Name uint16_t confidence float distance uint16_t intensity"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Unit/#variable-confidence","title":"variable confidence","text":"<pre><code>uint16_t nebula::drivers::pandar_xtm::Unit::confidence;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Unit/#variable-distance","title":"variable distance","text":"<pre><code>float nebula::drivers::pandar_xtm::Unit::distance;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1pandar__xtm_1_1Unit/#variable-intensity","title":"variable intensity","text":"<pre><code>uint16_t nebula::drivers::pandar_xtm::Unit::intensity;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/","title":"Struct nebula::drivers::raw_block","text":"<p>ClassList &gt; nebula &gt; drivers &gt; raw_block</p> <p>Raw Velodyne data block. More...</p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t data uint16_t header UPPER_BANK or LOWER_BANK. uint16_t rotation 0-35999, divide by 100 to get degrees"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#detailed-description","title":"Detailed Description","text":"<p>Each block contains data from either the upper or lower laser bank. The device returns three times as many upper bank blocks.</p> <p>use stdint.h types, so things work with both 64 and 32-bit machines </p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#variable-data","title":"variable data","text":"<pre><code>uint8_t nebula::drivers::raw_block::data[BLOCK_DATA_SIZE];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#variable-header","title":"variable header","text":"<pre><code>uint16_t nebula::drivers::raw_block::header;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__block/#variable-rotation","title":"variable rotation","text":"<pre><code>uint16_t nebula::drivers::raw_block::rotation;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/","title":"Struct nebula::drivers::raw_packet","text":"<p>ClassList &gt; nebula &gt; drivers &gt; raw_packet</p> <p>Raw Velodyne packet. More...</p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#public-attributes","title":"Public Attributes","text":"Type Name raw_block_t blocks uint16_t revolution uint8_t status"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#detailed-description","title":"Detailed Description","text":"<p>revolution is described in the device manual as incrementing (mod 65536) for each physical turn of the device. Our device seems to alternate between two different values every third packet. One value increases, the other decreases.</p> <p>Todo</p> <p>figure out if revolution is only present for one of the two types of status fields</p> <p>status has either a temperature encoding or the microcode level </p>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#variable-blocks","title":"variable blocks","text":"<pre><code>raw_block_t nebula::drivers::raw_packet::blocks[BLOCKS_PER_PACKET];\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#variable-revolution","title":"variable revolution","text":"<pre><code>uint16_t nebula::drivers::raw_packet::revolution;\n</code></pre>"},{"location":"nebula_decoders/structnebula_1_1drivers_1_1raw__packet/#variable-status","title":"variable status","text":"<pre><code>uint8_t nebula::drivers::raw_packet::status[PACKET_STATUS_SIZE];\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/","title":"Union nebula::drivers::two_bytes","text":"<p>ClassList &gt; nebula &gt; drivers &gt; two_bytes</p> <p>More...</p> <ul> <li><code>#include &lt;velodyne_scan_decoder.hpp&gt;</code></li> </ul>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t bytes uint16_t uint"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#detailed-description","title":"Detailed Description","text":"<p>used for unpacking the first two data bytes in a block</p> <p>They are packed into the actual data stream misaligned. I doubt this works on big endian machines. </p>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#variable-bytes","title":"variable bytes","text":"<pre><code>uint8_t nebula::drivers::two_bytes::bytes[2];\n</code></pre>"},{"location":"nebula_decoders/unionnebula_1_1drivers_1_1two__bytes/#variable-uint","title":"variable uint","text":"<pre><code>uint16_t nebula::drivers::two_bytes::uint;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/","title":"Namespace nebula::drivers::vlp16","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; vlp16</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#classes","title":"Classes","text":"Type Name class Vlp16Decoder Velodyne LiDAR decoder (VLP16)"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#public-attributes","title":"Public Attributes","text":"Type Name constexpr uint32_t MAX_POINTS   = = 300000"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp16/#variable-max_points","title":"variable MAX_POINTS","text":"<pre><code>constexpr uint32_t nebula::drivers::vlp16::MAX_POINTS;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp16_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/","title":"Class nebula::drivers::vlp16::Vlp16Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; vlp16 &gt; Vlp16Decoder</p> <p>Velodyne LiDAR decoder (VLP16) </p> <ul> <li><code>#include &lt;vlp16_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::VelodyneScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#public-functions","title":"Public Functions","text":"Type Name Vlp16Decoder (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int pointsPerPacket () overrideCalculation of points in each packet. virtual void reset_overflow () overrideResetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) overrideResetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) overrideParsing and shaping VelodynePacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#public-functions-inherited-from-nebuladriversvelodynescandecoder","title":"Public Functions inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow () = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#protected-attributes-inherited-from-nebuladriversvelodynescandecoder","title":"Protected Attributes inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-vlp16decoder","title":"function Vlp16Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::vlp16::Vlp16Decoder::Vlp16Decoder (\nconst std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::vlp16::Vlp16Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::VelodyneScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::vlp16::Vlp16Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::VelodyneScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::vlp16::Vlp16Decoder::pointsPerPacket () override\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#of-points","title":"of points","text":"<p>Implements nebula::drivers::VelodyneScanDecoder::pointsPerPacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::vlp16::Vlp16Decoder::reset_overflow () override\n</code></pre> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_overflow</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::vlp16::Vlp16Decoder::reset_pointcloud (\nsize_t n_pts\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp16_1_1Vlp16Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::vlp16::Vlp16Decoder::unpack (\nconst velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_packet</code> </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp16_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp32/","title":"Namespace nebula::drivers::vlp32","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; vlp32</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vlp32/#classes","title":"Classes","text":"Type Name class Vlp32Decoder Velodyne LiDAR decoder (VLP32) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp32_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/","title":"Class nebula::drivers::vlp32::Vlp32Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; vlp32 &gt; Vlp32Decoder</p> <p>Velodyne LiDAR decoder (VLP32) </p> <ul> <li><code>#include &lt;vlp32_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::VelodyneScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#public-functions","title":"Public Functions","text":"Type Name Vlp32Decoder (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int pointsPerPacket () overrideCalculation of points in each packet. virtual void reset_overflow () overrideResetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) overrideResetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) overrideParsing and shaping VelodynePacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#public-functions-inherited-from-nebuladriversvelodynescandecoder","title":"Public Functions inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow () = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#protected-attributes-inherited-from-nebuladriversvelodynescandecoder","title":"Protected Attributes inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-vlp32decoder","title":"function Vlp32Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::vlp32::Vlp32Decoder::Vlp32Decoder (\nconst std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::vlp32::Vlp32Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::VelodyneScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::vlp32::Vlp32Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::VelodyneScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::vlp32::Vlp32Decoder::pointsPerPacket () override\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#of-points","title":"of points","text":"<p>Implements nebula::drivers::VelodyneScanDecoder::pointsPerPacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::vlp32::Vlp32Decoder::reset_overflow () override\n</code></pre> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_overflow</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::vlp32::Vlp32Decoder::reset_pointcloud (\nsize_t n_pts\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vlp32_1_1Vlp32Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::vlp32::Vlp32Decoder::unpack (\nconst velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_packet</code> </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp32_decoder.hpp</code></p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vls128/","title":"Namespace nebula::drivers::vls128","text":"<p>Namespace List &gt; nebula &gt; drivers &gt; vls128</p>"},{"location":"nebula_decoders/namespacenebula_1_1drivers_1_1vls128/#classes","title":"Classes","text":"Type Name class Vls128Decoder Velodyne LiDAR decoder (VLS128) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vls128_decoder.hpp</code></p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/","title":"Class nebula::drivers::vls128::Vls128Decoder","text":"<p>ClassList &gt; nebula &gt; drivers &gt; vls128 &gt; Vls128Decoder</p> <p>Velodyne LiDAR decoder (VLS128) </p> <ul> <li><code>#include &lt;vls128_decoder.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::VelodyneScanDecoder</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#public-functions","title":"Public Functions","text":"Type Name Vls128Decoder (const std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration, const std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration) Constructor. virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () overrideGet the constructed point cloud. virtual bool hasScanned () overrideGet the flag indicating whether one cycle is ready. virtual int pointsPerPacket () overrideCalculation of points in each packet. virtual void reset_overflow () overrideResetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) overrideResetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) overrideParsing and shaping VelodynePacket."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#public-functions-inherited-from-nebuladriversvelodynescandecoder","title":"Public Functions inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name VelodyneScanDecoder (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder (const VelodyneScanDecoder &amp; c) = delete VelodyneScanDecoder () = default virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; get_pointcloud () = 0Virtual function for getting the constructed point cloud. virtual bool hasScanned () = 0Virtual function for getting the flag indicating whether one cycle is ready. VelodyneScanDecoder &amp; operator= (VelodyneScanDecoder &amp;&amp; c) = delete VelodyneScanDecoder &amp; operator= (const VelodyneScanDecoder &amp; c) = delete virtual bool parsePacket (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing VelodynePacket based on packet structure. virtual int pointsPerPacket () = 0Calculation of points in each packet. virtual void reset_overflow () = 0Resetting overflowed point cloud buffer. virtual void reset_pointcloud (size_t n_pts) = 0Resetting point cloud buffer. virtual void unpack (const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0Virtual function for parsing and shaping VelodynePacket. virtual ~VelodyneScanDecoder () = default"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#protected-attributes-inherited-from-nebuladriversvelodynescandecoder","title":"Protected Attributes inherited from nebula::drivers::VelodyneScanDecoder","text":"<p>See nebula::drivers::VelodyneScanDecoder</p> Type Name std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; calibration_configuration_ Calibration for this decoder. double dual_return_distance_threshold_   = {} bool has_scanned_   = = true uint16_t last_phase_   = {} drivers::NebulaPointCloudPtr overflow_pc_ Point cloud overflowing from one cycle. drivers::NebulaPointCloudPtr scan_pc_ Decoded point cloud. uint16_t scan_phase_   = {} double scan_timestamp_   = {} std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; sensor_configuration_ SensorConfiguration for this decoder."},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-vls128decoder","title":"function Vls128Decoder","text":"<p>Constructor. <pre><code>explicit nebula::drivers::vls128::Vls128Decoder::Vls128Decoder (\nconst std::shared_ptr&lt; drivers::VelodyneSensorConfiguration &gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt; drivers::VelodyneCalibrationConfiguration &gt; &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this decoder </li> <li><code>calibration_configuration</code> Calibration for this decoder </li> </ul>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-get_pointcloud","title":"function get_pointcloud","text":"<p>Get the constructed point cloud. <pre><code>virtual std::tuple&lt; drivers::NebulaPointCloudPtr, double &gt; nebula::drivers::vls128::Vls128Decoder::get_pointcloud () override\n</code></pre></p> <p>Returns:</p> <p>tuple of Point cloud and timestamp </p> <p>Implements nebula::drivers::VelodyneScanDecoder::get_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-hasscanned","title":"function hasScanned","text":"<p>Get the flag indicating whether one cycle is ready. <pre><code>virtual bool nebula::drivers::vls128::Vls128Decoder::hasScanned () override\n</code></pre></p> <p>Returns:</p> <p>Readied </p> <p>Implements nebula::drivers::VelodyneScanDecoder::hasScanned</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-pointsperpacket","title":"function pointsPerPacket","text":"<p>Calculation of points in each packet. <pre><code>virtual int nebula::drivers::vls128::Vls128Decoder::pointsPerPacket () override\n</code></pre></p> <p>Returns:</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#of-points","title":"of points","text":"<p>Implements nebula::drivers::VelodyneScanDecoder::pointsPerPacket</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-reset_overflow","title":"function reset_overflow","text":"<pre><code>virtual void nebula::drivers::vls128::Vls128Decoder::reset_overflow () override\n</code></pre> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_overflow</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-reset_pointcloud","title":"function reset_pointcloud","text":"<p>Resetting point cloud buffer. <pre><code>virtual void nebula::drivers::vls128::Vls128Decoder::reset_pointcloud (\nsize_t n_pts\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n_pts</code> # of points </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::reset_pointcloud</p>"},{"location":"nebula_decoders/classnebula_1_1drivers_1_1vls128_1_1Vls128Decoder/#function-unpack","title":"function unpack","text":"<p>Parsing and shaping VelodynePacket. <pre><code>virtual void nebula::drivers::vls128::Vls128Decoder::unpack (\nconst velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet\n) override\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>velodyne_packet</code> </li> </ul> <p>Implements nebula::drivers::VelodyneScanDecoder::unpack</p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vls128_decoder.hpp</code></p>"},{"location":"nebula_decoders/dir_092e1212e2f122a1b02d21090e0bc2ae/","title":"Dir nebula_decoders","text":"<p>FileList &gt; nebula_decoders</p>"},{"location":"nebula_decoders/dir_092e1212e2f122a1b02d21090e0bc2ae/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_decoders/</code></p>"},{"location":"nebula_decoders/dir_ad7c7fa181818f82243609476539152a/","title":"Dir nebula_decoders/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_decoders/dir_ad7c7fa181818f82243609476539152a/#directories","title":"Directories","text":"Type Name dir nebula_decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/</code></p>"},{"location":"nebula_decoders/dir_2debd97622a84cc0aad22cb768ccd4f1/","title":"Dir nebula_decoders/include/nebula_decoders","text":"<p>FileList &gt; include &gt; nebula_decoders</p>"},{"location":"nebula_decoders/dir_2debd97622a84cc0aad22cb768ccd4f1/#directories","title":"Directories","text":"Type Name dir nebula_decoders_common dir nebula_decoders_hesai dir nebula_decoders_velodyne <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/</code></p>"},{"location":"nebula_decoders/dir_e9f39979da8d18d6cbf99a488b9210ec/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_common","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_common</p>"},{"location":"nebula_decoders/dir_e9f39979da8d18d6cbf99a488b9210ec/#files","title":"Files","text":"Type Name file nebula_driver_base.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/</code></p>"},{"location":"nebula_decoders/nebula__driver__base_8hpp/","title":"File nebula_driver_base.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_common &gt; nebula_driver_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_decoders/nebula__driver__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/nebula__driver__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaDriverBase Base class for each sensor driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp</code></p>"},{"location":"nebula_decoders/nebula__driver__base_8hpp_source/","title":"File nebula_driver_base.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_common &gt; nebula_driver_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_DRIVER_BASE_H\n#define NEBULA_DRIVER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass NebulaDriverBase\n{\npublic:\nNebulaDriverBase(NebulaDriverBase &amp;&amp; c) = delete;\nNebulaDriverBase &amp; operator=(NebulaDriverBase &amp;&amp; c) = delete;\nNebulaDriverBase(const NebulaDriverBase &amp; c) = delete;\nNebulaDriverBase &amp; operator=(const NebulaDriverBase &amp; c) = delete;\n\nNebulaDriverBase() = default;\n\nvirtual Status SetCalibrationConfiguration(\nconst CalibrationConfigurationBase &amp; calibration_configuration) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n#endif  // NEBULA_DRIVER_BASE_H\n</code></pre>"},{"location":"nebula_decoders/dir_7f8077aa31d3279eb8922efb51d95b65/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_hesai","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_hesai</p>"},{"location":"nebula_decoders/dir_7f8077aa31d3279eb8922efb51d95b65/#files","title":"Files","text":"Type Name file hesai_driver.hpp"},{"location":"nebula_decoders/dir_7f8077aa31d3279eb8922efb51d95b65/#directories","title":"Directories","text":"Type Name dir decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/</code></p>"},{"location":"nebula_decoders/hesai__driver_8hpp/","title":"File hesai_driver.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_hesai &gt; hesai_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;pcl_conversions/pcl_conversions.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/hesai__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/hesai__driver_8hpp/#classes","title":"Classes","text":"Type Name class HesaiDriver Hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp</code></p>"},{"location":"nebula_decoders/hesai__driver_8hpp_source/","title":"File hesai_driver.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_hesai &gt; hesai_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HESAI_DRIVER_H\n#define NEBULA_HESAI_DRIVER_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;pcl_conversions/pcl_conversions.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass HesaiDriver : NebulaDriverBase\n{\nprivate:\nStatus driver_status_;\nstd::shared_ptr&lt;drivers::HesaiScanDecoder&gt; scan_decoder_;\n\npublic:\nHesaiDriver() = delete;\nexplicit HesaiDriver(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCorrection&gt; &amp; correction_configuration = nullptr);\n\nStatus GetStatus();\n\nStatus SetCalibrationConfiguration(\nconst CalibrationConfigurationBase &amp; calibration_configuration) override;\n\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; ConvertScanToPointcloud(\nconst std::shared_ptr&lt;pandar_msgs::msg::PandarScan&gt; &amp; pandar_scan);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HESAI_DRIVER_H\n</code></pre>"},{"location":"nebula_decoders/dir_2bf573d84977ebd5e34295c1efb6f907/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders","text":"<p>FileList &gt; decoders</p>"},{"location":"nebula_decoders/dir_2bf573d84977ebd5e34295c1efb6f907/#files","title":"Files","text":"Type Name file hesai_scan_decoder.hpp file pandar_128_e4x.hpp file pandar_128_e4x_decoder.hpp file pandar_40.hpp file pandar_40_decoder.hpp file pandar_64.hpp file pandar_64_decoder.hpp file pandar_at.hpp file pandar_at_decoder.hpp file pandar_qt_128.hpp file pandar_qt_128_decoder.hpp file pandar_qt_64.hpp file pandar_qt_64_decoder.hpp file pandar_xt.hpp file pandar_xt_decoder.hpp file pandar_xtm.hpp file pandar_xtm_decoder.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/</code></p>"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp/","title":"File hesai_scan_decoder.hpp","text":"<p>FileList &gt; decoders &gt; hesai_scan_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;tuple&gt;</code></li> </ul>"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp/#classes","title":"Classes","text":"Type Name class HesaiScanDecoder Base class for Hesai LiDAR decoder. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/hesai__scan__decoder_8hpp_source/","title":"File hesai_scan_decoder.hpp","text":"<p>File List &gt; decoders &gt; hesai_scan_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_WS_HESAI_SCAN_DECODER_HPP\n#define NEBULA_WS_HESAI_SCAN_DECODER_HPP\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/point_types.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;tuple&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass HesaiScanDecoder\n{\nprotected:\ndrivers::NebulaPointCloudPtr scan_pc_;\ndrivers::NebulaPointCloudPtr overflow_pc_;\n\nuint16_t scan_phase_{};\nint last_phase_{};\nbool has_scanned_{};\ndouble dual_return_distance_threshold_{};\ndouble scan_timestamp_{};\n\nstd::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; sensor_configuration_;\nstd::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; sensor_calibration_;\n\npublic:\nHesaiScanDecoder(HesaiScanDecoder &amp;&amp; c) = delete;\nHesaiScanDecoder &amp; operator=(HesaiScanDecoder &amp;&amp; c) = delete;\nHesaiScanDecoder(const HesaiScanDecoder &amp; c) = delete;\nHesaiScanDecoder &amp; operator=(const HesaiScanDecoder &amp; c) = delete;\n\nvirtual ~HesaiScanDecoder() = default;\nHesaiScanDecoder() = default;\n\nvirtual int unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0;\n\nvirtual bool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) = 0;\n\nvirtual drivers::NebulaPointCloudPtr convert(size_t block_id) = 0;\nvirtual drivers::NebulaPointCloudPtr convert_dual(size_t block_id) = 0;\n\nvirtual bool hasScanned() = 0;\n\nvirtual std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() = 0;\n};\n}  // namespace drivers\n}  // namespace nebula\n#endif  // NEBULA_WS_HESAI_SCAN_DECODER_HPP\n</code></pre>"},{"location":"nebula_decoders/pandar__128__e4x_8hpp/","title":"File pandar_128_e4x.hpp","text":"<p>FileList &gt; decoders &gt; pandar_128_e4x.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__128__e4x_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_128_e4x"},{"location":"nebula_decoders/pandar__128__e4x_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct BlockExtended struct Body struct BodyExtended struct DateTime struct FunctionalSafety struct Header struct Packet struct PacketExtended struct Tail <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp</code></p>"},{"location":"nebula_decoders/pandar__128__e4x_8hpp_source/","title":"File pandar_128_e4x.hpp","text":"<p>File List &gt; decoders &gt; pandar_128_e4x.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_128_e4x\n{\nconstexpr size_t LASER_COUNT = 128;\n\nconstexpr uint8_t SINGLE_FIRST_RETURN = 0x33;\nconstexpr uint8_t SINGLE_STRONGEST_RETURN = 0x37;\nconstexpr uint8_t SINGLE_LAST_RETURN = 0x38;\n\nconstexpr uint8_t DUAL_LAST_STRONGEST_RETURN = 0x39;\nconstexpr uint8_t DUAL_LAST_FIRST_RETURN = 0x3B;\nconstexpr uint8_t DUAL_FIRST_STRONGEST_RETURN = 0x3C;\n\nconstexpr uint8_t HIGH_RES_STATE = 0x00;\nconstexpr uint8_t STANDARD_RES_STATE = 0x01;\n\nconstexpr uint16_t MAX_AZIMUTH_STEPS = 3600;  // High Res mode\nconstexpr float DISTANCE_UNIT = 0.004f;       // 4mm\n\nconstexpr uint8_t HEADER_SIZE = 12;\nconstexpr uint16_t BODY_SIZE = 776;\nconstexpr uint8_t TAIL_SIZE = 56;\nconstexpr uint8_t FUNCTIONAL_SAFETY_SIZE = 17;\nconstexpr uint16_t PACKET_SIZE = HEADER_SIZE + BODY_SIZE + FUNCTIONAL_SAFETY_SIZE + TAIL_SIZE;\nconstexpr float MIN_RANGE = 0.1;\nconstexpr float MAX_RANGE = 230.0;\nconstexpr uint16_t THREE_SIXTY = 360;\nconstexpr size_t NUM_BLOCKS = 2;\n\nconstexpr size_t UNUSED_INT = 0;\n\n#pragma pack(push, 1)\nstruct Header\n{  // 12 bytes\n// Pre header\nuint16_t SOP;\nuint8_t ProtocolMajor;\nuint8_t ProtocolMinor;\nuint16_t Reserved;\n// Header\nuint8_t LaserNum;\nuint8_t BlockNum;\nuint8_t FirstBlockReturn;\nuint8_t DistanceUnitMm;\nuint8_t ReturnNum;\nuint8_t Flags;\n};\n\nstruct BlockExtended\n{  // 4 bytes\nuint16_t distance;\nuint8_t reflectivity;\nuint8_t reserved;\n};\n\nstruct Block\n{  // 3 bytes\nuint16_t distance;\nuint8_t reflectivity;\n};\n\nstruct Body\n{  // 776 bytes\nuint16_t azimuth_1;\nBlock block_01[LASER_COUNT];  // 384 bytes\nuint16_t azimuth_2;\nBlock block_02[LASER_COUNT];  // 384 bytes\nuint32_t crc_1;\n};\n\nstruct BodyExtended\n{  // 1032 bytes\nuint16_t azimuth_1;\nBlockExtended block_01[LASER_COUNT];  // 512 bytes\nuint16_t azimuth_2;\nBlockExtended block_02[LASER_COUNT];  // 512 bytes\nuint32_t crc_1;\n};\n\nstruct FunctionalSafety\n{  // 17 bytes\nuint8_t reserved[17];\n};\n\nstruct DateTime\n{  // 6 bytes\nuint8_t year;\nuint8_t month;\nuint8_t day;\nuint8_t hour;\nuint8_t minute;\nuint8_t second;\n};\n\nstruct Tail\n{  // 56\nuint8_t reserved_01[9];\nuint16_t azimuth_state;\nuint8_t operational_state;\nuint8_t return_mode;\nuint16_t motor_speed_rpm;\nDateTime date_time;\nuint32_t timestamp_us;\nuint8_t factory_info;\nuint32_t udp_sequence;\nuint8_t reserved_02[22];\nuint32_t crc_32;\n};\n\nstruct Packet\n{\nHeader header;\nBody body;\nFunctionalSafety functional_safety;\nTail tail;\n};\n\nstruct PacketExtended\n{\nHeader header;\nBodyExtended body;\nFunctionalSafety functional_safety;\nTail tail;\n};\n#pragma pack(pop)\n\n}  // namespace pandar_128_e4x\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__128__e4x__decoder_8hpp/","title":"File pandar_128_e4x_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_128_e4x_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__128__e4x__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_128_e4x"},{"location":"nebula_decoders/pandar__128__e4x__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Pandar128E4XDecoder <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__128__e4x__decoder_8hpp_source/","title":"File pandar_128_e4x_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_128_e4x_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_128_e4x.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_128_e4x\n{\nclass Pandar128E4XDecoder : public HesaiScanDecoder\n{\npublic:\nexplicit Pandar128E4XDecoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\ndrivers::NebulaPoint build_point(\nconst Block &amp; block, const size_t &amp; laser_id, const uint16_t &amp; azimuth,\nconst uint32_t &amp; unix_second, float &amp; out_distance);\ndrivers::NebulaPointCloudPtr convert(size_t) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t) override;\nbool is_dual_return();\nstatic uint32_t get_epoch_from_datetime(const DateTime &amp; date_time);\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; cos_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; sin_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nPacket packet_{};\nuint32_t current_unit_unix_second_{};\nuint8_t first_return_type_{};\nuint8_t second_return_type_{};\n\n//  PacketExtended packet_extended_{};\n};\n\n}  // namespace pandar_128_e4x\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__40_8hpp/","title":"File pandar_40.hpp","text":"<p>FileList &gt; decoders &gt; pandar_40.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__40_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_40"},{"location":"nebula_decoders/pandar__40_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp</code></p>"},{"location":"nebula_decoders/pandar__40_8hpp_source/","title":"File pandar_40.hpp","text":"<p>File List &gt; decoders &gt; pandar_40.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_40\n{\nconstexpr double MIN_RANGE = 0.3f;\nconstexpr double MAX_RANGE = 200.f;\nconstexpr size_t SOB_ANGLE_SIZE = 4;\nconstexpr size_t RAW_MEASURE_SIZE = 3;\nconstexpr size_t LASER_COUNT = 40;\nconstexpr size_t BLOCKS_PER_PACKET = 10;\nconstexpr size_t BLOCK_SIZE = RAW_MEASURE_SIZE * LASER_COUNT + SOB_ANGLE_SIZE;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t FACTORY_INFO_SIZE = 1;\nconstexpr size_t RETURN_SIZE = 1;\nconstexpr size_t RESERVE_SIZE = 8;\nconstexpr size_t REVOLUTION_SIZE = 2;\nconstexpr size_t INFO_SIZE =\nTIMESTAMP_SIZE + FACTORY_INFO_SIZE + RETURN_SIZE + RESERVE_SIZE + REVOLUTION_SIZE;\nconstexpr size_t UTC_TIME = 6;\nconstexpr size_t PACKET_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET + INFO_SIZE + UTC_TIME;\nconstexpr size_t SEQ_NUM_SIZE = 4;\nconstexpr float LASER_RETURN_TO_DISTANCE_RATE = 0.004;\nconstexpr uint32_t STRONGEST_RETURN = 0x37;\nconstexpr uint32_t LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_RETURN = 0x39;\nconstexpr uint32_t MAX_AZIMUTH_STEPS = 360 * 100;  // Unit: 0.01\u00b0\n\nstruct Unit\n{\nuint8_t intensity;\nfloat distance;\n};\n\nstruct Block\n{\nuint16_t azimuth;\nuint16_t sob;\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nBlock blocks[BLOCKS_PER_PACKET];\nstruct tm t;\nuint32_t usec;\nuint32_t return_mode;\n};\n\n}  // namespace pandar_40\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__40__decoder_8hpp/","title":"File pandar_40_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_40_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__40__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_40"},{"location":"nebula_decoders/pandar__40__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Pandar40Decoder Hesai LiDAR decoder (Pandar40) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_40_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__40__decoder_8hpp_source/","title":"File pandar_40_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_40_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_40.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_40\n{\nclass Pandar40Decoder : public HesaiScanDecoder\n{\npublic:\nexplicit Pandar40Decoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\ndrivers::NebulaPoint build_point(size_t block_id, size_t unit_id, uint8_t return_type);\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; cos_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; sin_elevation_angle_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nstd::array&lt;float, LASER_COUNT&gt; firing_time_offset_{};\nstd::array&lt;size_t, LASER_COUNT&gt; vertical_laser_firing_order_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_single_return_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_dual_return_{};\n\nPacket packet_{};\n};\n\n}  // namespace pandar_40\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__64_8hpp/","title":"File pandar_64.hpp","text":"<p>FileList &gt; decoders &gt; pandar_64.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__64_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_64"},{"location":"nebula_decoders/pandar__64_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp</code></p>"},{"location":"nebula_decoders/pandar__64_8hpp_source/","title":"File pandar_64.hpp","text":"<p>File List &gt; decoders &gt; pandar_64.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_64\n{\nconstexpr double MIN_RANGE = 0.3f;\nconstexpr double MAX_RANGE = 200.f;\n// Head\nconstexpr size_t HEAD_SIZE = 8;\n// Body\nconstexpr size_t BLOCKS_PER_PACKET = 6;\nconstexpr size_t BLOCK_HEADER_AZIMUTH = 2;\nconstexpr size_t LASER_COUNT = 64;\nconstexpr size_t UNIT_SIZE = 3;\nconstexpr size_t BLOCK_SIZE = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH;\nconstexpr size_t BODY_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET;\n// Tail\nconstexpr size_t RESERVED_SIZE = 8;\nconstexpr size_t HIGH_TEMPERATURE = 1;\nconstexpr size_t ENGINE_VELOCITY = 2;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t RETURN_SIZE = 1;  // echo\nconstexpr size_t FACTORY_SIZE = 1;\nconstexpr size_t UTC_SIZE = 6;\nconstexpr size_t PACKET_TAIL_SIZE = 26;\nconstexpr size_t PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE = 22;\n\n// All\nconstexpr size_t PACKET_SIZE = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_SIZE;\nconstexpr size_t PACKET_WITHOUT_UDP_SEQ_SIZE =\nHEAD_SIZE + BODY_SIZE + PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE;\n\nconstexpr uint32_t STRONGEST_RETURN = 0x37;\nconstexpr uint32_t LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_RETURN = 0x39;\nconstexpr uint32_t MAX_AZIMUTH_STEPS = 360 * 100;  // Unit: 0.01\u00b0\n\nstruct Header\n{\nuint16_t sob;          // 0xEEFF 2bytes\nint8_t chLaserNumber;  // laser number 1byte\nint8_t chBlockNumber;  // block number 1byte\nint8_t chReturnType;   // return mode 1 byte  when dual return 0-Single Return\n// 1-The first block is the 1 st return.\n// 2-The first block is the 2 nd return\nint8_t chDisUnit;  // Distance unit, 4mm\n};\n\nstruct Unit\n{\nfloat distance;\nuint16_t intensity;\n};\n\nstruct Block\n{\nuint16_t azimuth;  // packet angle,Azimuth = RealAzimuth * 100\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nHeader header;\nBlock blocks[BLOCKS_PER_PACKET];\nuint32_t usec;  // ms\nuint32_t return_mode;\ntm t;\n};\n}  // namespace pandar_64\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__64__decoder_8hpp/","title":"File pandar_64_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_64_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__64__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_64"},{"location":"nebula_decoders/pandar__64__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Pandar64Decoder Hesai LiDAR decoder (Pandar64) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_64_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__64__decoder_8hpp_source/","title":"File pandar_64_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_64_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_64.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_64\n{\nclass Pandar64Decoder : public HesaiScanDecoder\n{\npublic:\nexplicit Pandar64Decoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\ndrivers::NebulaPoint build_point(size_t block_id, size_t unit_id, uint8_t return_type);\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; cos_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; sin_elevation_angle_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nstd::array&lt;float, LASER_COUNT&gt; firing_time_offset_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_single_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_dual_{};\n\nPacket packet_{};\n};\n\n}  // namespace pandar_64\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__at_8hpp/","title":"File pandar_at.hpp","text":"<p>FileList &gt; decoders &gt; pandar_at.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__at_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_at"},{"location":"nebula_decoders/pandar__at_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp</code></p>"},{"location":"nebula_decoders/pandar__at_8hpp_source/","title":"File pandar_at.hpp","text":"<p>File List &gt; decoders &gt; pandar_at.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_at\n{\nconstexpr float MIN_RANGE = 1.f;\nconstexpr float MAX_RANGE = 180.0f;\n// Head\nconstexpr size_t HEAD_SIZE = 12;\nconstexpr size_t PRE_HEADER_SIZE = 6;\nconstexpr size_t HEADER_SIZE = 6;\n// Body\nconstexpr size_t BLOCKS_PER_PACKET = 2;\n// constexpr size_t BLOCK_HEADER_AZIMUTH = 2;\nconstexpr size_t BLOCK_HEADER_AZIMUTH = 3;\n// constexpr size_t BLOCK_HEADER_FINE_AZIMUTH = 1;\nconstexpr size_t LASER_COUNT = 128;\nconstexpr size_t UNIT_SIZE = 4;\nconstexpr size_t CRC_SIZE = 4;\nconstexpr size_t BLOCK_SIZE =\nUNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH;  // + BLOCK_HEADER_FINE_AZIMUTH;\nconstexpr size_t BODY_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET + CRC_SIZE;\n// Tail\nconstexpr size_t RESERVED1_SIZE = 6;\nconstexpr size_t HIGH_TEMP_SHUTDOWN_FLAG_SIZE = 1;\nconstexpr size_t RESERVED2_SIZE = 11;\nconstexpr size_t MOTOR_SPEED_SIZE = 2;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t RETURN_SIZE = 1;\nconstexpr size_t FACTORY_SIZE = 1;\nconstexpr size_t UTC_SIZE = 6;\nconstexpr size_t SEQUENCE_SIZE = 4;\nconstexpr size_t PACKET_TAIL_SIZE = 40;\n\n// All\nconstexpr size_t PACKET_SIZE = 1118;\n\n// 0x33 - First Return      0x39 - Dual Return (Last, Strongest)\n// 0x37 - Strongest Return  0x3B - Dual Return (Last, First)\n// 0x38 - Last Return       0x3C - Dual Return (First, Strongest)\n\nconstexpr uint32_t FIRST_RETURN = 0x33;\nconstexpr uint32_t STRONGEST_RETURN = 0x37;\nconstexpr uint32_t LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_RETURN = 0x39;\nconstexpr uint32_t DUAL_RETURN_B = 0x3b;\nconstexpr uint32_t DUAL_RETURN_C = 0x3c;\nconstexpr uint32_t TRIPLE_RETURN = 0x3d;\n\nstruct Header\n{\nuint16_t sob;            // 0xFFEE 2bytes\nint8_t chProtocolMajor;  // Protocol Version Major 1byte\nint8_t chProtocolMinor;  // Protocol Version Minor 1byte\nint chLaserNumber;       // laser number 1byte (=128, so int8_t leads error)\nint8_t chBlockNumber;    // block number 1byte\nint8_t chReturnType;     // return mode 1 byte  when dual return 0-Single Return\n// 1-The first block is the 1 st return.\n// 2-The first block is the 2 nd return\nint8_t chDisUnit;        // Distance unit, 4mm\n};\n\nstruct Unit\n{\nfloat distance;\nuint16_t intensity;\nuint16_t confidence;\n};\n\nstruct Block\n{\nuint16_t azimuth;       // packet angle,Azimuth = RealAzimuth * 100\nuint16_t fine_azimuth;  // packet angle,Fine Azimuth = RealAzimuth * 100 / 256\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nHeader header;\nBlock blocks[BLOCKS_PER_PACKET];\nuint32_t usec;  // ms\nuint32_t return_mode;\nuint32_t shutdown_flg;\nuint32_t motor_speed;\ntm t;\ndouble unix_second;\n};\n}  // namespace pandar_at\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__at__decoder_8hpp/","title":"File pandar_at_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_at_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__at__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_at"},{"location":"nebula_decoders/pandar__at__decoder_8hpp/#classes","title":"Classes","text":"Type Name class PandarATDecoder Hesai LiDAR decoder (AT128) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_at_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__at__decoder_8hpp_source/","title":"File pandar_at_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_at_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_at.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_at\n{\nconst uint32_t channel_firing_ns[] = {\n0,     0,     8240,  4112,  4144,  8240,  0,     0,     12424, 4144,  4112,  8264,  12376,\n12376, 8264,  12424, 0,     0,     4112,  8240,  4144,  0,     0,     4144,  12424, 8264,\n4112,  12376, 12376, 12424, 8264,  848,   2504,  4976,  6616,  6616,  9112,  2504,  848,\n10768, 13280, 13280, 4976,  9112,  14928, 14928, 10768, 2504,  848,   6616,  4976,  9112,\n6616,  848,   2504,  13280, 10768, 4976,  13280, 14928, 9112,  10768, 14928, 13280, 848,\n9112,  13280, 2504,  4976,  848,   2504,  14928, 10768, 10768, 14928, 4976,  6616,  6616,\n9112,  848,   13280, 13280, 9112,  4976,  2504,  2504,  848,   10768, 14928, 14928, 10768,\n6616,  4976,  9112,  6616,  4112,  1242,  0,     4144,  0,     0,     12424, 0,     8264,\n4112,  4144,  8240,  8240,  8264,  12376, 12376, 12424, 4112,  4144,  0,     0,     0,\n0,     0,     12424, 8264,  8240,  4144,  8264,  8240,  12376, 12376, 8264};\n\nconst uint16_t MAX_AZIMUTH_DEGREE_NUM = 36000;\n\nconst uint16_t LIDAR_AZIMUTH_UNIT = 256;\nconst uint32_t MAX_AZI_LEN = 36000 * 256;\n\nconst uint32_t SCAN_POINTS_NUM = 1200 * LASER_COUNT;\nconst uint16_t MAX_RETURN_COUNT = 2;\n\nclass PandarATDecoder : public HesaiScanDecoder\n{\npublic:\nexplicit PandarATDecoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCorrection&gt; &amp; correction_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; raw_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\n\n#if defined(ROS_DISTRO_FOXY) || defined(ROS_DISTRO_GALACTIC)\nvoid CalcXTPointXYZIT(\nint block_id, int chLaserNumber, boost::shared_ptr&lt;pcl::PointCloud&lt;NebulaPoint&gt;&gt; cld);\n#else\nvoid CalcXTPointXYZIT(\nint block_id, int chLaserNumber, std::shared_ptr&lt;pcl::PointCloud&lt;NebulaPoint&gt;&gt; cld);\n#endif\n\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\nvoid convert(size_t block_id, NebulaPointCloudPtr &amp; out_pc);\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nstd::array&lt;float, LASER_COUNT&gt; elev_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\n\n//  std::array&lt;float, LASER_COUNT&gt; firing_offset_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_offset_single_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_offset_dual_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_offset_triple_{};\n\nstd::vector&lt;float&gt; m_sin_map_;\nstd::vector&lt;float&gt; m_cos_map_;\n\nPacket packet_{};\n\nint last_azimuth_;\nint max_azimuth_;\nuint16_t last_field_;\nint start_angle_;\ndouble last_timestamp_;\n\nstd::shared_ptr&lt;drivers::HesaiCorrection&gt; correction_configuration_;\n\nbool use_dat = true;\n};\n\n}  // namespace pandar_at\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__qt__128_8hpp/","title":"File pandar_qt_128.hpp","text":"<p>FileList &gt; decoders &gt; pandar_qt_128.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__qt__128_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_qt_128"},{"location":"nebula_decoders/pandar__qt__128_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp</code></p>"},{"location":"nebula_decoders/pandar__qt__128_8hpp_source/","title":"File pandar_qt_128.hpp","text":"<p>File List &gt; decoders &gt; pandar_qt_128.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_qt_128\n{\nconstexpr uint16_t MAX_AZIMUTH_STEPS = 36000;  // High Res mode\n// constexpr float DISTANCE_UNIT = 0.004f;       // 4mm\nconstexpr double MIN_RANGE = 0.05;\nconstexpr double MAX_RANGE = 50.0;\n\n// Head\nconstexpr size_t HEAD_SIZE = 12;\n// Body\nconstexpr size_t BLOCKS_PER_PACKET = 2;\nconstexpr size_t BLOCK_HEADER_AZIMUTH = 2;\nconstexpr size_t LASER_COUNT = 128;\nconstexpr size_t UNIT_SIZE = 4;\nconstexpr size_t CRC_SIZE = 4;\nconstexpr size_t BLOCK_SIZE = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH;\nconstexpr size_t BODY_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET + CRC_SIZE;\n// Functional Safety\nconstexpr size_t PACKET_FS_SIZE = 17;\n// Tail\nconstexpr size_t RESERVED2_SIZE = 5;\nconstexpr size_t MODE_FLAG_SIZE = 1;\nconstexpr size_t RESERVED3_SIZE = 6;\nconstexpr size_t UTC_SIZE = 6;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t FACTORY_SIZE = 1;\nconstexpr size_t PACKET_TAIL_SIZE = 34;\nconstexpr size_t PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE = 26;\nconstexpr size_t PACKET_TAIL_TIMESTAMP_OFFSET = 1076;\n\n// Cyber Security\nconstexpr size_t SIGNATURE_SIZE = 32;\n\nconstexpr size_t SKIP_SIZE = PACKET_FS_SIZE + RESERVED2_SIZE;\n\n// All\nconstexpr size_t PACKET_SIZE =\nHEAD_SIZE + BODY_SIZE + PACKET_FS_SIZE + PACKET_TAIL_SIZE + SIGNATURE_SIZE;\nconstexpr size_t PACKET_WITHOUT_UDP_SEQ_CRC_SIZE =\nHEAD_SIZE + BODY_SIZE + PACKET_FS_SIZE + PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE;\n\nconstexpr uint32_t SINGLE_FIRST_RETURN = 0x33;\nconstexpr uint32_t SINGLE_SECOND_RETURN = 0x34;\nconstexpr uint32_t SINGLE_STRONGEST_RETURN = 0x37;\nconstexpr uint32_t SINGLE_LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_LAST_STRONGEST_RETURN = 0x39;\nconstexpr uint32_t DUAL_FIRST_LAST_RETURN = 0x3B;\nconstexpr uint32_t DUAL_FIRST_STRONGEST_RETURN = 0x3C;\nconstexpr uint32_t DUAL_STRONGEST_2ndSTRONGEST_RETURN = 0x3E;\nconstexpr uint32_t DUAL_FIRST_SECOND_RETURN = 0x3A;\n\nstruct Header\n{\nuint16_t sob;             // 0xFFEE 2bytes\nuint8_t chProtocolMajor;  // Protocol Version Major 1byte\nuint8_t chProtocolMinor;  // Protocol Version Minor 1byte\nuint8_t chLaserNumber;    // laser number 1byte\nuint8_t chBlockNumber;    // block number 1byte\nuint8_t chDisUnit;        // Distance unit, 4mm\nuint8_t chReturnType;     // return mode 1 byte  when dual return 0-Single Return\n// 1-The first block is the 1 st return.\n// 2-The first block is the 2 nd return\nuint8_t chFlags;          // [6] channel customization: 1-Selected channels, 0-All channels\n// [3] digital signature: 1-YES, 0-NO\n// [2] functional safety: 1-YES, 0-NO\n// [1] IMU: 1-YES, 0-NO\n// [0] UDP sequence: 1-YES, 0-NO\n};\n\nstruct Unit\n{\nfloat distance;\nuint16_t intensity;\nuint16_t confidence;\n};\n\nstruct Block\n{\nuint16_t azimuth;  // packet angle,Azimuth = RealAzimuth * 100\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nHeader header;\nBlock blocks[BLOCKS_PER_PACKET];\nuint32_t usec;  // ms\nuint32_t mode_flag;\nuint32_t return_mode;\ntm t;\n};\nconst std::string PandarQT128_TL1 = R\"(33,27.656\n34,53\n35,2.312\n36,78.344\n37,81.512\n38,5.48\n39,56.168\n40,30.824\n41,33.992\n42,59.336\n43,8.648\n44,84.68\n45,87.848\n46,11.816\n47,62.504\n48,37.16\n49,40.328\n50,65.672\n51,14.984\n52,91.016\n53,94.184\n54,18.152\n55,68.84\n56,43.496\n57,46.664\n58,72.008\n59,21.32\n60,97.352\n61,100.52\n62,24.488\n63,75.176\n64,49.832\n65,1.456\n66,77.488\n67,26.8\n68,52.144\n69,55.312\n70,29.968\n71,80.656\n72,4.624\n73,7.792\n74,83.824\n75,33.136\n76,58.48\n77,61.648\n78,36.304\n79,86.992\n80,10.96\n81,14.128\n82,90.16\n83,39.472\n84,64.816\n85,67.984\n86,42.64\n87,93.328\n88,17.296\n89,20.464\n90,96.496\n91,45.808\n92,71.152\n93,74.32\n94,48.976\n95,99.664\n96,23.632\n97,25.944\n98,51.288\n99,0.6\n100,76.632\n101,79.8\n102,3.768\n103,54.456\n104,29.112\n105,32.28\n106,57.624\n107,6.936\n108,82.968\n109,86.136\n110,10.104\n111,60.792\n112,35.448\n113,38.616\n114,63.96\n115,13.272\n116,89.304\n117,92.472\n118,16.44\n119,67.128\n120,41.784\n121,44.952\n122,70.296\n123,19.608\n124,95.64\n125,98.808\n126,22.776\n127,73.464\n128,48.12)\";\nconst std::string PandarQT128_TL2 = R\"(1,2.312\n2,78.344\n3,27.656\n4,53\n5,56.168\n6,30.824\n7,81.512\n8,5.48\n9,8.648\n10,84.68\n11,33.992\n12,59.336\n13,62.504\n14,37.16\n15,87.848\n16,11.816\n17,14.984\n18,91.016\n19,40.328\n20,65.672\n21,68.84\n22,43.496\n23,94.184\n24,18.152\n25,21.32\n26,97.352\n27,46.664\n28,72.008\n29,75.176\n30,49.832\n31,100.52\n32,24.488\n65,0.6\n66,76.632\n67,25.944\n68,51.288\n69,54.456\n70,29.112\n71,79.8\n72,3.768\n73,6.936\n74,82.968\n75,32.28\n76,57.624\n77,60.792\n78,35.448\n79,86.136\n80,10.104\n81,13.272\n82,89.304\n83,38.616\n84,63.96\n85,67.128\n86,41.784\n87,92.472\n88,16.44\n89,19.608\n90,95.64\n91,44.952\n92,70.296\n93,73.464\n94,48.12\n95,98.808\n96,22.776\n97,26.8\n98,52.144\n99,1.456\n100,77.488\n101,80.656\n102,4.624\n103,55.312\n104,29.968\n105,33.136\n106,58.48\n107,7.792\n108,83.824\n109,86.992\n110,10.96\n111,61.648\n112,36.304\n113,39.472\n114,64.816\n115,14.128\n116,90.16\n117,93.328\n118,17.296\n119,67.984\n120,42.64\n121,45.808\n122,71.152\n123,20.464\n124,96.496\n125,99.664\n126,23.632\n127,74.32\n128,48.976)\";\n}  // namespace pandar_qt_128\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__qt__128__decoder_8hpp/","title":"File pandar_qt_128_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_qt_128_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__qt__128__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_qt_128"},{"location":"nebula_decoders/pandar__qt__128__decoder_8hpp/#classes","title":"Classes","text":"Type Name class PandarQT128Decoder Hesai LiDAR decoder (QT128) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__qt__128__decoder_8hpp_source/","title":"File pandar_qt_128_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_qt_128_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_128.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_qt_128\n{\nclass PandarQT128Decoder : public HesaiScanDecoder\n{\npublic:\nexplicit PandarQT128Decoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\ndrivers::NebulaPoint build_point(\nsize_t block_id, size_t unit_id, bool dual_return, const double &amp; unix_second);\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nbool is_dual_return();\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; elev_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; cos_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; sin_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nstd::map&lt;int, float&gt; firing_time_offset1_{};\nstd::map&lt;int, float&gt; firing_time_offset2_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_single_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_dual_{};\n\nuint8_t first_return_type_{};\nuint8_t second_return_type_{};\n\nPacket packet_{};\n};\n\n}  // namespace pandar_qt_128\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__qt__64_8hpp/","title":"File pandar_qt_64.hpp","text":"<p>FileList &gt; decoders &gt; pandar_qt_64.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__qt__64_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_qt_64"},{"location":"nebula_decoders/pandar__qt__64_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp</code></p>"},{"location":"nebula_decoders/pandar__qt__64_8hpp_source/","title":"File pandar_qt_64.hpp","text":"<p>File List &gt; decoders &gt; pandar_qt_64.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_qt_64\n{\nconstexpr double MIN_RANGE = 0.1f;\nconstexpr double MAX_RANGE = 60.f;\n// Head\nconstexpr size_t HEAD_SIZE = 12;\nconstexpr size_t PRE_HEADER_SIZE = 6;\nconstexpr size_t HEADER_SIZE = 6;\n// Body\nconstexpr size_t BLOCKS_PER_PACKET = 4;\nconstexpr size_t BLOCK_HEADER_AZIMUTH = 2;\nconstexpr size_t LASER_COUNT = 64;\nconstexpr size_t UNIT_SIZE = 4;\nconstexpr size_t BLOCK_SIZE = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH;\nconstexpr size_t BODY_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET;\n// Tail\nconstexpr size_t RESERVED_SIZE = 10;\nconstexpr size_t ENGINE_VELOCITY = 2;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t RETURN_SIZE = 1;\nconstexpr size_t FACTORY_SIZE = 1;\nconstexpr size_t UTC_SIZE = 6;\nconstexpr size_t SEQUENCE_SIZE = 4;\nconstexpr size_t PACKET_TAIL_SIZE = 28;\nconstexpr size_t PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE = 24;\n\n// All\nconstexpr size_t PACKET_SIZE = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_SIZE;\nconstexpr size_t PACKET_WITHOUT_UDP_SEQ_SIZE =\nHEAD_SIZE + BODY_SIZE + PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE;\n\nconstexpr uint32_t FIRST_RETURN = 0x33;\nconstexpr uint32_t LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_RETURN_B = 0x3b;\nconstexpr uint32_t MAX_AZIMUTH_STEPS = 360 * 100;  // Unit: 0.01\u00b0\n\nstruct Header\n{\nuint16_t sob;            // 0xFFEE 2bytes\nint8_t chProtocolMajor;  // Protocol Version Major 1byte\nint8_t chProtocolMinor;  // Protocol Version Minor 1byte\nint8_t chLaserNumber;    // laser number 1byte\nint8_t chBlockNumber;    // block number 1byte\nint8_t chReturnType;     // return mode 1 byte  when dual return 0-Single Return\n// 1-The first block is the 1 st return.\n// 2-The first block is the 2 nd return\nint8_t chDisUnit;        // Distance unit, 4mm\n};\n\nstruct Unit\n{\nfloat distance;\nuint16_t intensity;\nuint16_t confidence;\n};\n\nstruct Block\n{\nuint16_t azimuth;  // packet angle,Azimuth = RealAzimuth * 100\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nHeader header;\nBlock blocks[BLOCKS_PER_PACKET];\nuint32_t usec;  // ms\nuint32_t return_mode;\ntm t;\n};\n}  // namespace pandar_qt_64\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__qt__64__decoder_8hpp/","title":"File pandar_qt_64_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_qt_64_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__qt__64__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_qt_64"},{"location":"nebula_decoders/pandar__qt__64__decoder_8hpp/#classes","title":"Classes","text":"Type Name class PandarQT64Decoder Hesai LiDAR decoder (QT64) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__qt__64__decoder_8hpp_source/","title":"File pandar_qt_64_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_qt_64_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_qt_64.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_qt_64\n{\nclass PandarQT64Decoder : public HesaiScanDecoder\n{\npublic:\nexplicit PandarQT64Decoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\ndrivers::NebulaPoint build_point(size_t block_id, size_t unit_id, uint8_t return_type);\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; cos_elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; sin_elevation_angle_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nstd::array&lt;float, LASER_COUNT&gt; firing_offset_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_single_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_dual_{};\n\nPacket packet_{};\n};\n\n}  // namespace pandar_qt_64\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__xt_8hpp/","title":"File pandar_xt.hpp","text":"<p>FileList &gt; decoders &gt; pandar_xt.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__xt_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_xt"},{"location":"nebula_decoders/pandar__xt_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp</code></p>"},{"location":"nebula_decoders/pandar__xt_8hpp_source/","title":"File pandar_xt.hpp","text":"<p>File List &gt; decoders &gt; pandar_xt.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_xt\n{\nconstexpr float MIN_RANGE = 0.05f;\nconstexpr float MAX_RANGE = 120.0f;\n// Head\nconstexpr size_t HEAD_SIZE = 12;\nconstexpr size_t PRE_HEADER_SIZE = 6;\nconstexpr size_t HEADER_SIZE = 6;\n// Body\nconstexpr size_t BLOCKS_PER_PACKET = 8;\nconstexpr size_t BLOCK_HEADER_AZIMUTH = 2;\nconstexpr size_t LASER_COUNT = 32;\nconstexpr size_t UNIT_SIZE = 4;\nconstexpr size_t BLOCK_SIZE = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH;\nconstexpr size_t BODY_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET;\n// Tail\nconstexpr size_t RESERVED_SIZE = 10;\nconstexpr size_t ENGINE_VELOCITY = 2;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t RETURN_SIZE = 1;\nconstexpr size_t FACTORY_SIZE = 1;\nconstexpr size_t UTC_SIZE = 6;\nconstexpr size_t SEQUENCE_SIZE = 4;\nconstexpr size_t PACKET_TAIL_SIZE = 28;\n\n// All\nconstexpr size_t PACKET_SIZE = HEAD_SIZE + BODY_SIZE + PACKET_TAIL_SIZE;\n\n// 0x33 - First Return      0x39 - Dual Return (Last, Strongest)\n// 0x37 - Strongest Return  0x3B - Dual Return (Last, First)\n// 0x38 - Last Return       0x3C - Dual Return (First, Strongest)\n\nconstexpr uint32_t STRONGEST_RETURN = 0x37;\nconstexpr uint32_t LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_RETURN = 0x39;\nconstexpr uint32_t MAX_AZIMUTH_STEPS = 360 * 100;  // Unit: 0.01\u00b0\n\nstruct Header\n{\nuint16_t sob;            // 0xFFEE 2bytes\nint8_t chProtocolMajor;  // Protocol Version Major 1byte\nint8_t chProtocolMinor;  // Protocol Version Minor 1byte\nint8_t chLaserNumber;    // laser number 1byte\nint8_t chBlockNumber;    // block number 1byte\nint8_t chReturnType;     // return mode 1 byte  when dual return 0-Single Return\n// 1-The first block is the 1 st return.\n// 2-The first block is the 2 nd return\nint8_t chDisUnit;        // Distance unit, 4mm\n};\n\nstruct Unit\n{\nfloat distance;\nuint16_t intensity;\nuint16_t confidence;\n};\n\nstruct Block\n{\nuint16_t azimuth;  // packet angle,Azimuth = RealAzimuth * 100\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nHeader header;\nBlock blocks[BLOCKS_PER_PACKET];\nuint32_t usec;  // ms\nuint32_t return_mode;\ntm t;\n};\n}  // namespace pandar_xt\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__xt__decoder_8hpp/","title":"File pandar_xt_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_xt_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__xt__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_xt"},{"location":"nebula_decoders/pandar__xt__decoder_8hpp/#classes","title":"Classes","text":"Type Name class PandarXTDecoder Hesai LiDAR decoder (XT32) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__xt__decoder_8hpp_source/","title":"File pandar_xt_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_xt_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_xt.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_xt\n{\nclass PandarXTDecoder : public HesaiScanDecoder\n{\npublic:\nexplicit PandarXTDecoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; raw_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\ndrivers::NebulaPoint build_point(int block_id, int unit_id, uint8_t return_type);\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nstd::array&lt;float, LASER_COUNT&gt; firing_time_offset_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_single_return_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_offset_dual_return_{};\n\nPacket packet_{};\n};\n\n}  // namespace pandar_xt\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__xtm_8hpp/","title":"File pandar_xtm.hpp","text":"<p>FileList &gt; decoders &gt; pandar_xtm.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__xtm_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_xtm"},{"location":"nebula_decoders/pandar__xtm_8hpp/#classes","title":"Classes","text":"Type Name struct Block struct Header struct Packet struct Unit <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp</code></p>"},{"location":"nebula_decoders/pandar__xtm_8hpp_source/","title":"File pandar_xtm.hpp","text":"<p>File List &gt; decoders &gt; pandar_xtm.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;ctime&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_xtm\n{\nconstexpr float MIN_RANGE = 0.5f;\nconstexpr float MAX_RANGE = 300.0f;\n// Head\nconstexpr size_t HEAD_SIZE = 12;\nconstexpr size_t PRE_HEADER_SIZE = 6;\nconstexpr size_t HEADER_SIZE = 6;\n// Body\nconstexpr size_t BLOCKS_PER_PACKET = 8;\nconstexpr size_t BLOCK_HEADER_AZIMUTH = 2;\nconstexpr size_t LASER_COUNT = 32;\nconstexpr size_t UNIT_SIZE = 4;\nconstexpr size_t BLOCK_SIZE = UNIT_SIZE * LASER_COUNT + BLOCK_HEADER_AZIMUTH;\nconstexpr size_t BODY_SIZE = BLOCK_SIZE * BLOCKS_PER_PACKET;\n// Tail\nconstexpr size_t RESERVED_SIZE = 10;\nconstexpr size_t ENGINE_VELOCITY = 2;\nconstexpr size_t TIMESTAMP_SIZE = 4;\nconstexpr size_t RETURN_SIZE = 1;\nconstexpr size_t FACTORY_SIZE = 1;\nconstexpr size_t UTC_SIZE = 6;\nconstexpr size_t SEQUENCE_SIZE = 4;\nconstexpr size_t PACKET_TAIL_SIZE = 28;\n\n// All\nconstexpr size_t PACKET_SIZE = 820;\n\n// 0x33 - First Return      0x39 - Dual Return (Last, Strongest)\n// 0x37 - Strongest Return  0x3B - Dual Return (Last, First)\n// 0x38 - Last Return       0x3C - Dual Return (First, Strongest)\n\nconstexpr uint32_t FIRST_RETURN = 0x33;\nconstexpr uint32_t STRONGEST_RETURN = 0x37;\nconstexpr uint32_t LAST_RETURN = 0x38;\nconstexpr uint32_t DUAL_RETURN = 0x39;\nconstexpr uint32_t DUAL_RETURN_B = 0x3b;\nconstexpr uint32_t DUAL_RETURN_C = 0x3c;\nconstexpr uint32_t TRIPLE_RETURN = 0x3d;\nconstexpr uint32_t MAX_AZIMUTH_STEPS = 360 * 100;  // Unit: 0.01\u00b0\n\nstruct Header\n{\nuint16_t sob;            // 0xFFEE 2bytes\nint8_t chProtocolMajor;  // Protocol Version Major 1byte\nint8_t chProtocolMinor;  // Protocol Version Minor 1byte\nint8_t chLaserNumber;    // laser number 1byte\nint8_t chBlockNumber;    // block number 1byte\nint8_t chReturnType;     // return mode 1 byte  when dual return 0-Single Return\n// 1-The first block is the 1 st return.\n// 2-The first block is the 2 nd return\nint8_t chDisUnit;        // Distance unit, 4mm\n};\n\nstruct Unit\n{\nfloat distance;\nuint16_t intensity;\nuint16_t confidence;\n};\n\nstruct Block\n{\nuint16_t azimuth;  // packet angle,Azimuth = RealAzimuth * 100\nUnit units[LASER_COUNT];\n};\n\nstruct Packet\n{\nHeader header;\nBlock blocks[BLOCKS_PER_PACKET];\nuint32_t usec;  // ms\nuint32_t return_mode;\ntm t;\n};\n}  // namespace pandar_xtm\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/pandar__xtm__decoder_8hpp/","title":"File pandar_xtm_decoder.hpp","text":"<p>FileList &gt; decoders &gt; pandar_xtm_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/pandar__xtm__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace pandar_xtm"},{"location":"nebula_decoders/pandar__xtm__decoder_8hpp/#classes","title":"Classes","text":"Type Name class PandarXTMDecoder Hesai LiDAR decoder (XT32M) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm_decoder.hpp</code></p>"},{"location":"nebula_decoders/pandar__xtm__decoder_8hpp_source/","title":"File pandar_xtm_decoder.hpp","text":"<p>File List &gt; decoders &gt; pandar_xtm_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/hesai_scan_decoder.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/decoders/pandar_xtm.hpp\"\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace pandar_xtm\n{\nconst float blockXTMOffsetTriple[] = {\n5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 0.0f,\n5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f};\n\nconst float blockXTMOffsetDual[] = {\n5.632f - 50.0f * 2.0f, 5.632f - 50.0f * 2.0f, 5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 1.0f,\n5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f};\nconst float blockXTMOffsetSingle[] = {\n5.632f - 50.0f * 5.0f, 5.632f - 50.0f * 4.0f, 5.632f - 50.0f * 3.0f, 5.632f - 50.0f * 2.0f,\n5.632f - 50.0f * 1.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f, 5.632f - 50.0f * 0.0f};\n\nconst float laserXTMOffset[] = {\n2.856f * 0.0f + 0.368f,  2.856f * 1.0f + 0.368f,  2.856f * 2.0f + 0.368f,\n2.856f * 3.0f + 0.368f,  2.856f * 4.0f + 0.368f,  2.856f * 5.0f + 0.368f,\n2.856f * 6.0f + 0.368f,  2.856f * 7.0f + 0.368f,\n\n2.856f * 8.0f + 0.368f,  2.856f * 9.0f + 0.368f,  2.856f * 10.0f + 0.368f,\n2.856f * 11.0f + 0.368f, 2.856f * 12.0f + 0.368f, 2.856f * 13.0f + 0.368f,\n2.856f * 14.0f + 0.368f, 2.856f * 15.0f + 0.368f,\n\n2.856f * 0.0f + 0.368f,  2.856f * 1.0f + 0.368f,  2.856f * 2.0f + 0.368f,\n2.856f * 3.0f + 0.368f,  2.856f * 4.0f + 0.368f,  2.856f * 5.0f + 0.368f,\n2.856f * 6.0f + 0.368f,  2.856f * 7.0f + 0.368f,\n\n2.856f * 8.0f + 0.368f,  2.856f * 9.0f + 0.368f,  2.856f * 10.0f + 0.368f,\n2.856f * 11.0f + 0.368f, 2.856f * 12.0f + 0.368f, 2.856f * 13.0f + 0.368f,\n2.856f * 14.0f + 0.368f, 2.856f * 15.0f + 0.368f};\n\nconst uint16_t MAX_AZIMUTH_DEGREE_NUM = 36000;\n\nclass PandarXTMDecoder : public HesaiScanDecoder\n{\npublic:\nexplicit PandarXTMDecoder(\nconst std::shared_ptr&lt;drivers::HesaiSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; &amp; calibration_configuration);\nint unpack(const pandar_msgs::msg::PandarPacket &amp; raw_packet) override;\nbool hasScanned() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\n\nprivate:\nbool parsePacket(const pandar_msgs::msg::PandarPacket &amp; pandar_packet) override;\n\n#if defined(ROS_DISTRO_FOXY) || defined(ROS_DISTRO_GALACTIC)\nvoid CalcXTPointXYZIT(\nint block_id, char chLaserNumber, boost::shared_ptr&lt;pcl::PointCloud&lt;NebulaPoint&gt;&gt; cld);\n#else\nvoid CalcXTPointXYZIT(\nint block_id, char chLaserNumber, std::shared_ptr&lt;pcl::PointCloud&lt;NebulaPoint&gt;&gt; cld);\n#endif\n\ndrivers::NebulaPointCloudPtr convert(size_t block_id) override;\ndrivers::NebulaPointCloudPtr convert_dual(size_t block_id) override;\n\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_{};\nstd::array&lt;float, LASER_COUNT&gt; elevation_angle_rad_{};\nstd::array&lt;float, LASER_COUNT&gt; azimuth_offset_rad_{};\n\nstd::array&lt;float, MAX_AZIMUTH_STEPS&gt; block_azimuth_rad_{};\n\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_single_return_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_dual_return_{};\nstd::array&lt;float, BLOCKS_PER_PACKET&gt; block_time_offset_triple_return_{};\n\nstd::vector&lt;float&gt; sin_elevation_angle_;\nstd::vector&lt;float&gt; cos_elevation_angle_;\n\nstd::vector&lt;float&gt; sin_azimuth_angle_;\nstd::vector&lt;float&gt; cos_azimuth_angle_;\n\nPacket packet_{};\n\nuint16_t last_azimuth_;\nint start_angle_;\ndouble last_timestamp_;\n};\n\n}  // namespace pandar_xtm\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/dir_9e9febd3e1d4bd400359d959d7a13c5d/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_velodyne</p>"},{"location":"nebula_decoders/dir_9e9febd3e1d4bd400359d959d7a13c5d/#files","title":"Files","text":"Type Name file velodyne_driver.hpp"},{"location":"nebula_decoders/dir_9e9febd3e1d4bd400359d959d7a13c5d/#directories","title":"Directories","text":"Type Name dir decoders <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/</code></p>"},{"location":"nebula_decoders/dir_283845edb88ec58ddf1e6c9e3e9b0224/","title":"Dir nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders","text":"<p>FileList &gt; decoders</p>"},{"location":"nebula_decoders/dir_283845edb88ec58ddf1e6c9e3e9b0224/#files","title":"Files","text":"Type Name file velodyne_scan_decoder.hpp file vlp16_decoder.hpp file vlp32_decoder.hpp file vls128_decoder.hpp <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/</code></p>"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/","title":"File velodyne_scan_decoder.hpp","text":"<p>FileList &gt; decoders &gt; velodyne_scan_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;boost/format.hpp&gt;</code></li> <li><code>#include &lt;pcl/point_cloud.h&gt;</code></li> <li><code>#include &lt;cerrno&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;angles/angles/angles.h&gt;</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;tuple&gt;</code></li> </ul>"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneScanDecoder Base class for Velodyne LiDAR decoder. struct raw_block Raw Velodyne data block. struct raw_packet Raw Velodyne packet."},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#public-types","title":"Public Types","text":"Type Name union two_bytes"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp/#union-two_bytes","title":"union two_bytes","text":"<p>used for unpacking the first two data bytes in a block</p> <p>They are packed into the actual data stream misaligned. I doubt this works on big endian machines. </p> <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp</code></p>"},{"location":"nebula_decoders/velodyne__scan__decoder_8hpp_source/","title":"File velodyne_scan_decoder.hpp","text":"<p>File List &gt; decoders &gt; velodyne_scan_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_WS_VELODYNE_SCAN_DECODER_HPP\n#define NEBULA_WS_VELODYNE_SCAN_DECODER_HPP\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include &lt;boost/format.hpp&gt;\n\n#include &lt;pcl/point_cloud.h&gt;\n\n#include &lt;cerrno&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#if defined(ROS_DISTRO_FOXY) || defined(ROS_DISTRO_GALACTIC)\n#include &lt;angles/angles.h&gt;  //Galactic\n#else\n#include &lt;angles/angles/angles.h&gt;  //Humble\n#endif\n\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/velodyne/velodyne_calibration_decoder.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;tuple&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nstatic const int SIZE_BLOCK = 100;\nstatic const int RAW_SCAN_SIZE = 3;\nstatic const int SCANS_PER_BLOCK = 32;\nstatic const int BLOCK_DATA_SIZE = (SCANS_PER_BLOCK * RAW_SCAN_SIZE);\n\nstatic const double ROTATION_RESOLUTION = 0.01;     // [deg]\nstatic const uint16_t ROTATION_MAX_UNITS = 36000u;  // [deg/100]\n\nstatic const size_t RETURN_MODE_INDEX = 1204;\n\nstatic const uint16_t UPPER_BANK = 0xeeff;\nstatic const uint16_t LOWER_BANK = 0xddff;\n\nstatic const uint16_t RETURN_MODE_STRONGEST = 55;\nstatic const uint16_t RETURN_MODE_LAST = 56;\nstatic const uint16_t RETURN_MODE_DUAL = 57;\n\nstatic const int VLP16_FIRINGS_PER_BLOCK = 2;\nstatic const int VLP16_SCANS_PER_FIRING = 16;\nstatic const float VLP16_BLOCK_DURATION = 110.592f;  // [\u00b5s]\nstatic const float VLP16_DSR_TOFFSET = 2.304f;       // [\u00b5s]\nstatic const float VLP16_FIRING_TOFFSET = 55.296f;   // [\u00b5s]\n\nstatic const float VLP128_DISTANCE_RESOLUTION = 0.004f;  // [m]\n\n// These are used to detect which bank of 32 lasers is in this block\nstatic const uint16_t VLS128_BANK_1 = 0xeeff;\nstatic const uint16_t VLS128_BANK_2 = 0xddff;\nstatic const uint16_t VLS128_BANK_3 = 0xccff;\nstatic const uint16_t VLS128_BANK_4 = 0xbbff;\n\nstatic const float VLS128_CHANNEL_DURATION =\n2.665f;  // [\u00b5s] Channels corresponds to one laser firing\nstatic const float VLS128_SEQ_DURATION =\n53.3f;  // [\u00b5s] Sequence is a set of laser firings including recharging\n\ntypedef struct raw_block\n{\nuint16_t header;    uint16_t rotation;  uint8_t data[BLOCK_DATA_SIZE];\n} raw_block_t;\n\nunion two_bytes {\nuint16_t uint;\nuint8_t bytes[2];\n};\n\nstatic const int PACKET_SIZE = 1206;\nstatic const int BLOCKS_PER_PACKET = 12;\nstatic const int PACKET_STATUS_SIZE = 4;\nstatic const int SCANS_PER_PACKET = (SCANS_PER_BLOCK * BLOCKS_PER_PACKET);\n\ntypedef struct raw_packet\n{\nraw_block_t blocks[BLOCKS_PER_PACKET];\nuint16_t revolution;\nuint8_t status[PACKET_STATUS_SIZE];\n} raw_packet_t;\n\nenum RETURN_TYPE {\nINVALID = 0,\nSINGLE_STRONGEST = 1,\nSINGLE_LAST = 2,\nDUAL_STRONGEST_FIRST = 3,\nDUAL_STRONGEST_LAST = 4,\nDUAL_WEAK_FIRST = 5,\nDUAL_WEAK_LAST = 6,\nDUAL_ONLY = 7\n};\n\nclass VelodyneScanDecoder\n{\nprotected:\ndrivers::NebulaPointCloudPtr scan_pc_;\ndrivers::NebulaPointCloudPtr overflow_pc_;\n\nuint16_t scan_phase_{};\nuint16_t last_phase_{};\nbool has_scanned_ = true;\ndouble dual_return_distance_threshold_{};  // Velodyne does this internally, this will not be\n// implemented here\ndouble scan_timestamp_{};\n\nstd::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; sensor_configuration_;\nstd::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; calibration_configuration_;\n\npublic:\nVelodyneScanDecoder(VelodyneScanDecoder &amp;&amp; c) = delete;\nVelodyneScanDecoder &amp; operator=(VelodyneScanDecoder &amp;&amp; c) = delete;\nVelodyneScanDecoder(const VelodyneScanDecoder &amp; c) = delete;\nVelodyneScanDecoder &amp; operator=(const VelodyneScanDecoder &amp; c) = delete;\n\nvirtual ~VelodyneScanDecoder() = default;\nVelodyneScanDecoder() = default;\n\nvirtual void unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0;\nvirtual bool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) = 0;\n\nvirtual bool hasScanned() = 0;\nvirtual int pointsPerPacket() = 0;\n\nvirtual std::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() = 0;\nvirtual void reset_pointcloud(size_t n_pts) = 0;\nvirtual void reset_overflow() = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_WS_VELODYNE_SCAN_DECODER_HPP\n</code></pre>"},{"location":"nebula_decoders/vlp16__decoder_8hpp/","title":"File vlp16_decoder.hpp","text":"<p>FileList &gt; decoders &gt; vlp16_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/vlp16__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace vlp16"},{"location":"nebula_decoders/vlp16__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Vlp16Decoder Velodyne LiDAR decoder (VLP16) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp16_decoder.hpp</code></p>"},{"location":"nebula_decoders/vlp16__decoder_8hpp_source/","title":"File vlp16_decoder.hpp","text":"<p>File List &gt; decoders &gt; vlp16_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace vlp16\n{\nconstexpr uint32_t MAX_POINTS = 300000;\nclass Vlp16Decoder : public VelodyneScanDecoder\n{\npublic:\nexplicit Vlp16Decoder(\nconst std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\nvoid unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\nbool hasScanned() override;\nint pointsPerPacket() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\nvoid reset_pointcloud(size_t n_pts) override;\nvoid reset_overflow() override;\n\nprivate:\nbool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\nfloat sin_rot_table_[ROTATION_MAX_UNITS];\nfloat cos_rot_table_[ROTATION_MAX_UNITS];\nfloat rotation_radians_[ROTATION_MAX_UNITS];\nint phase_;\nint max_pts_;\nstd::vector&lt;std::vector&lt;float&gt;&gt; timing_offsets_;\n};\n\n}  // namespace vlp16\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/vlp32__decoder_8hpp/","title":"File vlp32_decoder.hpp","text":"<p>FileList &gt; decoders &gt; vlp32_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/vlp32__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace vlp32"},{"location":"nebula_decoders/vlp32__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Vlp32Decoder Velodyne LiDAR decoder (VLP32) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vlp32_decoder.hpp</code></p>"},{"location":"nebula_decoders/vlp32__decoder_8hpp_source/","title":"File vlp32_decoder.hpp","text":"<p>File List &gt; decoders &gt; vlp32_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace vlp32\n{\nclass Vlp32Decoder : public VelodyneScanDecoder\n{\npublic:\nexplicit Vlp32Decoder(\nconst std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\nvoid unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\nbool hasScanned() override;\nint pointsPerPacket() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\nvoid reset_pointcloud(size_t n_pts) override;\nvoid reset_overflow() override;\n\nprivate:\nbool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\nfloat sin_rot_table_[ROTATION_MAX_UNITS];\nfloat cos_rot_table_[ROTATION_MAX_UNITS];\nfloat rotation_radians_[ROTATION_MAX_UNITS];\nstd::vector&lt;std::vector&lt;float&gt;&gt; timing_offsets_;\nint phase_;\nint max_pts_;\n};\n\n}  // namespace vlp32\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/vls128__decoder_8hpp/","title":"File vls128_decoder.hpp","text":"<p>FileList &gt; decoders &gt; vls128_decoder.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;array&gt;</code></li> </ul>"},{"location":"nebula_decoders/vls128__decoder_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers namespace vls128"},{"location":"nebula_decoders/vls128__decoder_8hpp/#classes","title":"Classes","text":"Type Name class Vls128Decoder Velodyne LiDAR decoder (VLS128) <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/decoders/vls128_decoder.hpp</code></p>"},{"location":"nebula_decoders/vls128__decoder_8hpp_source/","title":"File vls128_decoder.hpp","text":"<p>File List &gt; decoders &gt; vls128_decoder.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;array&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nnamespace vls128\n{\nclass Vls128Decoder : public VelodyneScanDecoder\n{\npublic:\nexplicit Vls128Decoder(\nconst std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\nvoid unpack(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\nbool hasScanned() override;\nint pointsPerPacket() override;\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; get_pointcloud() override;\nvoid reset_pointcloud(size_t n_pts) override;\nvoid reset_overflow() override;\n\nprivate:\nbool parsePacket(const velodyne_msgs::msg::VelodynePacket &amp; velodyne_packet) override;\nfloat sin_rot_table_[ROTATION_MAX_UNITS];\nfloat cos_rot_table_[ROTATION_MAX_UNITS];\nfloat rotation_radians_[ROTATION_MAX_UNITS];\nfloat vls_128_laser_azimuth_cache_[16];\nint phase_;\nint max_pts_;\nstd::vector&lt;std::vector&lt;float&gt;&gt; timing_offsets_;\n};\n\n}  // namespace vls128\n}  // namespace drivers\n}  // namespace nebula\n</code></pre>"},{"location":"nebula_decoders/velodyne__driver_8hpp/","title":"File velodyne_driver.hpp","text":"<p>FileList &gt; include &gt; nebula_decoders &gt; nebula_decoders_velodyne &gt; velodyne_driver.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/point_types.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;pcl_conversions/pcl_conversions.h&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"nebula_decoders/velodyne__driver_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_decoders/velodyne__driver_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneDriver Velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_decoders/include/nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp</code></p>"},{"location":"nebula_decoders/velodyne__driver_8hpp_source/","title":"File velodyne_driver.hpp","text":"<p>File List &gt; include &gt; nebula_decoders &gt; nebula_decoders_velodyne &gt; velodyne_driver.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_DRIVER_H\n#define NEBULA_VELODYNE_DRIVER_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/point_types.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_common/nebula_driver_base.hpp\"\n#include \"nebula_decoders/nebula_decoders_velodyne/decoders/velodyne_scan_decoder.hpp\"\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;pcl_conversions/pcl_conversions.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass VelodyneDriver : NebulaDriverBase\n{\nprivate:\nStatus driver_status_;\nstd::shared_ptr&lt;drivers::VelodyneScanDecoder&gt; scan_decoder_;\n\npublic:\nVelodyneDriver() = delete;\nVelodyneDriver(\nconst std::shared_ptr&lt;drivers::VelodyneSensorConfiguration&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::VelodyneCalibrationConfiguration&gt; &amp; calibration_configuration);\n\nStatus SetCalibrationConfiguration(\nconst CalibrationConfigurationBase &amp; calibration_configuration) override;\n\nStatus GetStatus();\n\nstd::tuple&lt;drivers::NebulaPointCloudPtr, double&gt; ConvertScanToPointcloud(\nconst std::shared_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; &amp; velodyne_scan);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_DRIVER_H\n</code></pre>"},{"location":"nebula_decoders/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace drivers <ul> <li>namespace pandar_128_e4x </li> <li>namespace pandar_40 </li> <li>namespace pandar_64 </li> <li>namespace pandar_at </li> <li>namespace pandar_qt_128 </li> <li>namespace pandar_qt_64 </li> <li>namespace pandar_xt </li> <li>namespace pandar_xtm </li> <li>namespace vlp16 </li> <li>namespace vlp32 </li> <li>namespace vls128 </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_decoders/classes/","title":"Class Index","text":""},{"location":"nebula_decoders/classes/#b","title":"b","text":"<ul> <li>Block (nebula::drivers::pandar_128_e4x)</li> <li>Block (nebula::drivers::pandar_40)</li> <li>Block (nebula::drivers::pandar_64)</li> <li>Block (nebula::drivers::pandar_at)</li> <li>Block (nebula::drivers::pandar_qt_128)</li> <li>Block (nebula::drivers::pandar_qt_64)</li> <li>Block (nebula::drivers::pandar_xt)</li> <li>Block (nebula::drivers::pandar_xtm)</li> <li>BlockExtended (nebula::drivers::pandar_128_e4x)</li> <li>Body (nebula::drivers::pandar_128_e4x)</li> <li>BodyExtended (nebula::drivers::pandar_128_e4x)</li> </ul>"},{"location":"nebula_decoders/classes/#d","title":"d","text":"<ul> <li>DateTime (nebula::drivers::pandar_128_e4x)</li> </ul>"},{"location":"nebula_decoders/classes/#f","title":"f","text":"<ul> <li>FunctionalSafety (nebula::drivers::pandar_128_e4x)</li> </ul>"},{"location":"nebula_decoders/classes/#h","title":"h","text":"<ul> <li>Header (nebula::drivers::pandar_128_e4x)</li> <li>Header (nebula::drivers::pandar_64)</li> <li>Header (nebula::drivers::pandar_at)</li> <li>Header (nebula::drivers::pandar_qt_128)</li> <li>Header (nebula::drivers::pandar_qt_64)</li> <li>Header (nebula::drivers::pandar_xt)</li> <li>Header (nebula::drivers::pandar_xtm)</li> <li>HesaiDriver (nebula::drivers)</li> <li>HesaiScanDecoder (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#n","title":"n","text":"<ul> <li>NebulaDriverBase (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#p","title":"p","text":"<ul> <li>Packet (nebula::drivers::pandar_128_e4x)</li> <li>Packet (nebula::drivers::pandar_40)</li> <li>Packet (nebula::drivers::pandar_64)</li> <li>Packet (nebula::drivers::pandar_at)</li> <li>Packet (nebula::drivers::pandar_qt_128)</li> <li>Packet (nebula::drivers::pandar_qt_64)</li> <li>Packet (nebula::drivers::pandar_xt)</li> <li>Packet (nebula::drivers::pandar_xtm)</li> <li>PacketExtended (nebula::drivers::pandar_128_e4x)</li> <li>Pandar128E4XDecoder (nebula::drivers::pandar_128_e4x)</li> <li>Pandar40Decoder (nebula::drivers::pandar_40)</li> <li>Pandar64Decoder (nebula::drivers::pandar_64)</li> <li>PandarATDecoder (nebula::drivers::pandar_at)</li> <li>PandarQT128Decoder (nebula::drivers::pandar_qt_128)</li> <li>PandarQT64Decoder (nebula::drivers::pandar_qt_64)</li> <li>PandarXTDecoder (nebula::drivers::pandar_xt)</li> <li>PandarXTMDecoder (nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/classes/#r","title":"r","text":"<ul> <li>raw_block (nebula::drivers)</li> <li>raw_packet (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/classes/#t","title":"t","text":"<ul> <li>Tail (nebula::drivers::pandar_128_e4x)</li> </ul>"},{"location":"nebula_decoders/classes/#u","title":"u","text":"<ul> <li>Unit (nebula::drivers::pandar_40)</li> <li>Unit (nebula::drivers::pandar_64)</li> <li>Unit (nebula::drivers::pandar_at)</li> <li>Unit (nebula::drivers::pandar_qt_128)</li> <li>Unit (nebula::drivers::pandar_qt_64)</li> <li>Unit (nebula::drivers::pandar_xt)</li> <li>Unit (nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/classes/#v","title":"v","text":"<ul> <li>VelodyneDriver (nebula::drivers)</li> <li>VelodyneScanDecoder (nebula::drivers)</li> <li>Vlp16Decoder (nebula::drivers::vlp16)</li> <li>Vlp32Decoder (nebula::drivers::vlp32)</li> <li>Vls128Decoder (nebula::drivers::vls128)</li> </ul>"},{"location":"nebula_decoders/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::drivers::NebulaDriverBase Base class for each sensor driver. <ul> <li>class nebula::drivers::HesaiDriver Hesai driver. </li> <li>class nebula::drivers::VelodyneDriver Velodyne driver. </li> </ul> </li> <li>class nebula::drivers::HesaiScanDecoder Base class for Hesai LiDAR decoder. <ul> <li>class nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder </li> <li>class nebula::drivers::pandar_40::Pandar40Decoder Hesai LiDAR decoder (Pandar40) </li> <li>class nebula::drivers::pandar_64::Pandar64Decoder Hesai LiDAR decoder (Pandar64) </li> <li>class nebula::drivers::pandar_at::PandarATDecoder Hesai LiDAR decoder (AT128) </li> <li>class nebula::drivers::pandar_qt_128::PandarQT128Decoder Hesai LiDAR decoder (QT128) </li> <li>class nebula::drivers::pandar_qt_64::PandarQT64Decoder Hesai LiDAR decoder (QT64) </li> <li>class nebula::drivers::pandar_xt::PandarXTDecoder Hesai LiDAR decoder (XT32) </li> <li>class nebula::drivers::pandar_xtm::PandarXTMDecoder Hesai LiDAR decoder (XT32M) </li> </ul> </li> <li>class nebula::drivers::VelodyneScanDecoder Base class for Velodyne LiDAR decoder. <ul> <li>class nebula::drivers::vlp16::Vlp16Decoder Velodyne LiDAR decoder (VLP16) </li> <li>class nebula::drivers::vlp32::Vlp32Decoder Velodyne LiDAR decoder (VLP32) </li> <li>class nebula::drivers::vls128::Vls128Decoder Velodyne LiDAR decoder (VLS128) </li> </ul> </li> <li>struct nebula::drivers::pandar_128_e4x::Block </li> <li>struct nebula::drivers::pandar_128_e4x::BlockExtended </li> <li>struct nebula::drivers::pandar_128_e4x::Body </li> <li>struct nebula::drivers::pandar_128_e4x::BodyExtended </li> <li>struct nebula::drivers::pandar_128_e4x::DateTime </li> <li>struct nebula::drivers::pandar_128_e4x::FunctionalSafety </li> <li>struct nebula::drivers::pandar_128_e4x::Header </li> <li>struct nebula::drivers::pandar_128_e4x::Packet </li> <li>struct nebula::drivers::pandar_128_e4x::PacketExtended </li> <li>struct nebula::drivers::pandar_128_e4x::Tail </li> <li>struct nebula::drivers::pandar_40::Block </li> <li>struct nebula::drivers::pandar_40::Packet </li> <li>struct nebula::drivers::pandar_40::Unit </li> <li>struct nebula::drivers::pandar_64::Block </li> <li>struct nebula::drivers::pandar_64::Header </li> <li>struct nebula::drivers::pandar_64::Packet </li> <li>struct nebula::drivers::pandar_64::Unit </li> <li>struct nebula::drivers::pandar_at::Block </li> <li>struct nebula::drivers::pandar_at::Header </li> <li>struct nebula::drivers::pandar_at::Packet </li> <li>struct nebula::drivers::pandar_at::Unit </li> <li>struct nebula::drivers::pandar_qt_128::Block </li> <li>struct nebula::drivers::pandar_qt_128::Header </li> <li>struct nebula::drivers::pandar_qt_128::Packet </li> <li>struct nebula::drivers::pandar_qt_128::Unit </li> <li>struct nebula::drivers::pandar_qt_64::Block </li> <li>struct nebula::drivers::pandar_qt_64::Header </li> <li>struct nebula::drivers::pandar_qt_64::Packet </li> <li>struct nebula::drivers::pandar_qt_64::Unit </li> <li>struct nebula::drivers::pandar_xt::Block </li> <li>struct nebula::drivers::pandar_xt::Header </li> <li>struct nebula::drivers::pandar_xt::Packet </li> <li>struct nebula::drivers::pandar_xt::Unit </li> <li>struct nebula::drivers::pandar_xtm::Block </li> <li>struct nebula::drivers::pandar_xtm::Header </li> <li>struct nebula::drivers::pandar_xtm::Packet </li> <li>struct nebula::drivers::pandar_xtm::Unit </li> <li>struct nebula::drivers::raw_block Raw Velodyne data block. </li> <li>struct nebula::drivers::raw_packet Raw Velodyne packet. </li> </ul>"},{"location":"nebula_decoders/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_decoders/todo/","title":"Todo","text":"<p>Todo List</p>"},{"location":"nebula_decoders/todo/#member-nebuladriversraw_packet_t","title":"Member nebula::drivers::raw_packet_t","text":"<p>figure out if revolution is only present for one of the two types of status fields</p>"},{"location":"nebula_decoders/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p> <ul> <li>Todo List </li> </ul>"},{"location":"nebula_decoders/class_members/","title":"Class Members","text":""},{"location":"nebula_decoders/class_members/#a","title":"a","text":"<ul> <li>azimuth_1 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>azimuth_2 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>azimuth_offset_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>azimuth_offset_rad_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>azimuth_state (nebula::drivers::pandar_128_e4x::Tail)</li> <li>azimuth (nebula::drivers::pandar_40::Block, nebula::drivers::pandar_64::Block, nebula::drivers::pandar_at::Block, nebula::drivers::pandar_qt_128::Block, nebula::drivers::pandar_qt_64::Block, nebula::drivers::pandar_xt::Block, nebula::drivers::pandar_xtm::Block)</li> </ul>"},{"location":"nebula_decoders/class_members/#b","title":"b","text":"<ul> <li>block_01 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>block_02 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>BlockNum (nebula::drivers::pandar_128_e4x::Header)</li> <li>body (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended)</li> <li>block_azimuth_rad_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>build_point (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>blocks (nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet, nebula::drivers::raw_packet)</li> <li>block_time_offset_dual_return_ (nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>block_time_offset_single_return_ (nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>block_time_offset_dual_ (nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> <li>block_time_offset_single_ (nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> <li>block_offset_dual_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>block_offset_single_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>block_offset_triple_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>block_offset_dual_return_ (nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>block_time_offset_triple_return_ (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#c","title":"c","text":"<ul> <li>ConvertScanToPointcloud (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>convert (nebula::drivers::HesaiScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>convert_dual (nebula::drivers::HesaiScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>calibration_configuration_ (nebula::drivers::VelodyneScanDecoder)</li> <li>crc_1 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>cos_elevation_angle_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>current_unit_unix_second_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder)</li> <li>crc_32 (nebula::drivers::pandar_128_e4x::Tail)</li> <li>chBlockNumber (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chDisUnit (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chLaserNumber (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chReturnType (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chProtocolMajor (nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chProtocolMinor (nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>CalcXTPointXYZIT (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>correction_configuration_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>confidence (nebula::drivers::pandar_at::Unit, nebula::drivers::pandar_qt_128::Unit, nebula::drivers::pandar_qt_64::Unit, nebula::drivers::pandar_xt::Unit, nebula::drivers::pandar_xtm::Unit)</li> <li>chFlags (nebula::drivers::pandar_qt_128::Header)</li> <li>cos_azimuth_angle_ (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>cos_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#d","title":"d","text":"<ul> <li>driver_status_ (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>dual_return_distance_threshold_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>distance (nebula::drivers::pandar_128_e4x::Block, nebula::drivers::pandar_128_e4x::BlockExtended, nebula::drivers::pandar_40::Unit, nebula::drivers::pandar_64::Unit, nebula::drivers::pandar_at::Unit, nebula::drivers::pandar_qt_128::Unit, nebula::drivers::pandar_qt_64::Unit, nebula::drivers::pandar_xt::Unit, nebula::drivers::pandar_xtm::Unit)</li> <li>day (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>DistanceUnitMm (nebula::drivers::pandar_128_e4x::Header)</li> <li>date_time (nebula::drivers::pandar_128_e4x::Tail)</li> <li>data (nebula::drivers::raw_block)</li> </ul>"},{"location":"nebula_decoders/class_members/#e","title":"e","text":"<ul> <li>elevation_angle_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>elevation_angle_rad_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>elev_angle_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>elev_angle_rad_ (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#f","title":"f","text":"<ul> <li>FirstBlockReturn (nebula::drivers::pandar_128_e4x::Header)</li> <li>Flags (nebula::drivers::pandar_128_e4x::Header)</li> <li>functional_safety (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended)</li> <li>first_return_type_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>factory_info (nebula::drivers::pandar_128_e4x::Tail)</li> <li>firing_time_offset_ (nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>fine_azimuth (nebula::drivers::pandar_at::Block)</li> <li>firing_time_offset1_ (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>firing_time_offset2_ (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>firing_offset_ (nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#g","title":"g","text":"<ul> <li>GetStatus (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>get_pointcloud (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>get_epoch_from_datetime (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#h","title":"h","text":"<ul> <li>HesaiDriver (nebula::drivers::HesaiDriver)</li> <li>HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>hasScanned (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>has_scanned_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>hour (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>header (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet, nebula::drivers::raw_block)</li> </ul>"},{"location":"nebula_decoders/class_members/#i","title":"i","text":"<ul> <li>is_dual_return (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>intensity (nebula::drivers::pandar_40::Unit, nebula::drivers::pandar_64::Unit, nebula::drivers::pandar_at::Unit, nebula::drivers::pandar_qt_128::Unit, nebula::drivers::pandar_qt_64::Unit, nebula::drivers::pandar_xt::Unit, nebula::drivers::pandar_xtm::Unit)</li> </ul>"},{"location":"nebula_decoders/class_members/#l","title":"l","text":"<ul> <li>last_phase_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>LaserNum (nebula::drivers::pandar_128_e4x::Header)</li> <li>last_azimuth_ (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>last_field_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>last_timestamp_ (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#m","title":"m","text":"<ul> <li>minute (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>month (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>motor_speed_rpm (nebula::drivers::pandar_128_e4x::Tail)</li> <li>motor_speed (nebula::drivers::pandar_at::Packet)</li> <li>m_cos_map_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>m_sin_map_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>max_azimuth_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>mode_flag (nebula::drivers::pandar_qt_128::Packet)</li> <li>max_pts_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#n","title":"n","text":"<ul> <li>NebulaDriverBase (nebula::drivers::NebulaDriverBase)</li> </ul>"},{"location":"nebula_decoders/class_members/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::HesaiScanDecoder, nebula::drivers::NebulaDriverBase, nebula::drivers::VelodyneScanDecoder)</li> <li>overflow_pc_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>operational_state (nebula::drivers::pandar_128_e4x::Tail)</li> </ul>"},{"location":"nebula_decoders/class_members/#p","title":"p","text":"<ul> <li>parsePacket (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>pointsPerPacket (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>ProtocolMajor (nebula::drivers::pandar_128_e4x::Header)</li> <li>ProtocolMinor (nebula::drivers::pandar_128_e4x::Header)</li> <li>Pandar128E4XDecoder (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder)</li> <li>packet_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>Pandar40Decoder (nebula::drivers::pandar_40::Pandar40Decoder)</li> <li>Pandar64Decoder (nebula::drivers::pandar_64::Pandar64Decoder)</li> <li>PandarATDecoder (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>PandarQT128Decoder (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>PandarQT64Decoder (nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> <li>PandarXTDecoder (nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>PandarXTMDecoder (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>phase_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#r","title":"r","text":"<ul> <li>reset_overflow (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>reset_pointcloud (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>reflectivity (nebula::drivers::pandar_128_e4x::Block, nebula::drivers::pandar_128_e4x::BlockExtended)</li> <li>reserved (nebula::drivers::pandar_128_e4x::BlockExtended, nebula::drivers::pandar_128_e4x::FunctionalSafety)</li> <li>Reserved (nebula::drivers::pandar_128_e4x::Header)</li> <li>ReturnNum (nebula::drivers::pandar_128_e4x::Header)</li> <li>reserved_01 (nebula::drivers::pandar_128_e4x::Tail)</li> <li>reserved_02 (nebula::drivers::pandar_128_e4x::Tail)</li> <li>return_mode (nebula::drivers::pandar_128_e4x::Tail, nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet)</li> <li>rotation (nebula::drivers::raw_block)</li> <li>revolution (nebula::drivers::raw_packet)</li> <li>rotation_radians_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#s","title":"s","text":"<ul> <li>SetCalibrationConfiguration (nebula::drivers::HesaiDriver, nebula::drivers::NebulaDriverBase, nebula::drivers::VelodyneDriver)</li> <li>scan_decoder_ (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>scan_pc_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>scan_phase_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>scan_timestamp_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>sensor_calibration_ (nebula::drivers::HesaiScanDecoder)</li> <li>sensor_configuration_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>second (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>SOP (nebula::drivers::pandar_128_e4x::Header)</li> <li>second_return_type_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>sin_elevation_angle_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>sob (nebula::drivers::pandar_40::Block, nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>shutdown_flg (nebula::drivers::pandar_at::Packet)</li> <li>start_angle_ (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>sin_azimuth_angle_ (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>status (nebula::drivers::raw_packet)</li> <li>sin_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#t","title":"t","text":"<ul> <li>tail (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended)</li> <li>timestamp_us (nebula::drivers::pandar_128_e4x::Tail)</li> <li>t (nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet)</li> <li>timing_offsets_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#u","title":"u","text":"<ul> <li>unpack (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>udp_sequence (nebula::drivers::pandar_128_e4x::Tail)</li> <li>units (nebula::drivers::pandar_40::Block, nebula::drivers::pandar_64::Block, nebula::drivers::pandar_at::Block, nebula::drivers::pandar_qt_128::Block, nebula::drivers::pandar_qt_64::Block, nebula::drivers::pandar_xt::Block, nebula::drivers::pandar_xtm::Block)</li> <li>usec (nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet)</li> <li>unix_second (nebula::drivers::pandar_at::Packet)</li> <li>use_dat (nebula::drivers::pandar_at::PandarATDecoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#v","title":"v","text":"<ul> <li>VelodyneDriver (nebula::drivers::VelodyneDriver)</li> <li>VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> <li>vertical_laser_firing_order_ (nebula::drivers::pandar_40::Pandar40Decoder)</li> <li>Vlp16Decoder (nebula::drivers::vlp16::Vlp16Decoder)</li> <li>Vlp32Decoder (nebula::drivers::vlp32::Vlp32Decoder)</li> <li>Vls128Decoder (nebula::drivers::vls128::Vls128Decoder)</li> <li>vls_128_laser_azimuth_cache_ (nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_members/#y","title":"y","text":"<ul> <li>year (nebula::drivers::pandar_128_e4x::DateTime)</li> </ul>"},{"location":"nebula_decoders/class_members/#_1","title":"~","text":"<ul> <li>~HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>~VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_decoders/class_member_functions/#b","title":"b","text":"<ul> <li>build_point (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#c","title":"c","text":"<ul> <li>ConvertScanToPointcloud (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>convert (nebula::drivers::HesaiScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>convert_dual (nebula::drivers::HesaiScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>CalcXTPointXYZIT (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#g","title":"g","text":"<ul> <li>GetStatus (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>get_pointcloud (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>get_epoch_from_datetime (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiDriver (nebula::drivers::HesaiDriver)</li> <li>HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>hasScanned (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#i","title":"i","text":"<ul> <li>is_dual_return (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#n","title":"n","text":"<ul> <li>NebulaDriverBase (nebula::drivers::NebulaDriverBase)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::HesaiScanDecoder, nebula::drivers::NebulaDriverBase, nebula::drivers::VelodyneScanDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#p","title":"p","text":"<ul> <li>parsePacket (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>pointsPerPacket (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>Pandar128E4XDecoder (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder)</li> <li>Pandar40Decoder (nebula::drivers::pandar_40::Pandar40Decoder)</li> <li>Pandar64Decoder (nebula::drivers::pandar_64::Pandar64Decoder)</li> <li>PandarATDecoder (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>PandarQT128Decoder (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>PandarQT64Decoder (nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> <li>PandarXTDecoder (nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>PandarXTMDecoder (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#r","title":"r","text":"<ul> <li>reset_overflow (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> <li>reset_pointcloud (nebula::drivers::VelodyneScanDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#s","title":"s","text":"<ul> <li>SetCalibrationConfiguration (nebula::drivers::HesaiDriver, nebula::drivers::NebulaDriverBase, nebula::drivers::VelodyneDriver)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#u","title":"u","text":"<ul> <li>unpack (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder, nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder, nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneDriver (nebula::drivers::VelodyneDriver)</li> <li>VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> <li>Vlp16Decoder (nebula::drivers::vlp16::Vlp16Decoder)</li> <li>Vlp32Decoder (nebula::drivers::vlp32::Vlp32Decoder)</li> <li>Vls128Decoder (nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_functions/#_1","title":"~","text":"<ul> <li>~HesaiScanDecoder (nebula::drivers::HesaiScanDecoder)</li> <li>~VelodyneScanDecoder (nebula::drivers::VelodyneScanDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_decoders/class_member_variables/#a","title":"a","text":"<ul> <li>azimuth_1 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>azimuth_2 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>azimuth_offset_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>azimuth_offset_rad_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>azimuth_state (nebula::drivers::pandar_128_e4x::Tail)</li> <li>azimuth (nebula::drivers::pandar_40::Block, nebula::drivers::pandar_64::Block, nebula::drivers::pandar_at::Block, nebula::drivers::pandar_qt_128::Block, nebula::drivers::pandar_qt_64::Block, nebula::drivers::pandar_xt::Block, nebula::drivers::pandar_xtm::Block)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#b","title":"b","text":"<ul> <li>block_01 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>block_02 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>BlockNum (nebula::drivers::pandar_128_e4x::Header)</li> <li>body (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended)</li> <li>block_azimuth_rad_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>blocks (nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet, nebula::drivers::raw_packet)</li> <li>block_time_offset_dual_return_ (nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>block_time_offset_single_return_ (nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>block_time_offset_dual_ (nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> <li>block_time_offset_single_ (nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> <li>block_offset_dual_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>block_offset_single_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>block_offset_triple_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>block_offset_dual_return_ (nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>block_time_offset_triple_return_ (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#c","title":"c","text":"<ul> <li>calibration_configuration_ (nebula::drivers::VelodyneScanDecoder)</li> <li>crc_1 (nebula::drivers::pandar_128_e4x::Body, nebula::drivers::pandar_128_e4x::BodyExtended)</li> <li>cos_elevation_angle_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>current_unit_unix_second_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder)</li> <li>crc_32 (nebula::drivers::pandar_128_e4x::Tail)</li> <li>chBlockNumber (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chDisUnit (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chLaserNumber (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chReturnType (nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chProtocolMajor (nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>chProtocolMinor (nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>correction_configuration_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>confidence (nebula::drivers::pandar_at::Unit, nebula::drivers::pandar_qt_128::Unit, nebula::drivers::pandar_qt_64::Unit, nebula::drivers::pandar_xt::Unit, nebula::drivers::pandar_xtm::Unit)</li> <li>chFlags (nebula::drivers::pandar_qt_128::Header)</li> <li>cos_azimuth_angle_ (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>cos_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#d","title":"d","text":"<ul> <li>driver_status_ (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>dual_return_distance_threshold_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>distance (nebula::drivers::pandar_128_e4x::Block, nebula::drivers::pandar_128_e4x::BlockExtended, nebula::drivers::pandar_40::Unit, nebula::drivers::pandar_64::Unit, nebula::drivers::pandar_at::Unit, nebula::drivers::pandar_qt_128::Unit, nebula::drivers::pandar_qt_64::Unit, nebula::drivers::pandar_xt::Unit, nebula::drivers::pandar_xtm::Unit)</li> <li>day (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>DistanceUnitMm (nebula::drivers::pandar_128_e4x::Header)</li> <li>date_time (nebula::drivers::pandar_128_e4x::Tail)</li> <li>data (nebula::drivers::raw_block)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#e","title":"e","text":"<ul> <li>elevation_angle_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>elevation_angle_rad_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>elev_angle_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>elev_angle_rad_ (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#f","title":"f","text":"<ul> <li>FirstBlockReturn (nebula::drivers::pandar_128_e4x::Header)</li> <li>Flags (nebula::drivers::pandar_128_e4x::Header)</li> <li>functional_safety (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended)</li> <li>first_return_type_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>factory_info (nebula::drivers::pandar_128_e4x::Tail)</li> <li>firing_time_offset_ (nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder)</li> <li>fine_azimuth (nebula::drivers::pandar_at::Block)</li> <li>firing_time_offset1_ (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>firing_time_offset2_ (nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>firing_offset_ (nebula::drivers::pandar_qt_64::PandarQT64Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#h","title":"h","text":"<ul> <li>has_scanned_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>hour (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>header (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet, nebula::drivers::raw_block)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#i","title":"i","text":"<ul> <li>intensity (nebula::drivers::pandar_40::Unit, nebula::drivers::pandar_64::Unit, nebula::drivers::pandar_at::Unit, nebula::drivers::pandar_qt_128::Unit, nebula::drivers::pandar_qt_64::Unit, nebula::drivers::pandar_xt::Unit, nebula::drivers::pandar_xtm::Unit)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#l","title":"l","text":"<ul> <li>last_phase_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>LaserNum (nebula::drivers::pandar_128_e4x::Header)</li> <li>last_azimuth_ (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>last_field_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>last_timestamp_ (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#m","title":"m","text":"<ul> <li>minute (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>month (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>motor_speed_rpm (nebula::drivers::pandar_128_e4x::Tail)</li> <li>motor_speed (nebula::drivers::pandar_at::Packet)</li> <li>m_cos_map_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>m_sin_map_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>max_azimuth_ (nebula::drivers::pandar_at::PandarATDecoder)</li> <li>mode_flag (nebula::drivers::pandar_qt_128::Packet)</li> <li>max_pts_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#o","title":"o","text":"<ul> <li>overflow_pc_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>operational_state (nebula::drivers::pandar_128_e4x::Tail)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#p","title":"p","text":"<ul> <li>ProtocolMajor (nebula::drivers::pandar_128_e4x::Header)</li> <li>ProtocolMinor (nebula::drivers::pandar_128_e4x::Header)</li> <li>packet_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xt::PandarXTDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>phase_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#r","title":"r","text":"<ul> <li>reflectivity (nebula::drivers::pandar_128_e4x::Block, nebula::drivers::pandar_128_e4x::BlockExtended)</li> <li>reserved (nebula::drivers::pandar_128_e4x::BlockExtended, nebula::drivers::pandar_128_e4x::FunctionalSafety)</li> <li>Reserved (nebula::drivers::pandar_128_e4x::Header)</li> <li>ReturnNum (nebula::drivers::pandar_128_e4x::Header)</li> <li>reserved_01 (nebula::drivers::pandar_128_e4x::Tail)</li> <li>reserved_02 (nebula::drivers::pandar_128_e4x::Tail)</li> <li>return_mode (nebula::drivers::pandar_128_e4x::Tail, nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet)</li> <li>rotation (nebula::drivers::raw_block)</li> <li>revolution (nebula::drivers::raw_packet)</li> <li>rotation_radians_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#s","title":"s","text":"<ul> <li>scan_decoder_ (nebula::drivers::HesaiDriver, nebula::drivers::VelodyneDriver)</li> <li>scan_pc_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>scan_phase_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>scan_timestamp_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>sensor_calibration_ (nebula::drivers::HesaiScanDecoder)</li> <li>sensor_configuration_ (nebula::drivers::HesaiScanDecoder, nebula::drivers::VelodyneScanDecoder)</li> <li>second (nebula::drivers::pandar_128_e4x::DateTime)</li> <li>SOP (nebula::drivers::pandar_128_e4x::Header)</li> <li>second_return_type_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder)</li> <li>sin_elevation_angle_ (nebula::drivers::pandar_128_e4x::Pandar128E4XDecoder, nebula::drivers::pandar_40::Pandar40Decoder, nebula::drivers::pandar_64::Pandar64Decoder, nebula::drivers::pandar_qt_128::PandarQT128Decoder, nebula::drivers::pandar_qt_64::PandarQT64Decoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>sob (nebula::drivers::pandar_40::Block, nebula::drivers::pandar_64::Header, nebula::drivers::pandar_at::Header, nebula::drivers::pandar_qt_128::Header, nebula::drivers::pandar_qt_64::Header, nebula::drivers::pandar_xt::Header, nebula::drivers::pandar_xtm::Header)</li> <li>shutdown_flg (nebula::drivers::pandar_at::Packet)</li> <li>start_angle_ (nebula::drivers::pandar_at::PandarATDecoder, nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>sin_azimuth_angle_ (nebula::drivers::pandar_xtm::PandarXTMDecoder)</li> <li>status (nebula::drivers::raw_packet)</li> <li>sin_rot_table_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#t","title":"t","text":"<ul> <li>tail (nebula::drivers::pandar_128_e4x::Packet, nebula::drivers::pandar_128_e4x::PacketExtended)</li> <li>timestamp_us (nebula::drivers::pandar_128_e4x::Tail)</li> <li>t (nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet)</li> <li>timing_offsets_ (nebula::drivers::vlp16::Vlp16Decoder, nebula::drivers::vlp32::Vlp32Decoder, nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#u","title":"u","text":"<ul> <li>udp_sequence (nebula::drivers::pandar_128_e4x::Tail)</li> <li>units (nebula::drivers::pandar_40::Block, nebula::drivers::pandar_64::Block, nebula::drivers::pandar_at::Block, nebula::drivers::pandar_qt_128::Block, nebula::drivers::pandar_qt_64::Block, nebula::drivers::pandar_xt::Block, nebula::drivers::pandar_xtm::Block)</li> <li>usec (nebula::drivers::pandar_40::Packet, nebula::drivers::pandar_64::Packet, nebula::drivers::pandar_at::Packet, nebula::drivers::pandar_qt_128::Packet, nebula::drivers::pandar_qt_64::Packet, nebula::drivers::pandar_xt::Packet, nebula::drivers::pandar_xtm::Packet)</li> <li>unix_second (nebula::drivers::pandar_at::Packet)</li> <li>use_dat (nebula::drivers::pandar_at::PandarATDecoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#v","title":"v","text":"<ul> <li>vertical_laser_firing_order_ (nebula::drivers::pandar_40::Pandar40Decoder)</li> <li>vls_128_laser_azimuth_cache_ (nebula::drivers::vls128::Vls128Decoder)</li> </ul>"},{"location":"nebula_decoders/class_member_variables/#y","title":"y","text":"<ul> <li>year (nebula::drivers::pandar_128_e4x::DateTime)</li> </ul>"},{"location":"nebula_decoders/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_decoders/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"nebula_decoders/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_decoders/namespace_members/#b","title":"b","text":"<ul> <li>BLOCKS_PER_PACKET (nebula::drivers, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>BLOCK_DATA_SIZE (nebula::drivers)</li> <li>BODY_SIZE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>BLOCK_SIZE (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>BLOCK_HEADER_AZIMUTH (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>blockXTMOffsetDual (nebula::drivers::pandar_xtm)</li> <li>blockXTMOffsetSingle (nebula::drivers::pandar_xtm)</li> <li>blockXTMOffsetTriple (nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#c","title":"c","text":"<ul> <li>CRC_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128)</li> <li>channel_firing_ns (nebula::drivers::pandar_at)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#d","title":"d","text":"<ul> <li>DISTANCE_UNIT (nebula::drivers::pandar_128_e4x)</li> <li>DUAL_FIRST_STRONGEST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>DUAL_LAST_FIRST_RETURN (nebula::drivers::pandar_128_e4x)</li> <li>DUAL_LAST_STRONGEST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>DUAL_RETURN (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>DUAL_RETURN_B (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xtm)</li> <li>DUAL_RETURN_C (nebula::drivers::pandar_at, nebula::drivers::pandar_xtm)</li> <li>DUAL_FIRST_LAST_RETURN (nebula::drivers::pandar_qt_128)</li> <li>DUAL_FIRST_SECOND_RETURN (nebula::drivers::pandar_qt_128)</li> <li>DUAL_STRONGEST_2ndSTRONGEST_RETURN (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#e","title":"e","text":"<ul> <li>ENGINE_VELOCITY (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#f","title":"f","text":"<ul> <li>FUNCTIONAL_SAFETY_SIZE (nebula::drivers::pandar_128_e4x)</li> <li>FACTORY_INFO_SIZE (nebula::drivers::pandar_40)</li> <li>FACTORY_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>FIRST_RETURN (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#h","title":"h","text":"<ul> <li>HEADER_SIZE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>HIGH_RES_STATE (nebula::drivers::pandar_128_e4x)</li> <li>HEAD_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>HIGH_TEMPERATURE (nebula::drivers::pandar_64)</li> <li>HIGH_TEMP_SHUTDOWN_FLAG_SIZE (nebula::drivers::pandar_at)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#i","title":"i","text":"<ul> <li>INFO_SIZE (nebula::drivers::pandar_40)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#l","title":"l","text":"<ul> <li>LOWER_BANK (nebula::drivers)</li> <li>LASER_COUNT (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>LASER_RETURN_TO_DISTANCE_RATE (nebula::drivers::pandar_40)</li> <li>LAST_RETURN (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>LIDAR_AZIMUTH_UNIT (nebula::drivers::pandar_at)</li> <li>laserXTMOffset (nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#m","title":"m","text":"<ul> <li>MAX_AZIMUTH_STEPS (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>MAX_RANGE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>MIN_RANGE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>MAX_AZIMUTH_DEGREE_NUM (nebula::drivers::pandar_at, nebula::drivers::pandar_xtm)</li> <li>MAX_AZI_LEN (nebula::drivers::pandar_at)</li> <li>MAX_RETURN_COUNT (nebula::drivers::pandar_at)</li> <li>MOTOR_SPEED_SIZE (nebula::drivers::pandar_at)</li> <li>MODE_FLAG_SIZE (nebula::drivers::pandar_qt_128)</li> <li>MAX_POINTS (nebula::drivers::vlp16)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#n","title":"n","text":"<ul> <li>NUM_BLOCKS (nebula::drivers::pandar_128_e4x)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#p","title":"p","text":"<ul> <li>PACKET_SIZE (nebula::drivers, nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>PACKET_STATUS_SIZE (nebula::drivers)</li> <li>PACKET_TAIL_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64)</li> <li>PACKET_WITHOUT_UDP_SEQ_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64)</li> <li>PRE_HEADER_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>PACKET_FS_SIZE (nebula::drivers::pandar_qt_128)</li> <li>PACKET_TAIL_TIMESTAMP_OFFSET (nebula::drivers::pandar_qt_128)</li> <li>PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE (nebula::drivers::pandar_qt_128)</li> <li>PACKET_WITHOUT_UDP_SEQ_CRC_SIZE (nebula::drivers::pandar_qt_128)</li> <li>PandarQT128_TL1 (nebula::drivers::pandar_qt_128)</li> <li>PandarQT128_TL2 (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#r","title":"r","text":"<ul> <li>RAW_SCAN_SIZE (nebula::drivers)</li> <li>RETURN_MODE_DUAL (nebula::drivers)</li> <li>RETURN_MODE_INDEX (nebula::drivers)</li> <li>RETURN_MODE_LAST (nebula::drivers)</li> <li>RETURN_MODE_STRONGEST (nebula::drivers)</li> <li>RETURN_TYPE (nebula::drivers)</li> <li>ROTATION_MAX_UNITS (nebula::drivers)</li> <li>ROTATION_RESOLUTION (nebula::drivers)</li> <li>RAW_MEASURE_SIZE (nebula::drivers::pandar_40)</li> <li>RESERVE_SIZE (nebula::drivers::pandar_40)</li> <li>RETURN_SIZE (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>REVOLUTION_SIZE (nebula::drivers::pandar_40)</li> <li>RESERVED_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>RESERVED1_SIZE (nebula::drivers::pandar_at)</li> <li>RESERVED2_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128)</li> <li>RESERVED3_SIZE (nebula::drivers::pandar_qt_128)</li> <li>raw_block_t (nebula::drivers)</li> <li>raw_packet_t (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#s","title":"s","text":"<ul> <li>SCANS_PER_BLOCK (nebula::drivers)</li> <li>SCANS_PER_PACKET (nebula::drivers)</li> <li>SIZE_BLOCK (nebula::drivers)</li> <li>SINGLE_FIRST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>SINGLE_LAST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>SINGLE_STRONGEST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>STANDARD_RES_STATE (nebula::drivers::pandar_128_e4x)</li> <li>SEQ_NUM_SIZE (nebula::drivers::pandar_40)</li> <li>SOB_ANGLE_SIZE (nebula::drivers::pandar_40)</li> <li>STRONGEST_RETURN (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>SCAN_POINTS_NUM (nebula::drivers::pandar_at)</li> <li>SEQUENCE_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>SIGNATURE_SIZE (nebula::drivers::pandar_qt_128)</li> <li>SINGLE_SECOND_RETURN (nebula::drivers::pandar_qt_128)</li> <li>SKIP_SIZE (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#t","title":"t","text":"<ul> <li>TAIL_SIZE (nebula::drivers::pandar_128_e4x)</li> <li>THREE_SIXTY (nebula::drivers::pandar_128_e4x)</li> <li>TIMESTAMP_SIZE (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>TRIPLE_RETURN (nebula::drivers::pandar_at, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#u","title":"u","text":"<ul> <li>UPPER_BANK (nebula::drivers)</li> <li>UNUSED_INT (nebula::drivers::pandar_128_e4x)</li> <li>UTC_TIME (nebula::drivers::pandar_40)</li> <li>UNIT_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>UTC_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_members/#v","title":"v","text":"<ul> <li>VLP128_DISTANCE_RESOLUTION (nebula::drivers)</li> <li>VLP16_BLOCK_DURATION (nebula::drivers)</li> <li>VLP16_DSR_TOFFSET (nebula::drivers)</li> <li>VLP16_FIRINGS_PER_BLOCK (nebula::drivers)</li> <li>VLP16_FIRING_TOFFSET (nebula::drivers)</li> <li>VLP16_SCANS_PER_FIRING (nebula::drivers)</li> <li>VLS128_BANK_1 (nebula::drivers)</li> <li>VLS128_BANK_2 (nebula::drivers)</li> <li>VLS128_BANK_3 (nebula::drivers)</li> <li>VLS128_BANK_4 (nebula::drivers)</li> <li>VLS128_CHANNEL_DURATION (nebula::drivers)</li> <li>VLS128_SEQ_DURATION (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"nebula_decoders/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"nebula_decoders/namespace_member_variables/#b","title":"b","text":"<ul> <li>BLOCKS_PER_PACKET (nebula::drivers, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>BLOCK_DATA_SIZE (nebula::drivers)</li> <li>BODY_SIZE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>BLOCK_SIZE (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>BLOCK_HEADER_AZIMUTH (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>blockXTMOffsetDual (nebula::drivers::pandar_xtm)</li> <li>blockXTMOffsetSingle (nebula::drivers::pandar_xtm)</li> <li>blockXTMOffsetTriple (nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#c","title":"c","text":"<ul> <li>CRC_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128)</li> <li>channel_firing_ns (nebula::drivers::pandar_at)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#d","title":"d","text":"<ul> <li>DISTANCE_UNIT (nebula::drivers::pandar_128_e4x)</li> <li>DUAL_FIRST_STRONGEST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>DUAL_LAST_FIRST_RETURN (nebula::drivers::pandar_128_e4x)</li> <li>DUAL_LAST_STRONGEST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>DUAL_RETURN (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>DUAL_RETURN_B (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xtm)</li> <li>DUAL_RETURN_C (nebula::drivers::pandar_at, nebula::drivers::pandar_xtm)</li> <li>DUAL_FIRST_LAST_RETURN (nebula::drivers::pandar_qt_128)</li> <li>DUAL_FIRST_SECOND_RETURN (nebula::drivers::pandar_qt_128)</li> <li>DUAL_STRONGEST_2ndSTRONGEST_RETURN (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#e","title":"e","text":"<ul> <li>ENGINE_VELOCITY (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#f","title":"f","text":"<ul> <li>FUNCTIONAL_SAFETY_SIZE (nebula::drivers::pandar_128_e4x)</li> <li>FACTORY_INFO_SIZE (nebula::drivers::pandar_40)</li> <li>FACTORY_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>FIRST_RETURN (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#h","title":"h","text":"<ul> <li>HEADER_SIZE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>HIGH_RES_STATE (nebula::drivers::pandar_128_e4x)</li> <li>HEAD_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>HIGH_TEMPERATURE (nebula::drivers::pandar_64)</li> <li>HIGH_TEMP_SHUTDOWN_FLAG_SIZE (nebula::drivers::pandar_at)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#i","title":"i","text":"<ul> <li>INFO_SIZE (nebula::drivers::pandar_40)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#l","title":"l","text":"<ul> <li>LOWER_BANK (nebula::drivers)</li> <li>LASER_COUNT (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>LASER_RETURN_TO_DISTANCE_RATE (nebula::drivers::pandar_40)</li> <li>LAST_RETURN (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>LIDAR_AZIMUTH_UNIT (nebula::drivers::pandar_at)</li> <li>laserXTMOffset (nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_AZIMUTH_STEPS (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>MAX_RANGE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>MIN_RANGE (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>MAX_AZIMUTH_DEGREE_NUM (nebula::drivers::pandar_at, nebula::drivers::pandar_xtm)</li> <li>MAX_AZI_LEN (nebula::drivers::pandar_at)</li> <li>MAX_RETURN_COUNT (nebula::drivers::pandar_at)</li> <li>MOTOR_SPEED_SIZE (nebula::drivers::pandar_at)</li> <li>MODE_FLAG_SIZE (nebula::drivers::pandar_qt_128)</li> <li>MAX_POINTS (nebula::drivers::vlp16)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#n","title":"n","text":"<ul> <li>NUM_BLOCKS (nebula::drivers::pandar_128_e4x)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#p","title":"p","text":"<ul> <li>PACKET_SIZE (nebula::drivers, nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>PACKET_STATUS_SIZE (nebula::drivers)</li> <li>PACKET_TAIL_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>PACKET_TAIL_WITHOUT_UDP_SEQ_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64)</li> <li>PACKET_WITHOUT_UDP_SEQ_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64)</li> <li>PRE_HEADER_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>PACKET_FS_SIZE (nebula::drivers::pandar_qt_128)</li> <li>PACKET_TAIL_TIMESTAMP_OFFSET (nebula::drivers::pandar_qt_128)</li> <li>PACKET_TAIL_WITHOUT_UDP_SEQ_CRC_SIZE (nebula::drivers::pandar_qt_128)</li> <li>PACKET_WITHOUT_UDP_SEQ_CRC_SIZE (nebula::drivers::pandar_qt_128)</li> <li>PandarQT128_TL1 (nebula::drivers::pandar_qt_128)</li> <li>PandarQT128_TL2 (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#r","title":"r","text":"<ul> <li>RAW_SCAN_SIZE (nebula::drivers)</li> <li>RETURN_MODE_DUAL (nebula::drivers)</li> <li>RETURN_MODE_INDEX (nebula::drivers)</li> <li>RETURN_MODE_LAST (nebula::drivers)</li> <li>RETURN_MODE_STRONGEST (nebula::drivers)</li> <li>ROTATION_MAX_UNITS (nebula::drivers)</li> <li>ROTATION_RESOLUTION (nebula::drivers)</li> <li>RAW_MEASURE_SIZE (nebula::drivers::pandar_40)</li> <li>RESERVE_SIZE (nebula::drivers::pandar_40)</li> <li>RETURN_SIZE (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>REVOLUTION_SIZE (nebula::drivers::pandar_40)</li> <li>RESERVED_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>RESERVED1_SIZE (nebula::drivers::pandar_at)</li> <li>RESERVED2_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128)</li> <li>RESERVED3_SIZE (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#s","title":"s","text":"<ul> <li>SCANS_PER_BLOCK (nebula::drivers)</li> <li>SCANS_PER_PACKET (nebula::drivers)</li> <li>SIZE_BLOCK (nebula::drivers)</li> <li>SINGLE_FIRST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>SINGLE_LAST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>SINGLE_STRONGEST_RETURN (nebula::drivers::pandar_128_e4x, nebula::drivers::pandar_qt_128)</li> <li>STANDARD_RES_STATE (nebula::drivers::pandar_128_e4x)</li> <li>SEQ_NUM_SIZE (nebula::drivers::pandar_40)</li> <li>SOB_ANGLE_SIZE (nebula::drivers::pandar_40)</li> <li>STRONGEST_RETURN (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>SCAN_POINTS_NUM (nebula::drivers::pandar_at)</li> <li>SEQUENCE_SIZE (nebula::drivers::pandar_at, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>SIGNATURE_SIZE (nebula::drivers::pandar_qt_128)</li> <li>SINGLE_SECOND_RETURN (nebula::drivers::pandar_qt_128)</li> <li>SKIP_SIZE (nebula::drivers::pandar_qt_128)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#t","title":"t","text":"<ul> <li>TAIL_SIZE (nebula::drivers::pandar_128_e4x)</li> <li>THREE_SIXTY (nebula::drivers::pandar_128_e4x)</li> <li>TIMESTAMP_SIZE (nebula::drivers::pandar_40, nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>TRIPLE_RETURN (nebula::drivers::pandar_at, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#u","title":"u","text":"<ul> <li>UPPER_BANK (nebula::drivers)</li> <li>UNUSED_INT (nebula::drivers::pandar_128_e4x)</li> <li>UTC_TIME (nebula::drivers::pandar_40)</li> <li>UNIT_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> <li>UTC_SIZE (nebula::drivers::pandar_64, nebula::drivers::pandar_at, nebula::drivers::pandar_qt_128, nebula::drivers::pandar_qt_64, nebula::drivers::pandar_xt, nebula::drivers::pandar_xtm)</li> </ul>"},{"location":"nebula_decoders/namespace_member_variables/#v","title":"v","text":"<ul> <li>VLP128_DISTANCE_RESOLUTION (nebula::drivers)</li> <li>VLP16_BLOCK_DURATION (nebula::drivers)</li> <li>VLP16_DSR_TOFFSET (nebula::drivers)</li> <li>VLP16_FIRINGS_PER_BLOCK (nebula::drivers)</li> <li>VLP16_FIRING_TOFFSET (nebula::drivers)</li> <li>VLP16_SCANS_PER_FIRING (nebula::drivers)</li> <li>VLS128_BANK_1 (nebula::drivers)</li> <li>VLS128_BANK_2 (nebula::drivers)</li> <li>VLS128_BANK_3 (nebula::drivers)</li> <li>VLS128_BANK_4 (nebula::drivers)</li> <li>VLS128_CHANNEL_DURATION (nebula::drivers)</li> <li>VLS128_SEQ_DURATION (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"nebula_decoders/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>raw_block_t (nebula::drivers)</li> <li>raw_packet_t (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"nebula_decoders/namespace_member_enums/#r","title":"r","text":"<ul> <li>RETURN_TYPE (nebula::drivers)</li> </ul>"},{"location":"nebula_decoders/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_decoders/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_decoders/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_decoders/links/","title":"Nebula Decoders","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"nebula_hw_interfaces/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>struct HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO </li> <li>struct HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO </li> <li>struct HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR </li> <li>struct HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE </li> <li>struct HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS </li> <li>struct HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG </li> <li>struct HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>namespace drivers <ul> <li>class HesaiHwInterface Hardware interface of hesai driver. </li> <li>class NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. </li> <li>class VelodyneHwInterface Hardware interface of velodyne driver. </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_hw_interfaces/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_hw_interfaces <ul> <li>dir include <ul> <li>dir nebula_hw_interfaces <ul> <li>dir nebula_hw_interfaces_common <ul> <li>file nebula_hw_interface_base.hpp </li> </ul> </li> <li>dir nebula_hw_interfaces_hesai <ul> <li>file hesai_cmd_response.hpp </li> <li>file hesai_hw_interface.hpp </li> </ul> </li> <li>dir nebula_hw_interfaces_velodyne <ul> <li>file velodyne_hw_interface.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_hw_interfaces/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_hw_interfaces/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace drivers"},{"location":"nebula_hw_interfaces/namespacenebula/#classes","title":"Classes","text":"Type Name struct HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO struct HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO struct HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR struct HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE struct HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS struct HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG struct HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/","title":"Struct nebula::HesaiConfig","text":"<p>ClassList &gt; nebula &gt; HesaiConfig</p> <p>struct of PTC_COMMAND_GET_CONFIG_INFO </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#public-attributes","title":"Public Attributes","text":"Type Name int clock_data_fmt int clock_source int dest_LiDAR_udp_port int dest_gps_udp_port int dest_ipaddr int gateway int ipaddr int mask int motor_status int noise_filtering int reflectivity_mapping unsigned char reserved int return_mode int spin_rate int standby_mode int start_angle int stop_angle int sync int sync_angle int trigger_method int udp_seq int vlan_flag int vlan_id"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-clock_data_fmt","title":"variable clock_data_fmt","text":"<pre><code>int nebula::HesaiConfig::clock_data_fmt;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-clock_source","title":"variable clock_source","text":"<pre><code>int nebula::HesaiConfig::clock_source;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-dest_lidar_udp_port","title":"variable dest_LiDAR_udp_port","text":"<pre><code>int nebula::HesaiConfig::dest_LiDAR_udp_port;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-dest_gps_udp_port","title":"variable dest_gps_udp_port","text":"<pre><code>int nebula::HesaiConfig::dest_gps_udp_port;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-dest_ipaddr","title":"variable dest_ipaddr","text":"<pre><code>int nebula::HesaiConfig::dest_ipaddr[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-gateway","title":"variable gateway","text":"<pre><code>int nebula::HesaiConfig::gateway[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-ipaddr","title":"variable ipaddr","text":"<pre><code>int nebula::HesaiConfig::ipaddr[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-mask","title":"variable mask","text":"<pre><code>int nebula::HesaiConfig::mask[4];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-motor_status","title":"variable motor_status","text":"<pre><code>int nebula::HesaiConfig::motor_status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-noise_filtering","title":"variable noise_filtering","text":"<pre><code>int nebula::HesaiConfig::noise_filtering;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-reflectivity_mapping","title":"variable reflectivity_mapping","text":"<pre><code>int nebula::HesaiConfig::reflectivity_mapping;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-reserved","title":"variable reserved","text":"<pre><code>unsigned char nebula::HesaiConfig::reserved[6];\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-return_mode","title":"variable return_mode","text":"<pre><code>int nebula::HesaiConfig::return_mode;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-spin_rate","title":"variable spin_rate","text":"<pre><code>int nebula::HesaiConfig::spin_rate;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-standby_mode","title":"variable standby_mode","text":"<pre><code>int nebula::HesaiConfig::standby_mode;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-start_angle","title":"variable start_angle","text":"<pre><code>int nebula::HesaiConfig::start_angle;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-stop_angle","title":"variable stop_angle","text":"<pre><code>int nebula::HesaiConfig::stop_angle;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-sync","title":"variable sync","text":"<pre><code>int nebula::HesaiConfig::sync;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-sync_angle","title":"variable sync_angle","text":"<pre><code>int nebula::HesaiConfig::sync_angle;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-trigger_method","title":"variable trigger_method","text":"<pre><code>int nebula::HesaiConfig::trigger_method;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-udp_seq","title":"variable udp_seq","text":"<pre><code>int nebula::HesaiConfig::udp_seq;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-vlan_flag","title":"variable vlan_flag","text":"<pre><code>int nebula::HesaiConfig::vlan_flag;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#variable-vlan_id","title":"variable vlan_id","text":"<pre><code>int nebula::HesaiConfig::vlan_id;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiConfig/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiConfig::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiConfig const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/","title":"Struct nebula::HesaiInventory","text":"<p>ClassList &gt; nebula &gt; HesaiInventory</p> <p>struct of PTC_COMMAND_GET_INVENTORY_INFO </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-attributes","title":"Public Attributes","text":"Type Name int angle_offset std::vector&lt; char &gt; control_fw_ver   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; date_of_manufacture   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; hw_ver   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; mac   = = std::vector&lt;char&gt;(6) int model int motor_type int num_of_lines std::vector&lt; unsigned char &gt; reserved   = = std::vector&lt;unsigned char&gt;(11) std::vector&lt; char &gt; sensor_fw_ver   = = std::vector&lt;char&gt;(16) std::vector&lt; char &gt; sn   = = std::vector&lt;char&gt;(18) std::vector&lt; char &gt; sw_ver   = = std::vector&lt;char&gt;(16)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-functions","title":"Public Functions","text":"Type Name HesaiInventory ()  HesaiInventory (const HesaiInventory &amp; arg)  std::string get_str_model ()"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-angle_offset","title":"variable angle_offset","text":"<pre><code>int nebula::HesaiInventory::angle_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-control_fw_ver","title":"variable control_fw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::control_fw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-date_of_manufacture","title":"variable date_of_manufacture","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::date_of_manufacture;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-hw_ver","title":"variable hw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::hw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-mac","title":"variable mac","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::mac;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-model","title":"variable model","text":"<pre><code>int nebula::HesaiInventory::model;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-motor_type","title":"variable motor_type","text":"<pre><code>int nebula::HesaiInventory::motor_type;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-num_of_lines","title":"variable num_of_lines","text":"<pre><code>int nebula::HesaiInventory::num_of_lines;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-reserved","title":"variable reserved","text":"<pre><code>std::vector&lt;unsigned char&gt; nebula::HesaiInventory::reserved;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-sensor_fw_ver","title":"variable sensor_fw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::sensor_fw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-sn","title":"variable sn","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::sn;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#variable-sw_ver","title":"variable sw_ver","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiInventory::sw_ver;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#function-hesaiinventory-12","title":"function HesaiInventory [1/2]","text":"<pre><code>inline nebula::HesaiInventory::HesaiInventory () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#function-hesaiinventory-22","title":"function HesaiInventory [2/2]","text":"<pre><code>inline nebula::HesaiInventory::HesaiInventory (\nconst HesaiInventory &amp; arg\n) </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#function-get_str_model","title":"function get_str_model","text":"<pre><code>inline std::string nebula::HesaiInventory::get_str_model () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiInventory/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiInventory::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiInventory const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/","title":"Struct nebula::HesaiLidarMonitor","text":"<p>ClassList &gt; nebula &gt; HesaiLidarMonitor</p> <p>struct of PTC_COMMAND_LIDAR_MONITOR </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#public-attributes","title":"Public Attributes","text":"Type Name int input_current int input_power int input_voltage std::vector&lt; unsigned char &gt; reserved   = = std::vector&lt;unsigned char&gt;(52)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-input_current","title":"variable input_current","text":"<pre><code>int nebula::HesaiLidarMonitor::input_current;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-input_power","title":"variable input_power","text":"<pre><code>int nebula::HesaiLidarMonitor::input_power;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-input_voltage","title":"variable input_voltage","text":"<pre><code>int nebula::HesaiLidarMonitor::input_voltage;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#variable-reserved","title":"variable reserved","text":"<pre><code>std::vector&lt;unsigned char&gt; nebula::HesaiLidarMonitor::reserved;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarMonitor/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiLidarMonitor::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiLidarMonitor const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/","title":"Struct nebula::HesaiLidarRangeAll","text":"<p>ClassList &gt; nebula &gt; HesaiLidarRangeAll</p> <p>struct of PTC_COMMAND_GET_LIDAR_RANGE </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#public-attributes","title":"Public Attributes","text":"Type Name int end int method int start"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#variable-end","title":"variable end","text":"<pre><code>int nebula::HesaiLidarRangeAll::end;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#variable-method","title":"variable method","text":"<pre><code>int nebula::HesaiLidarRangeAll::method;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#variable-start","title":"variable start","text":"<pre><code>int nebula::HesaiLidarRangeAll::start;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarRangeAll/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiLidarRangeAll::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiLidarRangeAll const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/","title":"Struct nebula::HesaiLidarStatus","text":"<p>ClassList &gt; nebula &gt; HesaiLidarStatus</p> <p>struct of PTC_COMMAND_GET_LIDAR_STATUS </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-attributes","title":"Public Attributes","text":"Type Name int gps_gprmc_status int gps_pps_lock int motor_speed int ptp_clock_status std::vector&lt; unsigned char &gt; reserved   = = std::vector&lt;unsigned char&gt;(5) int startup_times int system_uptime std::vector&lt; int &gt; temperature   = = std::vector&lt;int&gt;(8) int total_operation_time"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-functions","title":"Public Functions","text":"Type Name HesaiLidarStatus ()  HesaiLidarStatus (const HesaiLidarStatus &amp; arg)  std::string get_str_gps_gprmc_status ()  std::string get_str_gps_pps_lock ()  std::string get_str_ptp_clock_status ()"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-gps_gprmc_status","title":"variable gps_gprmc_status","text":"<pre><code>int nebula::HesaiLidarStatus::gps_gprmc_status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-gps_pps_lock","title":"variable gps_pps_lock","text":"<pre><code>int nebula::HesaiLidarStatus::gps_pps_lock;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-motor_speed","title":"variable motor_speed","text":"<pre><code>int nebula::HesaiLidarStatus::motor_speed;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-ptp_clock_status","title":"variable ptp_clock_status","text":"<pre><code>int nebula::HesaiLidarStatus::ptp_clock_status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-reserved","title":"variable reserved","text":"<pre><code>std::vector&lt;unsigned char&gt; nebula::HesaiLidarStatus::reserved;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-startup_times","title":"variable startup_times","text":"<pre><code>int nebula::HesaiLidarStatus::startup_times;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-system_uptime","title":"variable system_uptime","text":"<pre><code>int nebula::HesaiLidarStatus::system_uptime;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-temperature","title":"variable temperature","text":"<pre><code>std::vector&lt;int&gt; nebula::HesaiLidarStatus::temperature;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#variable-total_operation_time","title":"variable total_operation_time","text":"<pre><code>int nebula::HesaiLidarStatus::total_operation_time;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-hesailidarstatus-12","title":"function HesaiLidarStatus [1/2]","text":"<pre><code>inline nebula::HesaiLidarStatus::HesaiLidarStatus () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-hesailidarstatus-22","title":"function HesaiLidarStatus [2/2]","text":"<pre><code>inline nebula::HesaiLidarStatus::HesaiLidarStatus (\nconst HesaiLidarStatus &amp; arg\n) </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-get_str_gps_gprmc_status","title":"function get_str_gps_gprmc_status","text":"<pre><code>inline std::string nebula::HesaiLidarStatus::get_str_gps_gprmc_status () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-get_str_gps_pps_lock","title":"function get_str_gps_pps_lock","text":"<pre><code>inline std::string nebula::HesaiLidarStatus::get_str_gps_pps_lock () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#function-get_str_ptp_clock_status","title":"function get_str_ptp_clock_status","text":"<pre><code>inline std::string nebula::HesaiLidarStatus::get_str_ptp_clock_status () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiLidarStatus/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiLidarStatus::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiLidarStatus const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/","title":"Struct nebula::HesaiPtpConfig","text":"<p>ClassList &gt; nebula &gt; HesaiPtpConfig</p> <p>struct of PTC_COMMAND_GET_PTP_CONFIG </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#public-attributes","title":"Public Attributes","text":"Type Name int domain int logAnnounceInterval int logMinDelayReqInterval int logSyncInterval int network int profile int status"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-domain","title":"variable domain","text":"<pre><code>int nebula::HesaiPtpConfig::domain;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-logannounceinterval","title":"variable logAnnounceInterval","text":"<pre><code>int nebula::HesaiPtpConfig::logAnnounceInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-logmindelayreqinterval","title":"variable logMinDelayReqInterval","text":"<pre><code>int nebula::HesaiPtpConfig::logMinDelayReqInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-logsyncinterval","title":"variable logSyncInterval","text":"<pre><code>int nebula::HesaiPtpConfig::logSyncInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-network","title":"variable network","text":"<pre><code>int nebula::HesaiPtpConfig::network;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-profile","title":"variable profile","text":"<pre><code>int nebula::HesaiPtpConfig::profile;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#variable-status","title":"variable status","text":"<pre><code>int nebula::HesaiPtpConfig::status;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpConfig/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpConfig::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiPtpConfig const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/","title":"Struct nebula::HesaiPtpDiagGrandmaster","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagGrandmaster</p> <p>LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#public-attributes","title":"Public Attributes","text":"Type Name int clockQuality int time_flags int time_source int utc_offset"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-clockquality","title":"variable clockQuality","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::clockQuality;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-time_flags","title":"variable time_flags","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::time_flags;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-time_source","title":"variable time_source","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::time_source;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#variable-utc_offset","title":"variable utc_offset","text":"<pre><code>int nebula::HesaiPtpDiagGrandmaster::utc_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagGrandmaster/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagGrandmaster::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiPtpDiagGrandmaster const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/","title":"Struct nebula::HesaiPtpDiagPort","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagPort</p> <p>PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-attributes","title":"Public Attributes","text":"Type Name int announceReceiptTimeout int delayMechanism int logAnnounceInterval int logMinDelayReqInterval int logMinPdelayReqInterval int logSyncInterval long long peerMeanPathDelay std::vector&lt; char &gt; portIdentity   = = std::vector&lt;char&gt;(10) int portState int versionNumber"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-functions","title":"Public Functions","text":"Type Name HesaiPtpDiagPort ()  HesaiPtpDiagPort (const HesaiPtpDiagPort &amp; arg)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-announcereceipttimeout","title":"variable announceReceiptTimeout","text":"<pre><code>int nebula::HesaiPtpDiagPort::announceReceiptTimeout;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-delaymechanism","title":"variable delayMechanism","text":"<pre><code>int nebula::HesaiPtpDiagPort::delayMechanism;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logannounceinterval","title":"variable logAnnounceInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logAnnounceInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logmindelayreqinterval","title":"variable logMinDelayReqInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logMinDelayReqInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logminpdelayreqinterval","title":"variable logMinPdelayReqInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logMinPdelayReqInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-logsyncinterval","title":"variable logSyncInterval","text":"<pre><code>int nebula::HesaiPtpDiagPort::logSyncInterval;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-peermeanpathdelay","title":"variable peerMeanPathDelay","text":"<pre><code>long long nebula::HesaiPtpDiagPort::peerMeanPathDelay;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-portidentity","title":"variable portIdentity","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiPtpDiagPort::portIdentity;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-portstate","title":"variable portState","text":"<pre><code>int nebula::HesaiPtpDiagPort::portState;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#variable-versionnumber","title":"variable versionNumber","text":"<pre><code>int nebula::HesaiPtpDiagPort::versionNumber;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#function-hesaiptpdiagport-12","title":"function HesaiPtpDiagPort [1/2]","text":"<pre><code>inline nebula::HesaiPtpDiagPort::HesaiPtpDiagPort () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#function-hesaiptpdiagport-22","title":"function HesaiPtpDiagPort [2/2]","text":"<pre><code>inline nebula::HesaiPtpDiagPort::HesaiPtpDiagPort (\nconst HesaiPtpDiagPort &amp; arg\n) </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagPort/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagPort::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiPtpDiagPort const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/","title":"Struct nebula::HesaiPtpDiagStatus","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagStatus</p> <p>PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#public-attributes","title":"Public Attributes","text":"Type Name int elapsed_millisec long long master_offset int ptp_state"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#variable-elapsed_millisec","title":"variable elapsed_millisec","text":"<pre><code>int nebula::HesaiPtpDiagStatus::elapsed_millisec;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#variable-master_offset","title":"variable master_offset","text":"<pre><code>long long nebula::HesaiPtpDiagStatus::master_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#variable-ptp_state","title":"variable ptp_state","text":"<pre><code>int nebula::HesaiPtpDiagStatus::ptp_state;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagStatus/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagStatus::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiPtpDiagStatus const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/","title":"Struct nebula::HesaiPtpDiagTime","text":"<p>ClassList &gt; nebula &gt; HesaiPtpDiagTime</p> <p>LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </p> <ul> <li><code>#include &lt;hesai_cmd_response.hpp&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-attributes","title":"Public Attributes","text":"Type Name int cumulativeScaledRateOffset long long gmIdentity int gmPresent int gmTimeBaseIndicator long long ingress_time std::vector&lt; char &gt; lastGmPhaseChange   = = std::vector&lt;char&gt;(12) long long master_offset int scaledLastGmPhaseChange"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-functions","title":"Public Functions","text":"Type Name HesaiPtpDiagTime ()  HesaiPtpDiagTime (const HesaiPtpDiagTime &amp; arg)"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-cumulativescaledrateoffset","title":"variable cumulativeScaledRateOffset","text":"<pre><code>int nebula::HesaiPtpDiagTime::cumulativeScaledRateOffset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-gmidentity","title":"variable gmIdentity","text":"<pre><code>long long nebula::HesaiPtpDiagTime::gmIdentity;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-gmpresent","title":"variable gmPresent","text":"<pre><code>int nebula::HesaiPtpDiagTime::gmPresent;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-gmtimebaseindicator","title":"variable gmTimeBaseIndicator","text":"<pre><code>int nebula::HesaiPtpDiagTime::gmTimeBaseIndicator;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-ingress_time","title":"variable ingress_time","text":"<pre><code>long long nebula::HesaiPtpDiagTime::ingress_time;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-lastgmphasechange","title":"variable lastGmPhaseChange","text":"<pre><code>std::vector&lt;char&gt; nebula::HesaiPtpDiagTime::lastGmPhaseChange;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-master_offset","title":"variable master_offset","text":"<pre><code>long long nebula::HesaiPtpDiagTime::master_offset;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#variable-scaledlastgmphasechange","title":"variable scaledLastGmPhaseChange","text":"<pre><code>int nebula::HesaiPtpDiagTime::scaledLastGmPhaseChange;\n</code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#function-hesaiptpdiagtime-12","title":"function HesaiPtpDiagTime [1/2]","text":"<pre><code>inline nebula::HesaiPtpDiagTime::HesaiPtpDiagTime () </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#function-hesaiptpdiagtime-22","title":"function HesaiPtpDiagTime [2/2]","text":"<pre><code>inline nebula::HesaiPtpDiagTime::HesaiPtpDiagTime (\nconst HesaiPtpDiagTime &amp; arg\n) </code></pre>"},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#friends-documentation","title":"Friends Documentation","text":""},{"location":"nebula_hw_interfaces/structnebula_1_1HesaiPtpDiagTime/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; nebula::HesaiPtpDiagTime::operator&lt;&lt; (\nstd::ostream &amp; os,\nnebula::HesaiPtpDiagTime const &amp; arg\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/","title":"Namespace nebula::drivers","text":"<p>Namespace List &gt; nebula &gt; drivers</p>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#classes","title":"Classes","text":"Type Name class HesaiHwInterface Hardware interface of hesai driver. class NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. class VelodyneHwInterface Hardware interface of velodyne driver."},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#public-attributes","title":"Public Attributes","text":"Type Name const int HESAI_LIDAR_GPS_CLOCK_SOURCE   = = 0 const int HESAI_LIDAR_PTP_CLOCK_SOURCE   = = 1 const uint16_t MTU_SIZE   = = 1500 const uint16_t PANDAR128_E4X_EXTENDED_PACKET_SIZE   = = 1117 const uint16_t PANDAR128_E4X_PACKET_SIZE   = = 861 const uint16_t PANDAR40P_EXTENDED_PACKET_SIZE   = = 1266 const uint16_t PANDAR40_PACKET_SIZE   = = 1262 const uint16_t PANDAR64_EXTENDED_PACKET_SIZE   = = 1198 const uint16_t PANDAR64_PACKET_SIZE   = = 1194 const uint16_t PANDARAT128_PACKET_SIZE   = = 1118 const uint16_t PANDARQT128_PACKET_SIZE   = = 1127 const uint16_t PANDARQT64_PACKET_SIZE   = = 1072 const uint16_t PANDARXT32M_PACKET_SIZE   = = 820 const uint16_t PANDARXT32_PACKET_SIZE   = = 1080 const uint8_t PTC_COMMAND_DUMMY_BYTE   = = 0x00 const uint8_t PTC_COMMAND_GET_CONFIG_INFO   = = 0x08 const uint8_t PTC_COMMAND_GET_INVENTORY_INFO   = = 0x07 const uint8_t PTC_COMMAND_GET_LIDAR_CALIBRATION   = = 0x05 const uint8_t PTC_COMMAND_GET_LIDAR_RANGE   = = 0x23 const uint8_t PTC_COMMAND_GET_LIDAR_STATUS   = = 0x09 const uint8_t PTC_COMMAND_GET_PTP_CONFIG   = = 0x26 const uint8_t PTC_COMMAND_HEADER_HIGH   = = 0x47 const uint8_t PTC_COMMAND_HEADER_LOW   = = 0x74 const uint8_t PTC_COMMAND_LIDAR_MONITOR   = = 0x27 const uint8_t PTC_COMMAND_PTP_DIAGNOSTICS   = = 0x06 const uint8_t PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP   = = 0x04 const uint8_t PTC_COMMAND_PTP_PORT_DATA_SET   = = 0x02 const uint8_t PTC_COMMAND_PTP_STATUS   = = 0x01 const uint8_t PTC_COMMAND_PTP_TIME_STATUS_NP   = = 0x03 const uint8_t PTC_COMMAND_RESET   = = 0x25 const uint8_t PTC_COMMAND_SET_CLOCK_SOURCE   = = 0x1f const uint8_t PTC_COMMAND_SET_CONTROL_PORT   = = 0x21 const uint8_t PTC_COMMAND_SET_DESTINATION_IP   = = 0x20 const uint8_t PTC_COMMAND_SET_LIDAR_RANGE   = = 0x22 const uint8_t PTC_COMMAND_SET_PTP_CONFIG   = = 0x24 const uint8_t PTC_COMMAND_SET_RETURN_MODE   = = 0x1e const uint8_t PTC_COMMAND_SET_ROTATE_DIRECTION   = = 0x2a const uint8_t PTC_COMMAND_SET_SPIN_RATE   = = 0x17 const uint8_t PTC_COMMAND_SET_STANDBY_MODE   = = 0x1c const uint8_t PTC_COMMAND_SET_SYNC_ANGLE   = = 0x18 const uint8_t PTC_COMMAND_SET_TRIGGER_METHOD   = = 0x1b const int PTP_DOMAIN_ID   = = 0 const int PTP_LOG_ANNOUNCE_INTERVAL   = = 1 const int PTP_LOG_MIN_DELAY_INTERVAL   = = 0 const int PTP_NETWORK_TRANSPORT   = = 0 const int PTP_PROFILE   = = 0 const int PTP_SYNC_INTERVAL   = = 1 const int PandarTcpCommandPort   = = 9347"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-hesai_lidar_gps_clock_source","title":"variable HESAI_LIDAR_GPS_CLOCK_SOURCE","text":"<pre><code>const int nebula::drivers::HESAI_LIDAR_GPS_CLOCK_SOURCE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-hesai_lidar_ptp_clock_source","title":"variable HESAI_LIDAR_PTP_CLOCK_SOURCE","text":"<pre><code>const int nebula::drivers::HESAI_LIDAR_PTP_CLOCK_SOURCE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-mtu_size","title":"variable MTU_SIZE","text":"<pre><code>const uint16_t nebula::drivers::MTU_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar128_e4x_extended_packet_size","title":"variable PANDAR128_E4X_EXTENDED_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR128_E4X_EXTENDED_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar128_e4x_packet_size","title":"variable PANDAR128_E4X_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR128_E4X_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar40p_extended_packet_size","title":"variable PANDAR40P_EXTENDED_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR40P_EXTENDED_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar40_packet_size","title":"variable PANDAR40_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR40_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar64_extended_packet_size","title":"variable PANDAR64_EXTENDED_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR64_EXTENDED_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandar64_packet_size","title":"variable PANDAR64_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDAR64_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarat128_packet_size","title":"variable PANDARAT128_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARAT128_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarqt128_packet_size","title":"variable PANDARQT128_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARQT128_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarqt64_packet_size","title":"variable PANDARQT64_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARQT64_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarxt32m_packet_size","title":"variable PANDARXT32M_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARXT32M_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandarxt32_packet_size","title":"variable PANDARXT32_PACKET_SIZE","text":"<pre><code>const uint16_t nebula::drivers::PANDARXT32_PACKET_SIZE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_dummy_byte","title":"variable PTC_COMMAND_DUMMY_BYTE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_DUMMY_BYTE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_config_info","title":"variable PTC_COMMAND_GET_CONFIG_INFO","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_CONFIG_INFO;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_inventory_info","title":"variable PTC_COMMAND_GET_INVENTORY_INFO","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_INVENTORY_INFO;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_lidar_calibration","title":"variable PTC_COMMAND_GET_LIDAR_CALIBRATION","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_LIDAR_CALIBRATION;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_lidar_range","title":"variable PTC_COMMAND_GET_LIDAR_RANGE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_LIDAR_RANGE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_lidar_status","title":"variable PTC_COMMAND_GET_LIDAR_STATUS","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_LIDAR_STATUS;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_get_ptp_config","title":"variable PTC_COMMAND_GET_PTP_CONFIG","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_GET_PTP_CONFIG;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_header_high","title":"variable PTC_COMMAND_HEADER_HIGH","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_HEADER_HIGH;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_header_low","title":"variable PTC_COMMAND_HEADER_LOW","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_HEADER_LOW;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_lidar_monitor","title":"variable PTC_COMMAND_LIDAR_MONITOR","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_LIDAR_MONITOR;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_diagnostics","title":"variable PTC_COMMAND_PTP_DIAGNOSTICS","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_DIAGNOSTICS;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_grandmaster_settings_np","title":"variable PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_port_data_set","title":"variable PTC_COMMAND_PTP_PORT_DATA_SET","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_PORT_DATA_SET;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_status","title":"variable PTC_COMMAND_PTP_STATUS","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_STATUS;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_ptp_time_status_np","title":"variable PTC_COMMAND_PTP_TIME_STATUS_NP","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_PTP_TIME_STATUS_NP;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_reset","title":"variable PTC_COMMAND_RESET","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_RESET;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_clock_source","title":"variable PTC_COMMAND_SET_CLOCK_SOURCE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_CLOCK_SOURCE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_control_port","title":"variable PTC_COMMAND_SET_CONTROL_PORT","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_CONTROL_PORT;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_destination_ip","title":"variable PTC_COMMAND_SET_DESTINATION_IP","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_DESTINATION_IP;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_lidar_range","title":"variable PTC_COMMAND_SET_LIDAR_RANGE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_LIDAR_RANGE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_ptp_config","title":"variable PTC_COMMAND_SET_PTP_CONFIG","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_PTP_CONFIG;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_return_mode","title":"variable PTC_COMMAND_SET_RETURN_MODE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_RETURN_MODE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_rotate_direction","title":"variable PTC_COMMAND_SET_ROTATE_DIRECTION","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_ROTATE_DIRECTION;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_spin_rate","title":"variable PTC_COMMAND_SET_SPIN_RATE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_SPIN_RATE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_standby_mode","title":"variable PTC_COMMAND_SET_STANDBY_MODE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_STANDBY_MODE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_sync_angle","title":"variable PTC_COMMAND_SET_SYNC_ANGLE","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_SYNC_ANGLE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptc_command_set_trigger_method","title":"variable PTC_COMMAND_SET_TRIGGER_METHOD","text":"<pre><code>const uint8_t nebula::drivers::PTC_COMMAND_SET_TRIGGER_METHOD;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_domain_id","title":"variable PTP_DOMAIN_ID","text":"<pre><code>const int nebula::drivers::PTP_DOMAIN_ID;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_log_announce_interval","title":"variable PTP_LOG_ANNOUNCE_INTERVAL","text":"<pre><code>const int nebula::drivers::PTP_LOG_ANNOUNCE_INTERVAL;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_log_min_delay_interval","title":"variable PTP_LOG_MIN_DELAY_INTERVAL","text":"<pre><code>const int nebula::drivers::PTP_LOG_MIN_DELAY_INTERVAL;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_network_transport","title":"variable PTP_NETWORK_TRANSPORT","text":"<pre><code>const int nebula::drivers::PTP_NETWORK_TRANSPORT;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_profile","title":"variable PTP_PROFILE","text":"<pre><code>const int nebula::drivers::PTP_PROFILE;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-ptp_sync_interval","title":"variable PTP_SYNC_INTERVAL","text":"<pre><code>const int nebula::drivers::PTP_SYNC_INTERVAL;\n</code></pre>"},{"location":"nebula_hw_interfaces/namespacenebula_1_1drivers/#variable-pandartcpcommandport","title":"variable PandarTcpCommandPort","text":"<pre><code>const int nebula::drivers::PandarTcpCommandPort;\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/","title":"Class nebula::drivers::HesaiHwInterface","text":"<p>ClassList &gt; nebula &gt; drivers &gt; HesaiHwInterface</p> <p>Hardware interface of hesai driver. </p> <ul> <li><code>#include &lt;hesai_hw_interface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaHwInterfaceBase</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#public-functions","title":"Public Functions","text":"Type Name HesaiStatus CheckAndSetConfig (std::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration, HesaiConfig hesai_config) Checking the current settings and changing the difference point. HesaiStatus CheckAndSetConfig (std::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration, HesaiLidarRangeAll hesai_lidar_range_all) Checking the current settings and changing the difference point. HesaiStatus CheckAndSetConfig () Checking the current settings and changing the difference point. virtual Status CloudInterfaceStart () Starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () Function for stopping the interface that handles UDP streams. Status FinalizeTcpDriver () Closes the TcpDriver and related resources. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) Printing calibration configuration. Status GetConfig (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiConfig &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiConfig &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (std::function&lt; void(HesaiConfig &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. Status GetConfig (bool with_run=true) Getting data with PTC_COMMAND_GET_CONFIG_INFO. std::shared_ptr&lt; boost::asio::io_context &gt; GetIOContext () GetIO Context. Status GetInventory (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiInventory &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiInventory &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (std::function&lt; void(HesaiInventory &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetInventory (bool with_run=true) Getting data with PTC_COMMAND_GET_INVENTORY_INFO. Status GetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::string &amp;str)&gt; str_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(const std::string &amp;str)&gt; str_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibrationFromSensor (std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibrationFromSensor (std::function&lt; void(const std::string &amp;str)&gt; str_callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarCalibrationFromSensor (bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. Status GetLidarMonitor (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiLidarMonitor &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. Status GetLidarMonitor (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiLidarMonitor &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. Status GetLidarMonitor (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. Status GetLidarMonitor (std::function&lt; void(HesaiLidarMonitor &amp;result)&gt; callback, bool with_run=true)  Status GetLidarMonitor (bool with_run=true) Getting data with PTC_COMMAND_LIDAR_MONITOR. HesaiStatus GetLidarMonitorAsyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting lidar_monitor via HTTP API. HesaiStatus GetLidarMonitorAsyncHttp (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting lidar_monitor via HTTP API. Status GetLidarRange (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiLidarRangeAll &amp;result)&gt; callback, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiLidarRangeAll &amp;result)&gt; callback, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (std::function&lt; void(HesaiLidarRangeAll &amp;result)&gt; callback, bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarRange (bool with_run=true) Getting values with PTC_COMMAND_GET_LIDAR_RANGE. Status GetLidarStatus (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(HesaiLidarStatus &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(HesaiLidarStatus &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (std::function&lt; void(HesaiLidarStatus &amp;result)&gt; callback, bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetLidarStatus (bool with_run=true) Getting data with PTC_COMMAND_GET_LIDAR_STATUS. Status GetPtpConfig (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_GET_PTP_CONFIG. Status GetPtpConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_GET_PTP_CONFIG. Status GetPtpConfig (bool with_run=true) Getting data with PTC_COMMAND_GET_PTP_CONFIG. Status GetPtpDiagGrandmaster (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) Status GetPtpDiagGrandmaster (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) Status GetPtpDiagGrandmaster (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) Status GetPtpDiagPort (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) Status GetPtpDiagPort (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) Status GetPtpDiagPort (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) Status GetPtpDiagStatus (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) Status GetPtpDiagStatus (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) Status GetPtpDiagStatus (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) Status GetPtpDiagTime (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) Status GetPtpDiagTime (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) Status GetPtpDiagTime (bool with_run=true) Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) Printing sensor configuration. HesaiHwInterface () Constructor. void IOContextRun () Call run() of IO Context. Status InitializeTcpDriver (bool setup_sensor=true) Initializing tcp_driver for TCP communication. boost::property_tree::ptree ParseJson (const std::string &amp; str) Parsing json string to property_tree. virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) Callback function to receive the Cloud Packet data from the UDP Driver. Status RegisterScanCallback (std::function&lt; void(std::unique_ptr&lt; pandar_msgs::msg::PandarScan &gt;)&gt; scan_callback) Registering callback for PandarScan. Status SendReset (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, bool with_run=true) Sending command with PTC_COMMAND_RESET. Status SendReset (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, bool with_run=true) Sending command with PTC_COMMAND_RESET. Status SendReset (bool with_run=true) Sending command with PTC_COMMAND_RESET. Status SetClockSource (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int clock_source, bool with_run)  Status SetClockSource (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int clock_source, bool with_run)  Status SetClockSource (int clock_source, bool with_run=true)  Status SetControlPort (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run=true) Setting IP with PTC_COMMAND_SET_CONTROL_PORT. Status SetControlPort (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run=true) Setting IP with PTC_COMMAND_SET_CONTROL_PORT. Status SetControlPort (int ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run=true) Setting IP with PTC_COMMAND_SET_CONTROL_PORT. Status SetDestinationIp (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run=true) Setting IP with PTC_COMMAND_SET_DESTINATION_IP. Status SetDestinationIp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run=true) Setting IP with PTC_COMMAND_SET_DESTINATION_IP. Status SetDestinationIp (int dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run=true) Setting IP with PTC_COMMAND_SET_DESTINATION_IP. Status SetLidarRange (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int method, std::vector&lt; unsigned char &gt; data, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int method, std::vector&lt; unsigned char &gt; data, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (int method, std::vector&lt; unsigned char &gt; data, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int start, int end, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int start, int end, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. Status SetLidarRange (int start, int end, bool with_run=true) Setting values with PTC_COMMAND_SET_LIDAR_RANGE. void SetLogger (std::shared_ptr&lt; rclcpp::Logger &gt; node) Setting rclcpp::Logger. Status SetPtpConfig (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run=true) Setting values with PTC_COMMAND_SET_PTP_CONFIG. Status SetPtpConfig (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run=true) Setting values with PTC_COMMAND_SET_PTP_CONFIG. Status SetPtpConfig (int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run=true) Setting values with PTC_COMMAND_SET_PTP_CONFIG. HesaiStatus SetPtpConfigSyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval)  HesaiStatus SetPtpConfigSyncHttp (int profile, int domain, int network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval)  Status SetReturnMode (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int return_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_RETURN_MODE. Status SetReturnMode (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int return_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_RETURN_MODE. Status SetReturnMode (int return_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_RETURN_MODE. Status SetRotDir (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int mode, bool with_run=true) Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. Status SetRotDir (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int mode, bool with_run=true) Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. Status SetRotDir (int mode, bool with_run=true) Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Setting sensor configuration. Status SetSpinRate (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, uint16_t rpm, bool with_run=true) Setting value with PTC_COMMAND_SET_SPIN_RATE. Status SetSpinRate (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, uint16_t rpm, bool with_run=true) Setting value with PTC_COMMAND_SET_SPIN_RATE. Status SetSpinRate (uint16_t rpm, bool with_run=true) Setting value with PTC_COMMAND_SET_SPIN_RATE. HesaiStatus SetSpinSpeedAsyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, uint16_t rpm) Setting spin_speed via HTTP API. HesaiStatus SetSpinSpeedAsyncHttp (uint16_t rpm) Setting spin_speed via HTTP API. Status SetStandbyMode (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int standby_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_STANDBY_MODE. Status SetStandbyMode (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int standby_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_STANDBY_MODE. Status SetStandbyMode (int standby_mode, bool with_run=true) Setting mode with PTC_COMMAND_SET_STANDBY_MODE. Status SetSyncAngle (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int sync_angle, int angle, bool with_run=true) Setting value with PTC_COMMAND_SET_SYNC_ANGLE. Status SetSyncAngle (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int sync_angle, int angle, bool with_run=true) Setting value with PTC_COMMAND_SET_SYNC_ANGLE. Status SetSyncAngle (int sync_angle, int angle, bool with_run=true) Setting value with PTC_COMMAND_SET_SYNC_ANGLE. HesaiStatus SetSyncAngleSyncHttp (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int enable, int angle)  HesaiStatus SetSyncAngleSyncHttp (int enable, int angle)  void SetTargetModel (int model) Set target model number (for proper use of HTTP and TCP according to the support of the target model) Status SetTriggerMethod (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, int trigger_method, bool with_run=true) Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. Status SetTriggerMethod (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, int trigger_method, bool with_run=true) Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. Status SetTriggerMethod (int trigger_method, bool with_run=true) Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. bool UseHttpGetLidarMonitor (int model) Whether to use HTTP for getting LidarMonitor. bool UseHttpGetLidarMonitor () Whether to use HTTP for getting LidarMonitor. bool UseHttpSetSpinRate (int model) Whether to use HTTP for setting SpinRate. bool UseHttpSetSpinRate () Whether to use HTTP for setting SpinRate. Status syncGetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver, std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx, std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibration (std::shared_ptr&lt; boost::asio::io_context &gt; ctx) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibrationFromSensor (std::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibrationFromSensor (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) Status syncGetLidarCalibrationFromSensor () Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync)"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#public-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Public Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#protected-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Protected Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-checkandsetconfig-13","title":"function CheckAndSetConfig [1/3]","text":"<p>Checking the current settings and changing the difference point. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::CheckAndSetConfig (\nstd::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration,\nHesaiConfig hesai_config\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Current SensorConfiguration </li> <li><code>hesai_config</code> Current HesaiConfig </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-checkandsetconfig-23","title":"function CheckAndSetConfig [2/3]","text":"<p>Checking the current settings and changing the difference point. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::CheckAndSetConfig (\nstd::shared_ptr&lt; HesaiSensorConfiguration &gt; sensor_configuration,\nHesaiLidarRangeAll hesai_lidar_range_all\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Current SensorConfiguration </li> <li><code>hesai_lidar_range_all</code> Current HesaiLidarRangeAll </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-checkandsetconfig-33","title":"function CheckAndSetConfig [3/3]","text":"<p>Checking the current settings and changing the difference point. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::CheckAndSetConfig () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Starting the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::CloudInterfaceStart () </code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::CloudInterfaceStop () </code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-finalizetcpdriver","title":"function FinalizeTcpDriver","text":"<p>Closes the TcpDriver and related resources. <pre><code>Status nebula::drivers::HesaiHwInterface::FinalizeTcpDriver () </code></pre></p> <p>Returns:</p> <p>Status result </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Printing calibration configuration. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::GetCalibrationConfiguration (\nCalibrationConfigurationBase &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-15","title":"function GetConfig [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void( HesaiConfig &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiConfig </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-25","title":"function GetConfig [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void( HesaiConfig &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiConfig </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-35","title":"function GetConfig [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-45","title":"function GetConfig [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\nstd::function&lt; void( HesaiConfig &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiConfig </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getconfig-55","title":"function GetConfig [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_CONFIG_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetConfig (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getiocontext","title":"function GetIOContext","text":"<p>GetIO Context. <pre><code>std::shared_ptr&lt; boost::asio::io_context &gt; nebula::drivers::HesaiHwInterface::GetIOContext () </code></pre></p> <p>Returns:</p> <p>IO Context </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-15","title":"function GetInventory [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void( HesaiInventory &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiInventory </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-25","title":"function GetInventory [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void( HesaiInventory &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiInventory </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-35","title":"function GetInventory [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-45","title":"function GetInventory [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\nstd::function&lt; void( HesaiInventory &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiInventory </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getinventory-55","title":"function GetInventory [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_INVENTORY_INFO. <pre><code>Status nebula::drivers::HesaiHwInterface::GetInventory (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-15","title":"function GetLidarCalibration [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-25","title":"function GetLidarCalibration [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>bytes_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-35","title":"function GetLidarCalibration [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-45","title":"function GetLidarCalibration [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibration-55","title":"function GetLidarCalibration [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibration (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibrationfromsensor-13","title":"function GetLidarCalibrationFromSensor [1/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibrationFromSensor (\nstd::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibrationfromsensor-23","title":"function GetLidarCalibrationFromSensor [2/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibrationFromSensor (\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>bytes_callback</code> callback </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarcalibrationfromsensor-33","title":"function GetLidarCalibrationFromSensor [3/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarCalibrationFromSensor (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>str_callback</code> callback </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-15","title":"function GetLidarMonitor [1/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void( HesaiLidarMonitor &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiLidarMonitor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-25","title":"function GetLidarMonitor [2/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void( HesaiLidarMonitor &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiLidarMonitor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-35","title":"function GetLidarMonitor [3/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-45","title":"function GetLidarMonitor [4/5]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\nstd::function&lt; void( HesaiLidarMonitor &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitor-55","title":"function GetLidarMonitor [5/5]","text":"<p>Getting data with PTC_COMMAND_LIDAR_MONITOR. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarMonitor (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitorasynchttp-12","title":"function GetLidarMonitorAsyncHttp [1/2]","text":"<p>Getting lidar_monitor via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::GetLidarMonitorAsyncHttp (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context </li> <li><code>str_callback</code> Callback function for received string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarmonitorasynchttp-22","title":"function GetLidarMonitorAsyncHttp [2/2]","text":"<p>Getting lidar_monitor via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::GetLidarMonitorAsyncHttp (\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-15","title":"function GetLidarRange [1/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void( HesaiLidarRangeAll &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiLidarRangeAll </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-25","title":"function GetLidarRange [2/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void( HesaiLidarRangeAll &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiLidarRangeAll </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-35","title":"function GetLidarRange [3/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-45","title":"function GetLidarRange [4/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\nstd::function&lt; void( HesaiLidarRangeAll &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiLidarRangeAll </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarrange-55","title":"function GetLidarRange [5/5]","text":"<p>Getting values with PTC_COMMAND_GET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarRange (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-15","title":"function GetLidarStatus [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void( HesaiLidarStatus &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>callback</code> Callback function for received HesaiLidarStatus </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-25","title":"function GetLidarStatus [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void( HesaiLidarStatus &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>callback</code> Callback function for received HesaiLidarStatus </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-35","title":"function GetLidarStatus [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-45","title":"function GetLidarStatus [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\nstd::function&lt; void( HesaiLidarStatus &amp;result)&gt; callback,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>callback</code> Callback function for received HesaiLidarStatus </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getlidarstatus-55","title":"function GetLidarStatus [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_STATUS. <pre><code>Status nebula::drivers::HesaiHwInterface::GetLidarStatus (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpconfig-13","title":"function GetPtpConfig [1/3]","text":"<p>Getting data with PTC_COMMAND_GET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpConfig (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpconfig-23","title":"function GetPtpConfig [2/3]","text":"<p>Getting data with PTC_COMMAND_GET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpConfig (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpconfig-33","title":"function GetPtpConfig [3/3]","text":"<p>Getting data with PTC_COMMAND_GET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpConfig (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiaggrandmaster-13","title":"function GetPtpDiagGrandmaster [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagGrandmaster (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiaggrandmaster-23","title":"function GetPtpDiagGrandmaster [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagGrandmaster (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiaggrandmaster-33","title":"function GetPtpDiagGrandmaster [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV GRANDMASTER_SETTINGS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagGrandmaster (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagport-13","title":"function GetPtpDiagPort [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagPort (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagport-23","title":"function GetPtpDiagPort [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagPort (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagport-33","title":"function GetPtpDiagPort [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV PORT_DATA_SET) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagPort (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagstatus-13","title":"function GetPtpDiagStatus [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagStatus (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagstatus-23","title":"function GetPtpDiagStatus [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagStatus (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagstatus-33","title":"function GetPtpDiagStatus [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP STATUS) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagStatus (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagtime-13","title":"function GetPtpDiagTime [1/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagTime (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagtime-23","title":"function GetPtpDiagTime [2/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagTime (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getptpdiagtime-33","title":"function GetPtpDiagTime [3/3]","text":"<p>Getting data with PTC_COMMAND_PTP_DIAGNOSTICS (PTP TLV TIME_STATUS_NP) <pre><code>Status nebula::drivers::HesaiHwInterface::GetPtpDiagTime (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Printing sensor configuration. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::GetSensorConfiguration (\nSensorConfigurationBase &amp; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-hesaihwinterface","title":"function HesaiHwInterface","text":"<pre><code>nebula::drivers::HesaiHwInterface::HesaiHwInterface () </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-iocontextrun","title":"function IOContextRun","text":"<pre><code>void nebula::drivers::HesaiHwInterface::IOContextRun () </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-initializetcpdriver","title":"function InitializeTcpDriver","text":"<p>Initializing tcp_driver for TCP communication. <pre><code>Status nebula::drivers::HesaiHwInterface::InitializeTcpDriver (\nbool setup_sensor=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>setup_sensor</code> Whether to also initialize tcp_driver for sensor configuration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-parsejson","title":"function ParseJson","text":"<p>Parsing json string to property_tree. <pre><code>boost::property_tree::ptree nebula::drivers::HesaiHwInterface::ParseJson (\nconst std::string &amp; str\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> JSON string </li> </ul> <p>Returns:</p> <p>Parsed property_tree </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<p>Callback function to receive the Cloud Packet data from the UDP Driver. <pre><code>virtual void nebula::drivers::HesaiHwInterface::ReceiveCloudPacketCallback (\nconst std::vector&lt; uint8_t &gt; &amp; buffer\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Implements nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-registerscancallback","title":"function RegisterScanCallback","text":"<p>Registering callback for PandarScan. <pre><code>Status nebula::drivers::HesaiHwInterface::RegisterScanCallback (\nstd::function&lt; void(std::unique_ptr&lt; pandar_msgs::msg::PandarScan &gt;)&gt; scan_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_callback</code> Callback function </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-sendreset-13","title":"function SendReset [1/3]","text":"<p>Sending command with PTC_COMMAND_RESET. <pre><code>Status nebula::drivers::HesaiHwInterface::SendReset (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-sendreset-23","title":"function SendReset [2/3]","text":"<p>Sending command with PTC_COMMAND_RESET. <pre><code>Status nebula::drivers::HesaiHwInterface::SendReset (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-sendreset-33","title":"function SendReset [3/3]","text":"<p>Sending command with PTC_COMMAND_RESET. <pre><code>Status nebula::drivers::HesaiHwInterface::SendReset (\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setclocksource-13","title":"function SetClockSource [1/3]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::SetClockSource (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint clock_source,\nbool with_run\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setclocksource-23","title":"function SetClockSource [2/3]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::SetClockSource (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint clock_source,\nbool with_run\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setclocksource-33","title":"function SetClockSource [3/3]","text":"<pre><code>Status nebula::drivers::HesaiHwInterface::SetClockSource (\nint clock_source,\nbool with_run=true\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setcontrolport-13","title":"function SetControlPort [1/3]","text":"<p>Setting IP with PTC_COMMAND_SET_CONTROL_PORT. <pre><code>Status nebula::drivers::HesaiHwInterface::SetControlPort (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint ip_1,\nint ip_2,\nint ip_3,\nint ip_4,\nint mask_1,\nint mask_2,\nint mask_3,\nint mask_4,\nint gateway_1,\nint gateway_2,\nint gateway_3,\nint gateway_4,\nint vlan_flg,\nint vlan_id,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>ip_1</code> Device IP of the 1st byte represents the 1st section </li> <li><code>ip_2</code> Device IP of the 2nd byte represents the 2nd section </li> <li><code>ip_3</code> Device IP of the 3rd byte represents the 3rd section </li> <li><code>ip_4</code> Device IP of the 4th byte represents the 4th section </li> <li><code>mask_1</code> Device subnet mask of the 1st byte represents the 1st section </li> <li><code>mask_2</code> Device subnet mask of the 2nd byte represents the 2nd section </li> <li><code>mask_3</code> Device subnet mask of the 3rd byte represents the 3rd section </li> <li><code>mask_4</code> Device subnet mask of the 4th byte represents the 4th section </li> <li><code>gateway_1</code> Device gateway of the 1st byte represents the 1st section </li> <li><code>gateway_2</code> Device gateway of the 2nd byte represents the 2nd section </li> <li><code>gateway_3</code> Device gateway of the 3rd byte represents the 3rd section </li> <li><code>gateway_4</code> Device gateway of the 4th byte represents the 4th section </li> <li><code>vlan_flg</code> VLAN Status </li> <li><code>vlan_id</code> VLAN ID </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setcontrolport-23","title":"function SetControlPort [2/3]","text":"<p>Setting IP with PTC_COMMAND_SET_CONTROL_PORT. <pre><code>Status nebula::drivers::HesaiHwInterface::SetControlPort (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint ip_1,\nint ip_2,\nint ip_3,\nint ip_4,\nint mask_1,\nint mask_2,\nint mask_3,\nint mask_4,\nint gateway_1,\nint gateway_2,\nint gateway_3,\nint gateway_4,\nint vlan_flg,\nint vlan_id,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>ip_1</code> Device IP of the 1st byte represents the 1st section </li> <li><code>ip_2</code> Device IP of the 2nd byte represents the 2nd section </li> <li><code>ip_3</code> Device IP of the 3rd byte represents the 3rd section </li> <li><code>ip_4</code> Device IP of the 4th byte represents the 4th section </li> <li><code>mask_1</code> Device subnet mask of the 1st byte represents the 1st section </li> <li><code>mask_2</code> Device subnet mask of the 2nd byte represents the 2nd section </li> <li><code>mask_3</code> Device subnet mask of the 3rd byte represents the 3rd section </li> <li><code>mask_4</code> Device subnet mask of the 4th byte represents the 4th section </li> <li><code>gateway_1</code> Device gateway of the 1st byte represents the 1st section </li> <li><code>gateway_2</code> Device gateway of the 2nd byte represents the 2nd section </li> <li><code>gateway_3</code> Device gateway of the 3rd byte represents the 3rd section </li> <li><code>gateway_4</code> Device gateway of the 4th byte represents the 4th section </li> <li><code>vlan_flg</code> VLAN Status </li> <li><code>vlan_id</code> VLAN ID </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setcontrolport-33","title":"function SetControlPort [3/3]","text":"<p>Setting IP with PTC_COMMAND_SET_CONTROL_PORT. <pre><code>Status nebula::drivers::HesaiHwInterface::SetControlPort (\nint ip_1,\nint ip_2,\nint ip_3,\nint ip_4,\nint mask_1,\nint mask_2,\nint mask_3,\nint mask_4,\nint gateway_1,\nint gateway_2,\nint gateway_3,\nint gateway_4,\nint vlan_flg,\nint vlan_id,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ip_1</code> Device IP of the 1st byte represents the 1st section </li> <li><code>ip_2</code> Device IP of the 2nd byte represents the 2nd section </li> <li><code>ip_3</code> Device IP of the 3rd byte represents the 3rd section </li> <li><code>ip_4</code> Device IP of the 4th byte represents the 4th section </li> <li><code>mask_1</code> Device subnet mask of the 1st byte represents the 1st section </li> <li><code>mask_2</code> Device subnet mask of the 2nd byte represents the 2nd section </li> <li><code>mask_3</code> Device subnet mask of the 3rd byte represents the 3rd section </li> <li><code>mask_4</code> Device subnet mask of the 4th byte represents the 4th section </li> <li><code>gateway_1</code> Device gateway of the 1st byte represents the 1st section </li> <li><code>gateway_2</code> Device gateway of the 2nd byte represents the 2nd section </li> <li><code>gateway_3</code> Device gateway of the 3rd byte represents the 3rd section </li> <li><code>gateway_4</code> Device gateway of the 4th byte represents the 4th section </li> <li><code>vlan_flg</code> VLAN Status </li> <li><code>vlan_id</code> VLAN ID </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setdestinationip-13","title":"function SetDestinationIp [1/3]","text":"<p>Setting IP with PTC_COMMAND_SET_DESTINATION_IP. <pre><code>Status nebula::drivers::HesaiHwInterface::SetDestinationIp (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint dest_ip_1,\nint dest_ip_2,\nint dest_ip_3,\nint dest_ip_4,\nint port,\nint gps_port,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>dest_ip_1</code> The 1st byte represents the 1st section </li> <li><code>dest_ip_2</code> The 2nd byte represents the 2nd section </li> <li><code>dest_ip_3</code> The 3rd byte represents the 3rd section </li> <li><code>dest_ip_4</code> The 4th byte represents the 4th section </li> <li><code>port</code> LiDAR Destination Port </li> <li><code>gps_port</code> GPS Destination Port </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setdestinationip-23","title":"function SetDestinationIp [2/3]","text":"<p>Setting IP with PTC_COMMAND_SET_DESTINATION_IP. <pre><code>Status nebula::drivers::HesaiHwInterface::SetDestinationIp (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint dest_ip_1,\nint dest_ip_2,\nint dest_ip_3,\nint dest_ip_4,\nint port,\nint gps_port,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>dest_ip_1</code> The 1st byte represents the 1st section </li> <li><code>dest_ip_2</code> The 2nd byte represents the 2nd section </li> <li><code>dest_ip_3</code> The 3rd byte represents the 3rd section </li> <li><code>dest_ip_4</code> The 4th byte represents the 4th section </li> <li><code>port</code> LiDAR Destination Port </li> <li><code>gps_port</code> GPS Destination Port </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setdestinationip-33","title":"function SetDestinationIp [3/3]","text":"<p>Setting IP with PTC_COMMAND_SET_DESTINATION_IP. <pre><code>Status nebula::drivers::HesaiHwInterface::SetDestinationIp (\nint dest_ip_1,\nint dest_ip_2,\nint dest_ip_3,\nint dest_ip_4,\nint port,\nint gps_port,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dest_ip_1</code> The 1st byte represents the 1st section </li> <li><code>dest_ip_2</code> The 2nd byte represents the 2nd section </li> <li><code>dest_ip_3</code> The 3rd byte represents the 3rd section </li> <li><code>dest_ip_4</code> The 4th byte represents the 4th section </li> <li><code>port</code> LiDAR Destination Port </li> <li><code>gps_port</code> GPS Destination Port </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-16","title":"function SetLidarRange [1/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint method,\nstd::vector&lt; unsigned char &gt; data,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>method</code> Method </li> <li><code>data</code> Set data </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-26","title":"function SetLidarRange [2/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint method,\nstd::vector&lt; unsigned char &gt; data,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>method</code> Method </li> <li><code>data</code> Set data </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-36","title":"function SetLidarRange [3/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\nint method,\nstd::vector&lt; unsigned char &gt; data,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>method</code> Method </li> <li><code>data</code> Set data </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-46","title":"function SetLidarRange [4/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint start,\nint end,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>start</code> Start angle </li> <li><code>end</code> End angle </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-56","title":"function SetLidarRange [5/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint start,\nint end,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>start</code> Start angle </li> <li><code>end</code> End angle </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlidarrange-66","title":"function SetLidarRange [6/6]","text":"<p>Setting values with PTC_COMMAND_SET_LIDAR_RANGE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetLidarRange (\nint start,\nint end,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>start</code> Start angle </li> <li><code>end</code> End angle </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setlogger","title":"function SetLogger","text":"<p>Setting rclcpp::Logger. <pre><code>void nebula::drivers::HesaiHwInterface::SetLogger (\nstd::shared_ptr&lt; rclcpp::Logger &gt; node\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>node</code> Logger </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfig-13","title":"function SetPtpConfig [1/3]","text":"<p>Setting values with PTC_COMMAND_SET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::SetPtpConfig (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>profile</code> IEEE timing and synchronization standard </li> <li><code>domain</code> Domain attribute of the local clock </li> <li><code>network</code> Network transport type of 1588v2 </li> <li><code>logAnnounceInterval</code> Time interval between Announce messages, in units of log seconds (default: 1) </li> <li><code>logSyncInterval</code> Time interval between Sync messages, in units of log seconds (default: 1) </li> <li><code>logMinDelayReqInterval</code> Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0) </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfig-23","title":"function SetPtpConfig [2/3]","text":"<p>Setting values with PTC_COMMAND_SET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::SetPtpConfig (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>profile</code> IEEE timing and synchronization standard </li> <li><code>domain</code> Domain attribute of the local clock </li> <li><code>network</code> Network transport type of 1588v2 </li> <li><code>logAnnounceInterval</code> Time interval between Announce messages, in units of log seconds (default: 1) </li> <li><code>logSyncInterval</code> Time interval between Sync messages, in units of log seconds (default: 1) </li> <li><code>logMinDelayReqInterval</code> Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0) </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfig-33","title":"function SetPtpConfig [3/3]","text":"<p>Setting values with PTC_COMMAND_SET_PTP_CONFIG. <pre><code>Status nebula::drivers::HesaiHwInterface::SetPtpConfig (\nint profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>profile</code> IEEE timing and synchronization standard </li> <li><code>domain</code> Domain attribute of the local clock </li> <li><code>network</code> Network transport type of 1588v2 </li> <li><code>logAnnounceInterval</code> Time interval between Announce messages, in units of log seconds (default: 1) </li> <li><code>logSyncInterval</code> Time interval between Sync messages, in units of log seconds (default: 1) </li> <li><code>logMinDelayReqInterval</code> Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0) </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfigsynchttp-12","title":"function SetPtpConfigSyncHttp [1/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetPtpConfigSyncHttp (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setptpconfigsynchttp-22","title":"function SetPtpConfigSyncHttp [2/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetPtpConfigSyncHttp (\nint profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setreturnmode-13","title":"function SetReturnMode [1/3]","text":"<p>Setting mode with PTC_COMMAND_SET_RETURN_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetReturnMode (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint return_mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>return_mode</code> Return mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setreturnmode-23","title":"function SetReturnMode [2/3]","text":"<p>Setting mode with PTC_COMMAND_SET_RETURN_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetReturnMode (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint return_mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>return_mode</code> Return mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setreturnmode-33","title":"function SetReturnMode [3/3]","text":"<p>Setting mode with PTC_COMMAND_SET_RETURN_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetReturnMode (\nint return_mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> Return mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setrotdir-13","title":"function SetRotDir [1/3]","text":"<p>Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. <pre><code>Status nebula::drivers::HesaiHwInterface::SetRotDir (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>mode</code> Rotation of the motor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setrotdir-23","title":"function SetRotDir [2/3]","text":"<p>Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. <pre><code>Status nebula::drivers::HesaiHwInterface::SetRotDir (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>mode</code> Rotation of the motor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setrotdir-33","title":"function SetRotDir [3/3]","text":"<p>Setting values with PTC_COMMAND_SET_ROTATE_DIRECTION. <pre><code>Status nebula::drivers::HesaiHwInterface::SetRotDir (\nint mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>mode</code> Rotation of the motor </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Setting sensor configuration. <pre><code>virtual Status nebula::drivers::HesaiHwInterface::SetSensorConfiguration (\nstd::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinrate-13","title":"function SetSpinRate [1/3]","text":"<p>Setting value with PTC_COMMAND_SET_SPIN_RATE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSpinRate (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nuint16_t rpm,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>rpm</code> Spin rate </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinrate-23","title":"function SetSpinRate [2/3]","text":"<p>Setting value with PTC_COMMAND_SET_SPIN_RATE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSpinRate (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nuint16_t rpm,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>rpm</code> Spin rate </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinrate-33","title":"function SetSpinRate [3/3]","text":"<p>Setting value with PTC_COMMAND_SET_SPIN_RATE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSpinRate (\nuint16_t rpm,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> Spin rate </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinspeedasynchttp-12","title":"function SetSpinSpeedAsyncHttp [1/2]","text":"<p>Setting spin_speed via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSpinSpeedAsyncHttp (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nuint16_t rpm\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>rpm</code> spin_speed (300, 600, 1200) </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setspinspeedasynchttp-22","title":"function SetSpinSpeedAsyncHttp [2/2]","text":"<p>Setting spin_speed via HTTP API. <pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSpinSpeedAsyncHttp (\nuint16_t rpm\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> spin_speed (300, 600, 1200) </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setstandbymode-13","title":"function SetStandbyMode [1/3]","text":"<p>Setting mode with PTC_COMMAND_SET_STANDBY_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetStandbyMode (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint standby_mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>standby_mode</code> Standby mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setstandbymode-23","title":"function SetStandbyMode [2/3]","text":"<p>Setting mode with PTC_COMMAND_SET_STANDBY_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetStandbyMode (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint standby_mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>standby_mode</code> Standby mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setstandbymode-33","title":"function SetStandbyMode [3/3]","text":"<p>Setting mode with PTC_COMMAND_SET_STANDBY_MODE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetStandbyMode (\nint standby_mode,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>standby_mode</code> Standby mode </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncangle-13","title":"function SetSyncAngle [1/3]","text":"<p>Setting value with PTC_COMMAND_SET_SYNC_ANGLE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSyncAngle (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint sync_angle,\nint angle,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>sync_angle</code> Sync angle enable flag </li> <li><code>angle</code> Angle value </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncangle-23","title":"function SetSyncAngle [2/3]","text":"<p>Setting value with PTC_COMMAND_SET_SYNC_ANGLE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSyncAngle (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint sync_angle,\nint angle,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>sync_angle</code> Sync angle enable flag </li> <li><code>angle</code> Angle value </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncangle-33","title":"function SetSyncAngle [3/3]","text":"<p>Setting value with PTC_COMMAND_SET_SYNC_ANGLE. <pre><code>Status nebula::drivers::HesaiHwInterface::SetSyncAngle (\nint sync_angle,\nint angle,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sync_angle</code> Sync angle enable flag </li> <li><code>angle</code> Angle value </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncanglesynchttp-12","title":"function SetSyncAngleSyncHttp [1/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSyncAngleSyncHttp (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint enable,\nint angle\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-setsyncanglesynchttp-22","title":"function SetSyncAngleSyncHttp [2/2]","text":"<pre><code>HesaiStatus nebula::drivers::HesaiHwInterface::SetSyncAngleSyncHttp (\nint enable,\nint angle\n) </code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settargetmodel","title":"function SetTargetModel","text":"<p>Set target model number (for proper use of HTTP and TCP according to the support of the target model) <pre><code>void nebula::drivers::HesaiHwInterface::SetTargetModel (\nint model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model number </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settriggermethod-13","title":"function SetTriggerMethod [1/3]","text":"<p>Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. <pre><code>Status nebula::drivers::HesaiHwInterface::SetTriggerMethod (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nint trigger_method,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>trigger_method</code> Trigger method </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settriggermethod-23","title":"function SetTriggerMethod [2/3]","text":"<p>Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. <pre><code>Status nebula::drivers::HesaiHwInterface::SetTriggerMethod (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nint trigger_method,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> <li><code>trigger_method</code> Trigger method </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-settriggermethod-33","title":"function SetTriggerMethod [3/3]","text":"<p>Setting mode with PTC_COMMAND_SET_TRIGGER_METHOD. <pre><code>Status nebula::drivers::HesaiHwInterface::SetTriggerMethod (\nint trigger_method,\nbool with_run=true\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>trigger_method</code> Trigger method </li> <li><code>with_run</code> Automatically executes run() of TcpDriver </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpgetlidarmonitor-12","title":"function UseHttpGetLidarMonitor [1/2]","text":"<p>Whether to use HTTP for getting LidarMonitor. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpGetLidarMonitor (\nint model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model number </li> </ul> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpgetlidarmonitor-22","title":"function UseHttpGetLidarMonitor [2/2]","text":"<p>Whether to use HTTP for getting LidarMonitor. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpGetLidarMonitor () </code></pre></p> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpsetspinrate-12","title":"function UseHttpSetSpinRate [1/2]","text":"<p>Whether to use HTTP for setting SpinRate. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpSetSpinRate (\nint model\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>model</code> Model number </li> </ul> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-usehttpsetspinrate-22","title":"function UseHttpSetSpinRate [2/2]","text":"<p>Whether to use HTTP for setting SpinRate. <pre><code>bool nebula::drivers::HesaiHwInterface::UseHttpSetSpinRate () </code></pre></p> <p>Returns:</p> <p>Use HTTP </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-15","title":"function syncGetLidarCalibration [1/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-25","title":"function syncGetLidarCalibration [2/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver,\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>bytes_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-35","title":"function syncGetLidarCalibration [3/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver &gt; target_tcp_driver\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-45","title":"function syncGetLidarCalibration [4/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx,\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>ctx</code> IO Context used </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibration-55","title":"function syncGetLidarCalibration [5/5]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibration (\nstd::shared_ptr&lt; boost::asio::io_context &gt; ctx\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> callback </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibrationfromsensor-13","title":"function syncGetLidarCalibrationFromSensor [1/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibrationFromSensor (\nstd::function&lt; void(const std::vector&lt; uint8_t &gt; &amp;received_bytes)&gt; bytes_callback\n) </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibrationfromsensor-23","title":"function syncGetLidarCalibrationFromSensor [2/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibrationFromSensor (\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>bytes_callback</code> callback </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1HesaiHwInterface/#function-syncgetlidarcalibrationfromsensor-33","title":"function syncGetLidarCalibrationFromSensor [3/3]","text":"<p>Getting data with PTC_COMMAND_GET_LIDAR_CALIBRATION (sync) <pre><code>Status nebula::drivers::HesaiHwInterface::syncGetLidarCalibrationFromSensor () </code></pre></p> <p>Parameters:</p> <ul> <li><code>target_tcp_driver</code> TcpDriver used </li> <li><code>str_callback</code> callback </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/","title":"Class nebula::drivers::NebulaHwInterfaceBase","text":"<p>ClassList &gt; nebula &gt; drivers &gt; NebulaHwInterfaceBase</p> <p>Base class for hardware interface of each LiDAR. </p> <ul> <li><code>#include &lt;nebula_hw_interface_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::drivers::HesaiHwInterface,  nebula::drivers::VelodyneHwInterface</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#public-functions","title":"Public Functions","text":"Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#protected-functions","title":"Protected Functions","text":"Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Virtual function for starting the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Virtual function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Virtual function for printing calibration configuration. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration (\nCalibrationConfigurationBase &amp; calibration_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Virtual function for printing sensor configuration. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration (\nSensorConfigurationBase &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-nebulahwinterfacebase-13","title":"function NebulaHwInterfaceBase [1/3]","text":"<pre><code>nebula::drivers::NebulaHwInterfaceBase::NebulaHwInterfaceBase (\nNebulaHwInterfaceBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-nebulahwinterfacebase-23","title":"function NebulaHwInterfaceBase [2/3]","text":"<pre><code>nebula::drivers::NebulaHwInterfaceBase::NebulaHwInterfaceBase (\nconst NebulaHwInterfaceBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-nebulahwinterfacebase-33","title":"function NebulaHwInterfaceBase [3/3]","text":"<pre><code>nebula::drivers::NebulaHwInterfaceBase::NebulaHwInterfaceBase () = default\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Virtual function for setting sensor configuration. <pre><code>virtual Status nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration (\nstd::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaHwInterfaceBase &amp; nebula::drivers::NebulaHwInterfaceBase::operator= (\nNebulaHwInterfaceBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaHwInterfaceBase &amp; nebula::drivers::NebulaHwInterfaceBase::operator= (\nconst NebulaHwInterfaceBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1NebulaHwInterfaceBase/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<pre><code>virtual void nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback (\nconst std::vector&lt; uint8_t &gt; &amp; buffer\n) = 0\n</code></pre> <p>Callback function to receive the Cloud Packet data from the UDP Driver </p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Returns:</p> <p>Status::OK if no error occurred. </p> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/","title":"Class nebula::drivers::VelodyneHwInterface","text":"<p>ClassList &gt; nebula &gt; drivers &gt; VelodyneHwInterface</p> <p>Hardware interface of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_hw_interface.hpp&gt;</code></li> </ul> <p>Inherits the following classes: nebula::drivers::NebulaHwInterfaceBase</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#public-functions","title":"Public Functions","text":"Type Name VelodyneStatus CheckAndSetConfigBySnapshotAsync () Checking the current settings and changing the difference point. virtual Status CloudInterfaceStart () Starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () Function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) Printing calibration configuration. std::string GetDiag () Getting diagnostic information from the sensor (sync) VelodyneStatus GetDiagAsync (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting diagnostic information from the sensor (async) VelodyneStatus GetDiagAsync () Getting diagnostic information from the sensor (async) virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) Printing sensor configuration. std::string GetSnapshot () Getting current sensor configuration and status data (sync) VelodyneStatus GetSnapshotAsync (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting current sensor configuration and status data (async) VelodyneStatus GetSnapshotAsync () Getting current sensor configuration and status data (async) std::string GetStatus () Getting the current operational state and parameters of the sensor (sync) VelodyneStatus GetStatusAsync (std::function&lt; void(const std::string &amp;str)&gt; str_callback) Getting the current operational state and parameters of the sensor (async) VelodyneStatus GetStatusAsync () Getting the current operational state and parameters of the sensor (async) VelodyneStatus InitHttpClient () Initializing HTTP client (sync) VelodyneStatus InitHttpClientAsync () Initializing HTTP client (async) Status InitializeSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Initializing sensor configuration. VelodyneStatus LaserOff () Turn laser state off (sync) VelodyneStatus LaserOffAsync () Turn laser state off (async) VelodyneStatus LaserOn () Turn laser state on (sync) VelodyneStatus LaserOnAsync () Turn laser state on (async) VelodyneStatus LaserOnOff (bool on) Turn laser state on/off (sync) VelodyneStatus LaserOnOffAsync (bool on) Turn laser state on/off (async) boost::property_tree::ptree ParseJson (const std::string &amp; str) Parsing JSON string to property_tree. virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) Callback function to receive the Cloud Packet data from the UDP Driver. Status RegisterScanCallback (std::function&lt; void(std::unique_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt;)&gt; scan_callback) Registering callback for PandarScan. VelodyneStatus ResetSystem () Resets the sensor (sync) VelodyneStatus ResetSystemAsync () Resets the sensor (async) VelodyneStatus SaveConfig () Save Configuration to the LiDAR memory (sync) VelodyneStatus SaveConfigAsync () Save Configuration to the LiDAR memory (async) VelodyneStatus SetFovEnd (uint16_t fov_end) Setting Field of View End (sync) VelodyneStatus SetFovEndAsync (uint16_t fov_end) Setting Field of View End (async) VelodyneStatus SetFovStart (uint16_t fov_start) Setting Field of View Start (sync) VelodyneStatus SetFovStartAsync (uint16_t fov_start) Setting Field of View Start (async) VelodyneStatus SetHostAddr (std::string addr) Setting host (destination) IP address (sync) VelodyneStatus SetHostAddrAsync (std::string addr) Setting host (destination) IP address (async) VelodyneStatus SetHostDport (uint16_t dport) Setting host (destination) data port (sync) VelodyneStatus SetHostDportAsync (uint16_t dport) Setting host (destination) data port (async) VelodyneStatus SetHostTport (uint16_t tport) Setting host (destination) telemetry port (sync) VelodyneStatus SetHostTportAsync (uint16_t tport) Setting host (destination) telemetry port (async) void SetLogger (std::shared_ptr&lt; rclcpp::Logger &gt; node) Setting rclcpp::Logger. VelodyneStatus SetNetAddr (std::string addr) Setting network (sensor) IP address (sync) VelodyneStatus SetNetAddrAsync (std::string addr) Setting network (sensor) IP address (async) VelodyneStatus SetNetDhcp (bool use_dhcp) This determines if the sensor is to rely on a DHCP server for its IP address (sync) VelodyneStatus SetNetDhcpAsync (bool use_dhcp) This determines if the sensor is to rely on a DHCP server for its IP address (async) VelodyneStatus SetNetGateway (std::string gateway) Setting the gateway address of the sensor (sync) VelodyneStatus SetNetGatewayAsync (std::string gateway) Setting the gateway address of the sensor (async) VelodyneStatus SetNetMask (std::string mask) Setting the network mask of the sensor (sync) VelodyneStatus SetNetMaskAsync (std::string mask) Setting the network mask of the sensor (async) VelodyneStatus SetReturnType (ReturnMode return_mode) Setting Return Type (sync) VelodyneStatus SetReturnTypeAsync (ReturnMode return_mode) Setting Return Type (async) VelodyneStatus SetRpm (uint16_t rpm) Setting Motor RPM (sync) VelodyneStatus SetRpmAsync (uint16_t rpm) Setting Motor RPM (async) virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) Setting sensor configuration with InitializeSensorConfiguration &amp; CheckAndSetConfigBySnapshotAsync. VelodyneHwInterface () Constructor."},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#public-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Public Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual Status CloudInterfaceStart () = 0Virtual function for starting the interface that handles UDP streams. virtual Status CloudInterfaceStop () = 0Virtual function for stopping the interface that handles UDP streams. virtual Status GetCalibrationConfiguration (CalibrationConfigurationBase &amp; calibration_configuration) = 0Virtual function for printing calibration configuration. virtual Status GetSensorConfiguration (SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for printing sensor configuration. NebulaHwInterfaceBase (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase (const NebulaHwInterfaceBase &amp; c) = delete NebulaHwInterfaceBase () = default virtual Status SetSensorConfiguration (std::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration) = 0Virtual function for setting sensor configuration. NebulaHwInterfaceBase &amp; operator= (NebulaHwInterfaceBase &amp;&amp; c) = delete NebulaHwInterfaceBase &amp; operator= (const NebulaHwInterfaceBase &amp; c) = delete"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#protected-functions-inherited-from-nebuladriversnebulahwinterfacebase","title":"Protected Functions inherited from nebula::drivers::NebulaHwInterfaceBase","text":"<p>See nebula::drivers::NebulaHwInterfaceBase</p> Type Name virtual void ReceiveCloudPacketCallback (const std::vector&lt; uint8_t &gt; &amp; buffer) = 0"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-checkandsetconfigbysnapshotasync","title":"function CheckAndSetConfigBySnapshotAsync","text":"<p>Checking the current settings and changing the difference point. <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::CheckAndSetConfigBySnapshotAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-cloudinterfacestart","title":"function CloudInterfaceStart","text":"<p>Starting the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::CloudInterfaceStart () </code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStart</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-cloudinterfacestop","title":"function CloudInterfaceStop","text":"<p>Function for stopping the interface that handles UDP streams. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::CloudInterfaceStop () </code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::CloudInterfaceStop</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getcalibrationconfiguration","title":"function GetCalibrationConfiguration","text":"<p>Printing calibration configuration. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::GetCalibrationConfiguration (\nCalibrationConfigurationBase &amp; calibration_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>calibration_configuration</code> CalibrationConfiguration for the checking </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetCalibrationConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getdiag","title":"function GetDiag","text":"<p>Getting diagnostic information from the sensor (sync) <pre><code>std::string nebula::drivers::VelodyneHwInterface::GetDiag () </code></pre></p> <p>Returns:</p> <p>Resulting JSON string </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getdiagasync-12","title":"function GetDiagAsync [1/2]","text":"<p>Getting diagnostic information from the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetDiagAsync (\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received JSON string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getdiagasync-22","title":"function GetDiagAsync [2/2]","text":"<p>Getting diagnostic information from the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetDiagAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsensorconfiguration","title":"function GetSensorConfiguration","text":"<p>Printing sensor configuration. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::GetSensorConfiguration (\nSensorConfigurationBase &amp; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::GetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsnapshot","title":"function GetSnapshot","text":"<p>Getting current sensor configuration and status data (sync) <pre><code>std::string nebula::drivers::VelodyneHwInterface::GetSnapshot () </code></pre></p> <p>Returns:</p> <p>Resulting JSON string </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsnapshotasync-12","title":"function GetSnapshotAsync [1/2]","text":"<p>Getting current sensor configuration and status data (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetSnapshotAsync (\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received JSON string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getsnapshotasync-22","title":"function GetSnapshotAsync [2/2]","text":"<p>Getting current sensor configuration and status data (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetSnapshotAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getstatus","title":"function GetStatus","text":"<p>Getting the current operational state and parameters of the sensor (sync) <pre><code>std::string nebula::drivers::VelodyneHwInterface::GetStatus () </code></pre></p> <p>Returns:</p> <p>Resulting JSON string </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getstatusasync-12","title":"function GetStatusAsync [1/2]","text":"<p>Getting the current operational state and parameters of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetStatusAsync (\nstd::function&lt; void(const std::string &amp;str)&gt; str_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str_callback</code> Callback function for received JSON string </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-getstatusasync-22","title":"function GetStatusAsync [2/2]","text":"<p>Getting the current operational state and parameters of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::GetStatusAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-inithttpclient","title":"function InitHttpClient","text":"<p>Initializing HTTP client (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::InitHttpClient () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-inithttpclientasync","title":"function InitHttpClientAsync","text":"<p>Initializing HTTP client (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::InitHttpClientAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-initializesensorconfiguration","title":"function InitializeSensorConfiguration","text":"<p>Initializing sensor configuration. <pre><code>Status nebula::drivers::VelodyneHwInterface::InitializeSensorConfiguration (\nstd::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseroff","title":"function LaserOff","text":"<p>Turn laser state off (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOff () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseroffasync","title":"function LaserOffAsync","text":"<p>Turn laser state off (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOffAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseron","title":"function LaserOn","text":"<p>Turn laser state on (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOn () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseronasync","title":"function LaserOnAsync","text":"<p>Turn laser state on (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOnAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseronoff","title":"function LaserOnOff","text":"<p>Turn laser state on/off (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOnOff (\nbool on\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> is ON </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-laseronoffasync","title":"function LaserOnOffAsync","text":"<p>Turn laser state on/off (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::LaserOnOffAsync (\nbool on\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>on</code> is ON </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-parsejson","title":"function ParseJson","text":"<p>Parsing JSON string to property_tree. <pre><code>boost::property_tree::ptree nebula::drivers::VelodyneHwInterface::ParseJson (\nconst std::string &amp; str\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>str</code> JSON string </li> </ul> <p>Returns:</p> <p>property_tree </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-receivecloudpacketcallback","title":"function ReceiveCloudPacketCallback","text":"<p>Callback function to receive the Cloud Packet data from the UDP Driver. <pre><code>virtual void nebula::drivers::VelodyneHwInterface::ReceiveCloudPacketCallback (\nconst std::vector&lt; uint8_t &gt; &amp; buffer\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Buffer containing the data received from the UDP socket </li> </ul> <p>Implements nebula::drivers::NebulaHwInterfaceBase::ReceiveCloudPacketCallback</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-registerscancallback","title":"function RegisterScanCallback","text":"<p>Registering callback for PandarScan. <pre><code>Status nebula::drivers::VelodyneHwInterface::RegisterScanCallback (\nstd::function&lt; void(std::unique_ptr&lt; velodyne_msgs::msg::VelodyneScan &gt;)&gt; scan_callback\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_callback</code> Callback function </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-resetsystem","title":"function ResetSystem","text":"<p>Resets the sensor (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::ResetSystem () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-resetsystemasync","title":"function ResetSystemAsync","text":"<p>Resets the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::ResetSystemAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-saveconfig","title":"function SaveConfig","text":"<p>Save Configuration to the LiDAR memory (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SaveConfig () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-saveconfigasync","title":"function SaveConfigAsync","text":"<p>Save Configuration to the LiDAR memory (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SaveConfigAsync () </code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovend","title":"function SetFovEnd","text":"<p>Setting Field of View End (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovEnd (\nuint16_t fov_end\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_end</code> FOV end </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovendasync","title":"function SetFovEndAsync","text":"<p>Setting Field of View End (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovEndAsync (\nuint16_t fov_end\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_end</code> FOV end </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovstart","title":"function SetFovStart","text":"<p>Setting Field of View Start (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovStart (\nuint16_t fov_start\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_start</code> FOV start </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setfovstartasync","title":"function SetFovStartAsync","text":"<p>Setting Field of View Start (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetFovStartAsync (\nuint16_t fov_start\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>fov_start</code> FOV start </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostaddr","title":"function SetHostAddr","text":"<p>Setting host (destination) IP address (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostAddr (\nstd::string addr\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> destination IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostaddrasync","title":"function SetHostAddrAsync","text":"<p>Setting host (destination) IP address (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostAddrAsync (\nstd::string addr\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> destination IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostdport","title":"function SetHostDport","text":"<p>Setting host (destination) data port (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostDport (\nuint16_t dport\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dport</code> destination data port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethostdportasync","title":"function SetHostDportAsync","text":"<p>Setting host (destination) data port (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostDportAsync (\nuint16_t dport\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>dport</code> destination data port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethosttport","title":"function SetHostTport","text":"<p>Setting host (destination) telemetry port (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostTport (\nuint16_t tport\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tport</code> destination telemetry port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-sethosttportasync","title":"function SetHostTportAsync","text":"<p>Setting host (destination) telemetry port (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetHostTportAsync (\nuint16_t tport\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>tport</code> destination telemetry port </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setlogger","title":"function SetLogger","text":"<p>Setting rclcpp::Logger. <pre><code>void nebula::drivers::VelodyneHwInterface::SetLogger (\nstd::shared_ptr&lt; rclcpp::Logger &gt; node\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>node</code> Logger </li> </ul>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetaddr","title":"function SetNetAddr","text":"<p>Setting network (sensor) IP address (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetAddr (\nstd::string addr\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> sensor IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetaddrasync","title":"function SetNetAddrAsync","text":"<p>Setting network (sensor) IP address (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetAddrAsync (\nstd::string addr\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>addr</code> sensor IP address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetdhcp","title":"function SetNetDhcp","text":"<p>This determines if the sensor is to rely on a DHCP server for its IP address (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetDhcp (\nbool use_dhcp\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>use_dhcp</code> DHCP on </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetdhcpasync","title":"function SetNetDhcpAsync","text":"<p>This determines if the sensor is to rely on a DHCP server for its IP address (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetDhcpAsync (\nbool use_dhcp\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>use_dhcp</code> DHCP on </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetgateway","title":"function SetNetGateway","text":"<p>Setting the gateway address of the sensor (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetGateway (\nstd::string gateway\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>gateway</code> Gateway address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetgatewayasync","title":"function SetNetGatewayAsync","text":"<p>Setting the gateway address of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetGatewayAsync (\nstd::string gateway\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>gateway</code> Gateway address </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetmask","title":"function SetNetMask","text":"<p>Setting the network mask of the sensor (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetMask (\nstd::string mask\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>mask</code> Network mask </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setnetmaskasync","title":"function SetNetMaskAsync","text":"<p>Setting the network mask of the sensor (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetNetMaskAsync (\nstd::string mask\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>mask</code> Network mask </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setreturntype","title":"function SetReturnType","text":"<p>Setting Return Type (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetReturnType (\nReturnMode return_mode\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> ReturnMode </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setreturntypeasync","title":"function SetReturnTypeAsync","text":"<p>Setting Return Type (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetReturnTypeAsync (\nReturnMode return_mode\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>return_mode</code> ReturnMode </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setrpm","title":"function SetRpm","text":"<p>Setting Motor RPM (sync) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetRpm (\nuint16_t rpm\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> the RPM of the motor </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setrpmasync","title":"function SetRpmAsync","text":"<p>Setting Motor RPM (async) <pre><code>VelodyneStatus nebula::drivers::VelodyneHwInterface::SetRpmAsync (\nuint16_t rpm\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>rpm</code> the RPM of the motor </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-setsensorconfiguration","title":"function SetSensorConfiguration","text":"<p>Setting sensor configuration with InitializeSensorConfiguration &amp; CheckAndSetConfigBySnapshotAsync. <pre><code>virtual Status nebula::drivers::VelodyneHwInterface::SetSensorConfiguration (\nstd::shared_ptr&lt; SensorConfigurationBase &gt; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this interface </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::drivers::NebulaHwInterfaceBase::SetSensorConfiguration</p>"},{"location":"nebula_hw_interfaces/classnebula_1_1drivers_1_1VelodyneHwInterface/#function-velodynehwinterface","title":"function VelodyneHwInterface","text":"<pre><code>nebula::drivers::VelodyneHwInterface::VelodyneHwInterface () </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/dir_cdea7329b6b65bb9fca0dec0063a1667/","title":"Dir nebula_hw_interfaces","text":"<p>FileList &gt; nebula_hw_interfaces</p>"},{"location":"nebula_hw_interfaces/dir_cdea7329b6b65bb9fca0dec0063a1667/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/</code></p>"},{"location":"nebula_hw_interfaces/dir_46bad66cb8ff2bf21ac1466c24078895/","title":"Dir nebula_hw_interfaces/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_hw_interfaces/dir_46bad66cb8ff2bf21ac1466c24078895/#directories","title":"Directories","text":"Type Name dir nebula_hw_interfaces <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/</code></p>"},{"location":"nebula_hw_interfaces/dir_753169d095bbb8c16a53041d0c804bb3/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces</p>"},{"location":"nebula_hw_interfaces/dir_753169d095bbb8c16a53041d0c804bb3/#directories","title":"Directories","text":"Type Name dir nebula_hw_interfaces_common dir nebula_hw_interfaces_hesai dir nebula_hw_interfaces_velodyne <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/</code></p>"},{"location":"nebula_hw_interfaces/dir_7a9d3e2469d6635a12ef6571522c310a/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_common</p>"},{"location":"nebula_hw_interfaces/dir_7a9d3e2469d6635a12ef6571522c310a/#files","title":"Files","text":"Type Name file nebula_hw_interface_base.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/</code></p>"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp/","title":"File nebula_hw_interface_base.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_common &gt; nebula_hw_interface_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp</code></p>"},{"location":"nebula_hw_interfaces/nebula__hw__interface__base_8hpp_source/","title":"File nebula_hw_interface_base.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_common &gt; nebula_hw_interface_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HW_INTERFACE_BASE_H\n#define NEBULA_HW_INTERFACE_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"boost_udp_driver/udp_driver.hpp\"\n\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass NebulaHwInterfaceBase\n{\nprotected:\nvirtual void ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) = 0;\n//  virtual Status RegisterScanCallback(\n//    std::function&lt;void(std::unique_ptr&lt;std::vector&lt;std::vector&lt;uint8_t&gt;&gt;&gt;)&gt; scan_callback) = 0;\n\npublic:\nNebulaHwInterfaceBase(NebulaHwInterfaceBase &amp;&amp; c) = delete;\nNebulaHwInterfaceBase &amp; operator=(NebulaHwInterfaceBase &amp;&amp; c) = delete;\nNebulaHwInterfaceBase(const NebulaHwInterfaceBase &amp; c) = delete;\nNebulaHwInterfaceBase &amp; operator=(const NebulaHwInterfaceBase &amp; c) = delete;\n\nNebulaHwInterfaceBase() = default;\n\nvirtual Status CloudInterfaceStart() = 0;\n\nvirtual Status CloudInterfaceStop() = 0;\n// You may want to also implement GpsInterfaceStart() and ReceiveGpsCallback, but that is sensor\n// specific.\n\nvirtual Status SetSensorConfiguration(\nstd::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) = 0;\n\nvirtual Status GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) = 0;\n\nvirtual Status GetCalibrationConfiguration(\nCalibrationConfigurationBase &amp; calibration_configuration) = 0;\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HW_INTERFACE_BASE_H\n</code></pre>"},{"location":"nebula_hw_interfaces/dir_97916b007af0a552f010ef776d20ae4f/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai</p>"},{"location":"nebula_hw_interfaces/dir_97916b007af0a552f010ef776d20ae4f/#files","title":"Files","text":"Type Name file hesai_cmd_response.hpp file hesai_hw_interface.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/</code></p>"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp/","title":"File hesai_cmd_response.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_cmd_response.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/algorithm/string/join.hpp&gt;</code></li> <li><code>#include &lt;boost/format.hpp&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp/#classes","title":"Classes","text":"Type Name struct HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO struct HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO struct HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR struct HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE struct HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS struct HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG struct HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. struct HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp</code></p>"},{"location":"nebula_hw_interfaces/hesai__cmd__response_8hpp_source/","title":"File hesai_cmd_response.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_cmd_response.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef HESAI_CMD_RESPONSE_HPP\n#define HESAI_CMD_RESPONSE_HPP\n\n#include &lt;boost/algorithm/string/join.hpp&gt;\n#include &lt;boost/format.hpp&gt;\n\n#include &lt;ostream&gt;\n\nnamespace nebula\n{\nstruct HesaiPtpDiagStatus\n{\nlong long master_offset;\nint ptp_state;\nint elapsed_millisec;\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagStatus const &amp; arg)\n{\nos &lt;&lt; \"master_offset: \" &lt;&lt; arg.master_offset;\nos &lt;&lt; \", \";\nos &lt;&lt; \"ptp_state: \" &lt;&lt; arg.ptp_state;\nos &lt;&lt; \", \";\nos &lt;&lt; \"elapsed_millisec: \" &lt;&lt; arg.elapsed_millisec;\n\nreturn os;\n}\n};\n\nstruct HesaiPtpDiagPort\n{\nstd::vector&lt;char&gt; portIdentity = std::vector&lt;char&gt;(10);\nint portState;\nint logMinDelayReqInterval;\nlong long peerMeanPathDelay;\nint logAnnounceInterval;\nint announceReceiptTimeout;\nint logSyncInterval;\nint delayMechanism;\nint logMinPdelayReqInterval;\nint versionNumber;\n\nHesaiPtpDiagPort() {}\nHesaiPtpDiagPort(const HesaiPtpDiagPort &amp; arg)\n{\nstd::copy(arg.portIdentity.begin(), arg.portIdentity.end(), portIdentity.begin());\nportState = arg.portState;\nlogMinDelayReqInterval = arg.logMinDelayReqInterval;\npeerMeanPathDelay = arg.peerMeanPathDelay;\nlogAnnounceInterval = arg.logAnnounceInterval;\nannounceReceiptTimeout = arg.announceReceiptTimeout;\nlogSyncInterval = arg.logSyncInterval;\ndelayMechanism = arg.delayMechanism;\nlogMinPdelayReqInterval = arg.logMinPdelayReqInterval;\nversionNumber = arg.versionNumber;\n}\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagPort const &amp; arg)\n{\nos &lt;&lt; \"portIdentity: \" &lt;&lt; std::string(arg.portIdentity.begin(), arg.portIdentity.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"portState: \" &lt;&lt; arg.portState;\nos &lt;&lt; \", \";\nos &lt;&lt; \"logMinDelayReqInterval: \" &lt;&lt; arg.logMinDelayReqInterval;\nos &lt;&lt; \", \";\nos &lt;&lt; \"peerMeanPathDelay: \" &lt;&lt; arg.peerMeanPathDelay;\nos &lt;&lt; \", \";\nos &lt;&lt; \"logAnnounceInterval: \" &lt;&lt; arg.logAnnounceInterval;\nos &lt;&lt; \", \";\nos &lt;&lt; \"announceReceiptTimeout: \" &lt;&lt; arg.announceReceiptTimeout;\nos &lt;&lt; \", \";\nos &lt;&lt; \"logSyncInterval: \" &lt;&lt; arg.logSyncInterval;\nos &lt;&lt; \", \";\nos &lt;&lt; \"delayMechanism: \" &lt;&lt; arg.delayMechanism;\nos &lt;&lt; \", \";\nos &lt;&lt; \"logMinPdelayReqInterval: \" &lt;&lt; arg.logMinPdelayReqInterval;\nos &lt;&lt; \", \";\nos &lt;&lt; \"versionNumber: \" &lt;&lt; arg.versionNumber;\n\nreturn os;\n}\n};\n\nstruct HesaiPtpDiagTime\n{\nlong long master_offset;\nlong long ingress_time;\nint cumulativeScaledRateOffset;\nint scaledLastGmPhaseChange;\nint gmTimeBaseIndicator;\nstd::vector&lt;char&gt; lastGmPhaseChange = std::vector&lt;char&gt;(12);\nint gmPresent;\nlong long gmIdentity;\n\nHesaiPtpDiagTime() {}\nHesaiPtpDiagTime(const HesaiPtpDiagTime &amp; arg)\n{\nmaster_offset = arg.master_offset;\ningress_time = arg.ingress_time;\ncumulativeScaledRateOffset = arg.cumulativeScaledRateOffset;\nscaledLastGmPhaseChange = arg.scaledLastGmPhaseChange;\ngmTimeBaseIndicator = arg.gmTimeBaseIndicator;\nstd::copy(\narg.lastGmPhaseChange.begin(), arg.lastGmPhaseChange.end(), lastGmPhaseChange.begin());\ngmPresent = arg.gmPresent;\ngmIdentity = arg.gmIdentity;\n}\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagTime const &amp; arg)\n{\nos &lt;&lt; \"master_offset: \" &lt;&lt; arg.master_offset;\nos &lt;&lt; \", \";\nos &lt;&lt; \"ingress_time: \" &lt;&lt; arg.ingress_time;\nos &lt;&lt; \", \";\nos &lt;&lt; \"cumulativeScaledRateOffset: \" &lt;&lt; arg.cumulativeScaledRateOffset;\nos &lt;&lt; \", \";\nos &lt;&lt; \"scaledLastGmPhaseChange: \" &lt;&lt; arg.scaledLastGmPhaseChange;\nos &lt;&lt; \", \";\nos &lt;&lt; \"gmTimeBaseIndicator: \" &lt;&lt; arg.gmTimeBaseIndicator;\nos &lt;&lt; \", \";\nos &lt;&lt; \"lastGmPhaseChange: \"\n&lt;&lt; std::string(arg.lastGmPhaseChange.begin(), arg.lastGmPhaseChange.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"gmPresent: \" &lt;&lt; arg.gmPresent;\nos &lt;&lt; \", \";\nos &lt;&lt; \"gmIdentity: \" &lt;&lt; arg.gmIdentity;\n\nreturn os;\n}\n};\n\nstruct HesaiPtpDiagGrandmaster\n{\nint clockQuality;\nint utc_offset;\nint time_flags;\nint time_source;\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpDiagGrandmaster const &amp; arg)\n{\nos &lt;&lt; \"clockQuality: \" &lt;&lt; arg.clockQuality;\nos &lt;&lt; \", \";\nos &lt;&lt; \"utc_offset: \" &lt;&lt; arg.utc_offset;\nos &lt;&lt; \", \";\nos &lt;&lt; \"time_flags: \" &lt;&lt; arg.time_flags;\nos &lt;&lt; \", \";\nos &lt;&lt; \"time_source: \" &lt;&lt; arg.time_source;\n\nreturn os;\n}\n};\n\nstruct HesaiInventory\n{\nstd::vector&lt;char&gt; sn = std::vector&lt;char&gt;(18);\nstd::vector&lt;char&gt; date_of_manufacture = std::vector&lt;char&gt;(16);\nstd::vector&lt;char&gt; mac = std::vector&lt;char&gt;(6);\nstd::vector&lt;char&gt; sw_ver = std::vector&lt;char&gt;(16);\nstd::vector&lt;char&gt; hw_ver = std::vector&lt;char&gt;(16);\nstd::vector&lt;char&gt; control_fw_ver = std::vector&lt;char&gt;(16);\nstd::vector&lt;char&gt; sensor_fw_ver = std::vector&lt;char&gt;(16);\nint angle_offset;\nint model;\nint motor_type;\nint num_of_lines;\nstd::vector&lt;unsigned char&gt; reserved = std::vector&lt;unsigned char&gt;(11);\n\nHesaiInventory() {}\nHesaiInventory(const HesaiInventory &amp; arg)\n{\nstd::copy(arg.sn.begin(), arg.sn.end(), sn.begin());\nstd::copy(\narg.date_of_manufacture.begin(), arg.date_of_manufacture.end(), date_of_manufacture.begin());\nstd::copy(arg.mac.begin(), arg.mac.end(), mac.begin());\nstd::copy(arg.sw_ver.begin(), arg.sw_ver.end(), sw_ver.begin());\nstd::copy(arg.hw_ver.begin(), arg.hw_ver.end(), hw_ver.begin());\nstd::copy(arg.control_fw_ver.begin(), arg.control_fw_ver.end(), control_fw_ver.begin());\nstd::copy(arg.sensor_fw_ver.begin(), arg.sensor_fw_ver.end(), sensor_fw_ver.begin());\nangle_offset = arg.angle_offset;\nmodel = arg.model;\nmotor_type = arg.motor_type;\nnum_of_lines = arg.num_of_lines;\nstd::copy(arg.reserved.begin(), arg.reserved.end(), reserved.begin());\n}\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiInventory const &amp; arg)\n{\nos &lt;&lt; \"sn: \" &lt;&lt; std::string(arg.sn.begin(), arg.sn.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"date_of_manufacture: \"\n&lt;&lt; std::string(arg.date_of_manufacture.begin(), arg.date_of_manufacture.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"mac: \";\nstd::stringstream ss;\nfor (long unsigned int i = 0; i &lt; arg.mac.size() - 1; i++) {\nss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; (static_cast&lt;int&gt;(arg.mac[i]) &amp; 0xff)\n&lt;&lt; \":\";\n}\nss &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2)\n&lt;&lt; (static_cast&lt;int&gt;(arg.mac[arg.mac.size() - 1]) &amp; 0xff);\nos &lt;&lt; ss.str();\nos &lt;&lt; \", \";\nos &lt;&lt; \"sw_ver: \" &lt;&lt; std::string(arg.sw_ver.begin(), arg.sw_ver.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"hw_ver: \" &lt;&lt; std::string(arg.hw_ver.begin(), arg.hw_ver.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"control_fw_ver: \" &lt;&lt; std::string(arg.control_fw_ver.begin(), arg.control_fw_ver.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"sensor_fw_ver: \" &lt;&lt; std::string(arg.sensor_fw_ver.begin(), arg.sensor_fw_ver.end());\nos &lt;&lt; \", \";\nos &lt;&lt; \"angle_offset: \" &lt;&lt; arg.angle_offset;\nos &lt;&lt; \", \";\nos &lt;&lt; \"model: \" &lt;&lt; arg.model;\nos &lt;&lt; \", \";\nos &lt;&lt; \"motor_type: \" &lt;&lt; arg.motor_type;\nos &lt;&lt; \", \";\nos &lt;&lt; \"num_of_lines: \" &lt;&lt; arg.num_of_lines;\nos &lt;&lt; \", \";\n//      os &lt;&lt; \"reserved: \" &lt;&lt; boost::algorithm::join(arg.reserved, \",\");\nos &lt;&lt; \"reserved: \";\nfor (long unsigned int i = 0; i &lt; arg.reserved.size() - 1; i++) {\nos &lt;&lt; arg.reserved[i] &lt;&lt; \",\";\n}\nos &lt;&lt; arg.reserved[arg.reserved.size() - 1];\n\nreturn os;\n}\n\nstd::string get_str_model()\n{\nswitch (model) {\ncase 0:\nreturn \"Pandar40P\";\nbreak;\ncase 2:\nreturn \"Pandar64\";\nbreak;\ncase 3:\nreturn \"Pandar128\";\nbreak;\ncase 15:\nreturn \"PandarQT\";\nbreak;\ncase 17:\nreturn \"Pandar40M\";\nbreak;\ncase 25:\nreturn \"PandarXT32\";\nbreak;\ncase 26:\nreturn \"PandarXT16\";\nbreak;\ncase 32:\nreturn \"QT128C2X\";\nbreak;\ncase 38:\nreturn \"PandarXT32M\";\nbreak;\ncase 48:\nreturn \"PandarAT128\";\nbreak;\ndefault:\nreturn \"Unknown(\" + std::to_string(model) + \")\";\nbreak;\n}\n}\n};\n\nstruct HesaiConfig\n{\nint ipaddr[4];\nint mask[4];\nint gateway[4];\nint dest_ipaddr[4];\nint dest_LiDAR_udp_port;\nint dest_gps_udp_port;\nint spin_rate;\nint sync;\nint sync_angle;\nint start_angle;\nint stop_angle;\nint clock_source;\nint udp_seq;\nint trigger_method;\nint return_mode;\nint standby_mode;\nint motor_status;\nint vlan_flag;\nint vlan_id;\nint clock_data_fmt;\nint noise_filtering;\nint reflectivity_mapping;\nunsigned char reserved[6];\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiConfig const &amp; arg)\n{\nos &lt;&lt; \"ipaddr: \" &lt;&lt; arg.ipaddr[0] &lt;&lt; \".\" &lt;&lt; arg.ipaddr[1] &lt;&lt; \".\" &lt;&lt; arg.ipaddr[2] &lt;&lt; \".\"\n&lt;&lt; arg.ipaddr[3];\nos &lt;&lt; \", \";\nos &lt;&lt; \"mask: \" &lt;&lt; arg.mask[0] &lt;&lt; \".\" &lt;&lt; arg.mask[1] &lt;&lt; \".\" &lt;&lt; arg.mask[2] &lt;&lt; \".\" &lt;&lt; arg.mask[3];\nos &lt;&lt; \", \";\nos &lt;&lt; \"gateway: \" &lt;&lt; arg.gateway[0] &lt;&lt; \".\" &lt;&lt; arg.gateway[1] &lt;&lt; \".\" &lt;&lt; arg.gateway[2] &lt;&lt; \".\"\n&lt;&lt; arg.gateway[3];\nos &lt;&lt; \", \";\nos &lt;&lt; \"dest_ipaddr: \" &lt;&lt; arg.dest_ipaddr[0] &lt;&lt; \".\" &lt;&lt; arg.dest_ipaddr[1] &lt;&lt; \".\"\n&lt;&lt; arg.dest_ipaddr[2] &lt;&lt; \".\" &lt;&lt; arg.dest_ipaddr[3];\nos &lt;&lt; \", \";\nos &lt;&lt; \"dest_LiDAR_udp_port: \" &lt;&lt; arg.dest_LiDAR_udp_port;\nos &lt;&lt; \", \";\nos &lt;&lt; \"dest_gps_udp_port: \" &lt;&lt; arg.dest_gps_udp_port;\nos &lt;&lt; \", \";\nos &lt;&lt; \"spin_rate: \" &lt;&lt; arg.spin_rate;\nos &lt;&lt; \", \";\nos &lt;&lt; \"sync: \" &lt;&lt; arg.sync;\nos &lt;&lt; \", \";\nos &lt;&lt; \"sync_angle: \" &lt;&lt; arg.sync_angle;\nos &lt;&lt; \", \";\nos &lt;&lt; \"start_angle: \" &lt;&lt; arg.start_angle;\nos &lt;&lt; \", \";\nos &lt;&lt; \"stop_angle: \" &lt;&lt; arg.stop_angle;\nos &lt;&lt; \", \";\nos &lt;&lt; \"clock_source: \" &lt;&lt; arg.clock_source;\nos &lt;&lt; \", \";\nos &lt;&lt; \"udp_seq: \" &lt;&lt; arg.udp_seq;\nos &lt;&lt; \", \";\nos &lt;&lt; \"trigger_method: \" &lt;&lt; arg.trigger_method;\nos &lt;&lt; \", \";\nos &lt;&lt; \"return_mode: \" &lt;&lt; arg.return_mode;\nos &lt;&lt; \", \";\nos &lt;&lt; \"standby_mode: \" &lt;&lt; arg.standby_mode;\nos &lt;&lt; \", \";\nos &lt;&lt; \"motor_status: \" &lt;&lt; arg.motor_status;\nos &lt;&lt; \", \";\nos &lt;&lt; \"vlan_flag: \" &lt;&lt; arg.vlan_flag;\nos &lt;&lt; \", \";\nos &lt;&lt; \"vlan_id: \" &lt;&lt; arg.vlan_id;\nos &lt;&lt; \", \";\nos &lt;&lt; \"clock_data_fmt: \" &lt;&lt; arg.clock_data_fmt;\nos &lt;&lt; \", \";\nos &lt;&lt; \"noise_filtering: \" &lt;&lt; arg.noise_filtering;\nos &lt;&lt; \", \";\nos &lt;&lt; \"reflectivity_mapping: \" &lt;&lt; arg.reflectivity_mapping;\nos &lt;&lt; \", \";\nos &lt;&lt; \"reserved: \" &lt;&lt; arg.reserved[0] &lt;&lt; \",\" &lt;&lt; arg.reserved[1] &lt;&lt; \",\" &lt;&lt; arg.reserved[2] &lt;&lt; \",\"\n&lt;&lt; arg.reserved[3] &lt;&lt; \",\" &lt;&lt; arg.reserved[4] &lt;&lt; \",\" &lt;&lt; arg.reserved[5];\n\nreturn os;\n}\n};\n\nstruct HesaiLidarStatus\n{\nint system_uptime;\nint motor_speed;\n//    int temperature[8];\nstd::vector&lt;int&gt; temperature = std::vector&lt;int&gt;(8);\nint gps_pps_lock;\nint gps_gprmc_status;\nint startup_times;\nint total_operation_time;\nint ptp_clock_status;\nstd::vector&lt;unsigned char&gt; reserved = std::vector&lt;unsigned char&gt;(5);\n\nHesaiLidarStatus() {}\nHesaiLidarStatus(const HesaiLidarStatus &amp; arg)\n{\nsystem_uptime = arg.system_uptime;\nmotor_speed = arg.motor_speed;\nstd::copy(arg.temperature.begin(), arg.temperature.end(), temperature.begin());\ngps_pps_lock = arg.gps_pps_lock;\ngps_gprmc_status = arg.gps_gprmc_status;\nstartup_times = arg.startup_times;\ntotal_operation_time = arg.total_operation_time;\nptp_clock_status = arg.ptp_clock_status;\nstd::copy(arg.reserved.begin(), arg.reserved.end(), reserved.begin());\n}\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiLidarStatus const &amp; arg)\n{\nos &lt;&lt; \"system_uptime: \" &lt;&lt; arg.system_uptime;\nos &lt;&lt; \", \";\nos &lt;&lt; \"motor_speed: \" &lt;&lt; arg.motor_speed;\nos &lt;&lt; \", \";\nos &lt;&lt; \"temperature: \";\nfor (long unsigned int i = 0; i &lt; arg.temperature.size() - 1; i++) {\nos &lt;&lt; arg.temperature[i] &lt;&lt; \",\";\n}\nos &lt;&lt; arg.temperature[arg.temperature.size() - 1];\nos &lt;&lt; \", \";\nos &lt;&lt; \"gps_pps_lock: \" &lt;&lt; arg.gps_pps_lock;\nos &lt;&lt; \", \";\nos &lt;&lt; \"gps_gprmc_status: \" &lt;&lt; arg.gps_gprmc_status;\nos &lt;&lt; \", \";\nos &lt;&lt; \"startup_times: \" &lt;&lt; arg.startup_times;\nos &lt;&lt; \", \";\nos &lt;&lt; \"total_operation_time: \" &lt;&lt; arg.total_operation_time;\nos &lt;&lt; \", \";\nos &lt;&lt; \"ptp_clock_status: \" &lt;&lt; arg.ptp_clock_status;\nos &lt;&lt; \", \";\nos &lt;&lt; \"reserved: \";\nfor (long unsigned int i = 0; i &lt; arg.reserved.size() - 1; i++) {\nos &lt;&lt; arg.reserved[i] &lt;&lt; \",\";\n}\nos &lt;&lt; arg.reserved[arg.reserved.size() - 1];\n\nreturn os;\n}\n\nstd::string get_str_gps_pps_lock()\n{\nswitch (gps_pps_lock) {\ncase 1:\nreturn \"Lock\";\nbreak;\ncase 0:\nreturn \"Unlock\";\nbreak;\ndefault:\nreturn \"Unknown\";\nbreak;\n}\n}\nstd::string get_str_gps_gprmc_status()\n{\nswitch (gps_gprmc_status) {\ncase 1:\nreturn \"Lock\";\nbreak;\ncase 0:\nreturn \"Unlock\";\nbreak;\ndefault:\nreturn \"Unknown\";\nbreak;\n}\n}\nstd::string get_str_ptp_clock_status()\n{\nswitch (ptp_clock_status) {\ncase 0:\nreturn \"free run\";\nbreak;\ncase 1:\nreturn \"tracking\";\nbreak;\ncase 2:\nreturn \"locked\";\nbreak;\ncase 3:\nreturn \"frozen\";\nbreak;\ndefault:\nreturn \"Unknown\";\nbreak;\n}\n}\n};\n\nstruct HesaiLidarRangeAll\n{\nint method;\nint start;\nint end;\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiLidarRangeAll const &amp; arg)\n{\nos &lt;&lt; \"method: \" &lt;&lt; arg.method;\nos &lt;&lt; \", \";\nos &lt;&lt; \"start: \" &lt;&lt; arg.start;\nos &lt;&lt; \", \";\nos &lt;&lt; \"end: \" &lt;&lt; arg.end;\n\nreturn os;\n}\n};\n\nstruct HesaiPtpConfig\n{\nint status;\nint profile;\nint domain;\nint network;\nint logAnnounceInterval;\nint logSyncInterval;\nint logMinDelayReqInterval;\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiPtpConfig const &amp; arg)\n{\nos &lt;&lt; \"status: \" &lt;&lt; arg.status;\nos &lt;&lt; \", \";\nos &lt;&lt; \"profile: \" &lt;&lt; arg.profile;\nos &lt;&lt; \", \";\nos &lt;&lt; \"domain: \" &lt;&lt; arg.domain;\nos &lt;&lt; \", \";\nos &lt;&lt; \"network: \" &lt;&lt; arg.network;\nif (arg.status == 0) {\nos &lt;&lt; \", \";\nos &lt;&lt; \"logAnnounceInterval: \" &lt;&lt; arg.logAnnounceInterval;\nos &lt;&lt; \", \";\nos &lt;&lt; \"logSyncInterval: \" &lt;&lt; arg.logSyncInterval;\nos &lt;&lt; \", \";\nos &lt;&lt; \"logMinDelayReqInterval: \" &lt;&lt; arg.logMinDelayReqInterval;\n}\nreturn os;\n}\n};\n\nstruct HesaiLidarMonitor\n{\nint input_voltage;\nint input_current;\nint input_power;\nstd::vector&lt;unsigned char&gt; reserved = std::vector&lt;unsigned char&gt;(52);\n\nfriend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, nebula::HesaiLidarMonitor const &amp; arg)\n{\nos &lt;&lt; \"input_voltage: \" &lt;&lt; arg.input_voltage;\nos &lt;&lt; \", \";\nos &lt;&lt; \"input_current: \" &lt;&lt; arg.input_current;\nos &lt;&lt; \", \";\nos &lt;&lt; \"input_power: \" &lt;&lt; arg.input_power;\nos &lt;&lt; \", \";\nos &lt;&lt; \"reserved: \";\nfor (long unsigned int i = 0; i &lt; arg.reserved.size() - 1; i++) {\nos &lt;&lt; arg.reserved[i] &lt;&lt; \",\";\n}\nos &lt;&lt; arg.reserved[arg.reserved.size() - 1];\n\nreturn os;\n}\n};\n\n}  // namespace nebula\n#endif  // HESAI_CMD_RESPONSE_HPP\n</code></pre>"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp/","title":"File hesai_hw_interface.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_hw_interface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/version.hpp&gt;</code></li> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/hesai/hesai_status.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/http_client_driver.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;boost/algorithm/string.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/json_parser.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/ptree.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp/#classes","title":"Classes","text":"Type Name class HesaiHwInterface Hardware interface of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/hesai__hw__interface_8hpp_source/","title":"File hesai_hw_interface.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_hesai &gt; hesai_hw_interface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HESAI_HW_INTERFACE_H\n#define NEBULA_HESAI_HW_INTERFACE_H\n// Have to define macros to silence warnings about deprecated headers being used by\n// boost/property_tree/ in some versions of boost.\n// See: https://github.com/boostorg/property_tree/issues/51\n#include &lt;boost/version.hpp&gt;\n#if (BOOST_VERSION / 100 &gt;= 1073 &amp;&amp; BOOST_VERSION / 100 &lt;= 1076)  // Boost 1.73 - 1.76\n#define BOOST_BIND_GLOBAL_PLACEHOLDERS\n#endif\n#if (BOOST_VERSION / 100 == 1074)  // Boost 1.74\n#define BOOST_ALLOW_DEPRECATED_HEADERS\n#endif\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/hesai/hesai_status.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_cmd_response.hpp\"\n#include \"boost_tcp_driver/http_client_driver.hpp\"\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n#include \"boost_udp_driver/udp_driver.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;boost/algorithm/string.hpp&gt;\n#include &lt;boost/property_tree/json_parser.hpp&gt;\n#include &lt;boost/property_tree/ptree.hpp&gt;\n\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nconst int PandarTcpCommandPort = 9347;\nconst uint8_t PTC_COMMAND_DUMMY_BYTE = 0x00;\nconst uint8_t PTC_COMMAND_HEADER_HIGH = 0x47;\nconst uint8_t PTC_COMMAND_HEADER_LOW = 0x74;\nconst uint8_t PTC_COMMAND_GET_LIDAR_CALIBRATION = 0x05;\nconst uint8_t PTC_COMMAND_PTP_DIAGNOSTICS = 0x06;\nconst uint8_t PTC_COMMAND_PTP_STATUS = 0x01;\nconst uint8_t PTC_COMMAND_PTP_PORT_DATA_SET = 0x02;\nconst uint8_t PTC_COMMAND_PTP_TIME_STATUS_NP = 0x03;\nconst uint8_t PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP = 0x04;\nconst uint8_t PTC_COMMAND_GET_INVENTORY_INFO = 0x07;\nconst uint8_t PTC_COMMAND_GET_CONFIG_INFO = 0x08;\nconst uint8_t PTC_COMMAND_GET_LIDAR_STATUS = 0x09;\nconst uint8_t PTC_COMMAND_SET_SPIN_RATE = 0x17;\nconst uint8_t PTC_COMMAND_SET_SYNC_ANGLE = 0x18;\nconst uint8_t PTC_COMMAND_SET_TRIGGER_METHOD = 0x1b;\nconst uint8_t PTC_COMMAND_SET_STANDBY_MODE = 0x1c;\nconst uint8_t PTC_COMMAND_SET_RETURN_MODE = 0x1e;\nconst uint8_t PTC_COMMAND_SET_CLOCK_SOURCE = 0x1f;\nconst uint8_t PTC_COMMAND_SET_DESTINATION_IP = 0x20;\nconst uint8_t PTC_COMMAND_SET_CONTROL_PORT = 0x21;\nconst uint8_t PTC_COMMAND_SET_LIDAR_RANGE = 0x22;\nconst uint8_t PTC_COMMAND_GET_LIDAR_RANGE = 0x23;\nconst uint8_t PTC_COMMAND_SET_PTP_CONFIG = 0x24;\nconst uint8_t PTC_COMMAND_GET_PTP_CONFIG = 0x26;\nconst uint8_t PTC_COMMAND_RESET = 0x25;\nconst uint8_t PTC_COMMAND_SET_ROTATE_DIRECTION = 0x2a;\nconst uint8_t PTC_COMMAND_LIDAR_MONITOR = 0x27;\n\nconst uint16_t PANDARQT64_PACKET_SIZE = 1072;\nconst uint16_t PANDARQT128_PACKET_SIZE = 1127;\nconst uint16_t PANDARXT32_PACKET_SIZE = 1080;\nconst uint16_t PANDARXT32M_PACKET_SIZE = 820;\nconst uint16_t PANDARAT128_PACKET_SIZE = 1118;\nconst uint16_t PANDAR64_PACKET_SIZE = 1194;\nconst uint16_t PANDAR64_EXTENDED_PACKET_SIZE = 1198;\nconst uint16_t PANDAR40_PACKET_SIZE = 1262;\nconst uint16_t PANDAR40P_EXTENDED_PACKET_SIZE = 1266;\nconst uint16_t PANDAR128_E4X_PACKET_SIZE = 861;\nconst uint16_t PANDAR128_E4X_EXTENDED_PACKET_SIZE = 1117;\n\nconst uint16_t MTU_SIZE = 1500;\n\nconst int PTP_PROFILE = 0; // Fixed: IEEE 1588v2\nconst int PTP_DOMAIN_ID = 0; // 0-127, Default: 0\nconst int PTP_NETWORK_TRANSPORT = 0; // 0: UDP/IP, 1: L2\nconst int PTP_LOG_ANNOUNCE_INTERVAL = 1; // Time interval between Announce messages, in units of log seconds (default: 1)\nconst int PTP_SYNC_INTERVAL = 1; //Time interval between Sync messages, in units of log seconds (default: 1)\nconst int PTP_LOG_MIN_DELAY_INTERVAL = 0; //Minimum permitted mean time between Delay_Req messages, in units of log seconds (default: 0)\n\nconst int HESAI_LIDAR_GPS_CLOCK_SOURCE = 0;\nconst int HESAI_LIDAR_PTP_CLOCK_SOURCE = 1;\n\nclass HesaiHwInterface : NebulaHwInterfaceBase\n{\nprivate:\nstd::unique_ptr&lt;::drivers::common::IoContext&gt; cloud_io_context_;\nstd::shared_ptr&lt;boost::asio::io_context&gt; m_owned_ctx;\nstd::shared_ptr&lt;boost::asio::io_context&gt; m_owned_ctx_s;\nstd::unique_ptr&lt;::drivers::udp_driver::UdpDriver&gt; cloud_udp_driver_;\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; tcp_driver_;\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; tcp_driver_s_;\nstd::shared_ptr&lt;HesaiSensorConfiguration&gt; sensor_configuration_;\nstd::shared_ptr&lt;HesaiCalibrationConfiguration&gt; calibration_configuration_;\nsize_t azimuth_index_{};\nsize_t mtu_size_{};\nstd::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt; scan_cloud_ptr_;\nstd::function&lt;bool(size_t)&gt;\nis_valid_packet_; /*Lambda Function Array to verify proper packet size*/\nstd::function&lt;void(std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt; buffer)&gt;\nscan_reception_callback_; int prev_phase_{};\n\nint timeout_ = 2000;\nstd::timed_mutex tm_;\nint tm_fail_cnt = 0;\nint tm_fail_cnt_max = 0;\nstd::timed_mutex tms_;\nint tms_fail_cnt = 0;\nint tms_fail_cnt_max = 3;\nbool wl = true;\nbool is_solid_state = false;\nint target_model_no;\n\nHesaiStatus GetHttpClientDriverOnce(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\nHesaiStatus GetHttpClientDriverOnce(\nstd::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\nvoid str_cb(const std::string &amp; str);\n\nbool CheckLock(std::timed_mutex &amp; tm, int &amp; fail_cnt, const int &amp; fail_cnt_max, std::string name);\nvoid CheckUnlock(std::timed_mutex &amp; tm, std::string name);\n\nstd::shared_ptr&lt;rclcpp::Logger&gt; parent_node_logger;\nvoid PrintInfo(std::string info);\nvoid PrintError(std::string error);\nvoid PrintDebug(std::string debug);\nvoid PrintDebug(const std::vector&lt;uint8_t&gt; &amp; bytes);\n\npublic:\nHesaiHwInterface();\nStatus InitializeTcpDriver(bool setup_sensor = true);\nStatus FinalizeTcpDriver();\nboost::property_tree::ptree ParseJson(const std::string &amp; str);\n\nvoid ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) final;\nStatus CloudInterfaceStart() final;\nStatus CloudInterfaceStop() final;\nStatus GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) final;\nStatus GetCalibrationConfiguration(CalibrationConfigurationBase &amp; calibration_configuration);\nStatus SetSensorConfiguration(\nstd::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) final;\nStatus RegisterScanCallback(\nstd::function&lt;void(std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt;)&gt; scan_callback);\nStatus syncGetLidarCalibration(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback);\nStatus syncGetLidarCalibration(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback);\nStatus syncGetLidarCalibration(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver);\nStatus syncGetLidarCalibration(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback);\nStatus syncGetLidarCalibration(std::shared_ptr&lt;boost::asio::io_context&gt; ctx);\nStatus syncGetLidarCalibrationFromSensor(\nstd::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback);\nStatus syncGetLidarCalibrationFromSensor(\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback);\nStatus syncGetLidarCalibrationFromSensor();\nStatus GetLidarCalibration(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback,\nbool with_run = true);\nStatus GetLidarCalibration(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback, bool with_run = true);\nStatus GetLidarCalibration(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus GetLidarCalibration(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback, bool with_run = true);\nStatus GetLidarCalibration(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetLidarCalibrationFromSensor(\nstd::function&lt;void(const std::vector&lt;uint8_t&gt; &amp; received_bytes)&gt; bytes_callback,\nbool with_run = true);\nStatus GetLidarCalibrationFromSensor(\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback, bool with_run = true);\nStatus GetLidarCalibrationFromSensor(bool with_run = true);\nStatus GetPtpDiagStatus(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus GetPtpDiagStatus(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetPtpDiagStatus(bool with_run = true);\nStatus GetPtpDiagPort(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus GetPtpDiagPort(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetPtpDiagPort(bool with_run = true);\nStatus GetPtpDiagTime(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus GetPtpDiagTime(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetPtpDiagTime(bool with_run = true);\nStatus GetPtpDiagGrandmaster(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus GetPtpDiagGrandmaster(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetPtpDiagGrandmaster(bool with_run = true);\nStatus GetInventory(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(HesaiInventory &amp; result)&gt; callback, bool with_run = true);\nStatus GetInventory(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(HesaiInventory &amp; result)&gt; callback, bool with_run = true);\nStatus GetInventory(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetInventory(std::function&lt;void(HesaiInventory &amp; result)&gt; callback, bool with_run = true);\nStatus GetInventory(bool with_run = true);\nStatus GetConfig(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(HesaiConfig &amp; result)&gt; callback, bool with_run = true);\nStatus GetConfig(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(HesaiConfig &amp; result)&gt; callback, bool with_run = true);\nStatus GetConfig(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetConfig(std::function&lt;void(HesaiConfig &amp; result)&gt; callback, bool with_run = true);\nStatus GetConfig(bool with_run = true);\nStatus GetLidarStatus(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(HesaiLidarStatus &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarStatus(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(HesaiLidarStatus &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarStatus(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetLidarStatus(\nstd::function&lt;void(HesaiLidarStatus &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarStatus(bool with_run = true);\nStatus SetSpinRate(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, uint16_t rpm,\nbool with_run = true);\nStatus SetSpinRate(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, uint16_t rpm, bool with_run = true);\nStatus SetSpinRate(uint16_t rpm, bool with_run = true);\nStatus SetSyncAngle(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int sync_angle, int angle,\nbool with_run = true);\nStatus SetSyncAngle(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int sync_angle, int angle, bool with_run = true);\nStatus SetSyncAngle(int sync_angle, int angle, bool with_run = true);\nStatus SetTriggerMethod(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int trigger_method,\nbool with_run = true);\nStatus SetTriggerMethod(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int trigger_method, bool with_run = true);\nStatus SetTriggerMethod(int trigger_method, bool with_run = true);\nStatus SetStandbyMode(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int standby_mode,\nbool with_run = true);\nStatus SetStandbyMode(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int standby_mode, bool with_run = true);\nStatus SetStandbyMode(int standby_mode, bool with_run = true);\nStatus SetReturnMode(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int return_mode,\nbool with_run = true);\nStatus SetReturnMode(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int return_mode, bool with_run = true);\nStatus SetReturnMode(int return_mode, bool with_run = true);\nStatus SetDestinationIp(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int dest_ip_1,\nint dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port, bool with_run = true);\nStatus SetDestinationIp(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int dest_ip_1, int dest_ip_2, int dest_ip_3,\nint dest_ip_4, int port, int gps_port, bool with_run = true);\nStatus SetDestinationIp(\nint dest_ip_1, int dest_ip_2, int dest_ip_3, int dest_ip_4, int port, int gps_port,\nbool with_run = true);\nStatus SetControlPort(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int ip_1, int ip_2,\nint ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4, int gateway_1,\nint gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id, bool with_run = true);\nStatus SetControlPort(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int ip_1, int ip_2, int ip_3, int ip_4,\nint mask_1, int mask_2, int mask_3, int mask_4, int gateway_1, int gateway_2, int gateway_3,\nint gateway_4, int vlan_flg, int vlan_id, bool with_run = true);\nStatus SetControlPort(\nint ip_1, int ip_2, int ip_3, int ip_4, int mask_1, int mask_2, int mask_3, int mask_4,\nint gateway_1, int gateway_2, int gateway_3, int gateway_4, int vlan_flg, int vlan_id,\nbool with_run = true);\nStatus SetLidarRange(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int method,\nstd::vector&lt;unsigned char&gt; data, bool with_run = true);\nStatus SetLidarRange(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int method, std::vector&lt;unsigned char&gt; data,\nbool with_run = true);\nStatus SetLidarRange(int method, std::vector&lt;unsigned char&gt; data, bool with_run = true);\nStatus SetLidarRange(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int start, int end,\nbool with_run = true);\nStatus SetLidarRange(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int start, int end, bool with_run = true);\nStatus SetLidarRange(int start, int end, bool with_run = true);\nStatus GetLidarRange(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(HesaiLidarRangeAll &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarRange(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(HesaiLidarRangeAll &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarRange(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetLidarRange(\nstd::function&lt;void(HesaiLidarRangeAll &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarRange(bool with_run = true);\n\nStatus SetClockSource(std::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int clock_source, bool with_run);\nStatus SetClockSource(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int clock_source, bool with_run);\nStatus SetClockSource(int clock_source, bool with_run = true);\n\nStatus SetPtpConfig(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int profile, int domain,\nint network, int logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval,\nbool with_run = true);\nStatus SetPtpConfig(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx, int profile, int domain, int network,\nint logAnnounceInterval, int logSyncInterval, int logMinDelayReqInterval, bool with_run = true);\nStatus SetPtpConfig(\nint profile, int domain, int network, int logAnnounceInterval, int logSyncInterval,\nint logMinDelayReqInterval, bool with_run = true);\nStatus GetPtpConfig(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus GetPtpConfig(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetPtpConfig(bool with_run = true);\nStatus SendReset(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, bool with_run = true);\nStatus SendReset(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus SendReset(bool with_run = true);\nStatus SetRotDir(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver, int mode,\nbool with_run = true);\nStatus SetRotDir(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, int mode, bool with_run = true);\nStatus SetRotDir(int mode, bool with_run = true);\nStatus GetLidarMonitor(\nstd::shared_ptr&lt;::drivers::tcp_driver::TcpDriver&gt; target_tcp_driver,\nstd::function&lt;void(HesaiLidarMonitor &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarMonitor(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(HesaiLidarMonitor &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarMonitor(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, bool with_run = true);\nStatus GetLidarMonitor(\nstd::function&lt;void(HesaiLidarMonitor &amp; result)&gt; callback, bool with_run = true);\nStatus GetLidarMonitor(bool with_run = true);\n\nvoid IOContextRun();\nstd::shared_ptr&lt;boost::asio::io_context&gt; GetIOContext();\n\nHesaiStatus SetSpinSpeedAsyncHttp(std::shared_ptr&lt;boost::asio::io_context&gt; ctx, uint16_t rpm);\nHesaiStatus SetSpinSpeedAsyncHttp(uint16_t rpm);\n\nHesaiStatus SetPtpConfigSyncHttp(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nint profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval);\nHesaiStatus SetPtpConfigSyncHttp(int profile,\nint domain,\nint network,\nint logAnnounceInterval,\nint logSyncInterval,\nint logMinDelayReqInterval);\nHesaiStatus SetSyncAngleSyncHttp(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nint enable,\nint angle);\nHesaiStatus SetSyncAngleSyncHttp(int enable, int angle);\n\n\n\nHesaiStatus GetLidarMonitorAsyncHttp(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::function&lt;void(const std::string &amp; str)&gt; str_callback);\nHesaiStatus GetLidarMonitorAsyncHttp(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\n\nHesaiStatus CheckAndSetConfig(\nstd::shared_ptr&lt;HesaiSensorConfiguration&gt; sensor_configuration, HesaiConfig hesai_config);\nHesaiStatus CheckAndSetConfig(\nstd::shared_ptr&lt;HesaiSensorConfiguration&gt; sensor_configuration,\nHesaiLidarRangeAll hesai_lidar_range_all);\nHesaiStatus CheckAndSetConfig();\n\nvoid SetTargetModel(int model);\n\nbool UseHttpSetSpinRate(int model);\nbool UseHttpSetSpinRate();\nbool UseHttpGetLidarMonitor(int model);\nbool UseHttpGetLidarMonitor();\n\nvoid SetLogger(std::shared_ptr&lt;rclcpp::Logger&gt; node);\n};\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_HESAI_HW_INTERFACE_H\n</code></pre>"},{"location":"nebula_hw_interfaces/dir_dfdaa22cf10ea0df1458ba0ebc4d9e9c/","title":"Dir nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_velodyne</p>"},{"location":"nebula_hw_interfaces/dir_dfdaa22cf10ea0df1458ba0ebc4d9e9c/#files","title":"Files","text":"Type Name file velodyne_hw_interface.hpp <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne/</code></p>"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp/","title":"File velodyne_hw_interface.hpp","text":"<p>FileList &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_velodyne &gt; velodyne_hw_interface.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;boost/version.hpp&gt;</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_status.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/http_client_driver.hpp\"</code></li> <li><code>#include \"boost_udp_driver/udp_driver.hpp\"</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;boost/property_tree/json_parser.hpp&gt;</code></li> <li><code>#include &lt;boost/property_tree/ptree.hpp&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace drivers"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneHwInterface Hardware interface of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_hw_interfaces/include/nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp</code></p>"},{"location":"nebula_hw_interfaces/velodyne__hw__interface_8hpp_source/","title":"File velodyne_hw_interface.hpp","text":"<p>File List &gt; include &gt; nebula_hw_interfaces &gt; nebula_hw_interfaces_velodyne &gt; velodyne_hw_interface.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VELODYNE_HW_INTERFACE_H\n#define NEBULA_VELODYNE_HW_INTERFACE_H\n\n// Have to define macros to silence warnings about deprecated headers being used by\n// boost/property_tree/ in some versions of boost.\n// See: https://github.com/boostorg/property_tree/issues/51\n#include &lt;boost/version.hpp&gt;\n#if (BOOST_VERSION / 100 &gt;= 1073 &amp;&amp; BOOST_VERSION / 100 &lt;= 1076)  // Boost 1.73 - 1.76\n#define BOOST_BIND_GLOBAL_PLACEHOLDERS\n#endif\n#if (BOOST_VERSION / 100 == 1074)  // Boost 1.74\n#define BOOST_ALLOW_DEPRECATED_HEADERS\n#endif\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_common/velodyne/velodyne_status.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_common/nebula_hw_interface_base.hpp\"\n#include \"boost_tcp_driver/http_client_driver.hpp\"\n#include \"boost_udp_driver/udp_driver.hpp\"\n\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;boost/property_tree/json_parser.hpp&gt;\n#include &lt;boost/property_tree/ptree.hpp&gt;\n\n#include &lt;memory&gt;\n\nnamespace nebula\n{\nnamespace drivers\n{\nclass VelodyneHwInterface : NebulaHwInterfaceBase\n{\nprivate:\nstd::unique_ptr&lt;::drivers::common::IoContext&gt; cloud_io_context_;\nstd::unique_ptr&lt;::drivers::udp_driver::UdpDriver&gt; cloud_udp_driver_;\nstd::shared_ptr&lt;VelodyneSensorConfiguration&gt; sensor_configuration_;\nstd::shared_ptr&lt;VelodyneCalibrationConfiguration&gt; calibration_configuration_;\nstd::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; scan_cloud_ptr_;\nstd::function&lt;bool(size_t)&gt;\nis_valid_packet_; /*Lambda Function Array to verify proper packet size*/\nstd::function&lt;void(std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; buffer)&gt;\nscan_reception_callback_; uint16_t packet_first_azm_ = 0;\nuint16_t packet_first_azm_phased_ = 0;\nuint16_t packet_last_azm_ = 0;\nuint16_t packet_last_azm_phased_ = 0;\nuint16_t prev_packet_first_azm_phased_ = 0;\nuint16_t phase_ = 0;\nuint processed_packets_ = 0;\n\nstd::shared_ptr&lt;boost::asio::io_context&gt; boost_ctx_;\nstd::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; http_client_driver_;\n\nstd::string TARGET_STATUS{\"/cgi/status.json\"};\nstd::string TARGET_DIAG{\"/cgi/diag.json\"};\nstd::string TARGET_SNAPSHOT{\"/cgi/snapshot.hdl\"};\nstd::string TARGET_SETTING{\"/cgi/setting\"};\nstd::string TARGET_FOV{\"/cgi/setting/fov\"};\nstd::string TARGET_HOST{\"/cgi/setting/host\"};\nstd::string TARGET_NET{\"/cgi/setting/net\"};\nstd::string TARGET_SAVE{\"/cgi/save\"};\nstd::string TARGET_RESET{\"/cgi/reset\"};\nvoid StringCallback(const std::string &amp; str);\n\nVelodyneStatus GetHttpClientDriverOnce(\nstd::shared_ptr&lt;boost::asio::io_context&gt; ctx,\nstd::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\nVelodyneStatus GetHttpClientDriverOnce(\nstd::unique_ptr&lt;::drivers::tcp_driver::HttpClientDriver&gt; &amp; hcd);\n\nVelodyneStatus CheckAndSetConfig(\nstd::shared_ptr&lt;VelodyneSensorConfiguration&gt; sensor_configuration,\nboost::property_tree::ptree tree);\n\nstd::shared_ptr&lt;rclcpp::Logger&gt; parent_node_logger;\nvoid PrintInfo(std::string info);\nvoid PrintError(std::string error);\nvoid PrintDebug(std::string debug);\n\npublic:\nVelodyneHwInterface();\n\nvoid ReceiveCloudPacketCallback(const std::vector&lt;uint8_t&gt; &amp; buffer) final;\nStatus CloudInterfaceStart() final;\nStatus CloudInterfaceStop() final;\nStatus GetSensorConfiguration(SensorConfigurationBase &amp; sensor_configuration) final;\nStatus GetCalibrationConfiguration(\nCalibrationConfigurationBase &amp; calibration_configuration) final;\nStatus InitializeSensorConfiguration(\nstd::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration);\nStatus SetSensorConfiguration(\nstd::shared_ptr&lt;SensorConfigurationBase&gt; sensor_configuration) final;\nStatus RegisterScanCallback(\nstd::function&lt;void(std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt;)&gt; scan_callback);\n\nboost::property_tree::ptree ParseJson(const std::string &amp; str);\n\nVelodyneStatus InitHttpClient();\nstd::string GetStatus();\nstd::string GetDiag();\nstd::string GetSnapshot();\nVelodyneStatus SetRpm(uint16_t rpm);\nVelodyneStatus SetFovStart(uint16_t fov_start);\nVelodyneStatus SetFovEnd(uint16_t fov_end);\nVelodyneStatus SetReturnType(ReturnMode return_mode);\nVelodyneStatus SaveConfig();\nVelodyneStatus ResetSystem();\nVelodyneStatus LaserOn();\nVelodyneStatus LaserOff();\nVelodyneStatus LaserOnOff(bool on);\nVelodyneStatus SetHostAddr(std::string addr);\nVelodyneStatus SetHostDport(uint16_t dport);\nVelodyneStatus SetHostTport(uint16_t tport);\nVelodyneStatus SetNetAddr(std::string addr);\nVelodyneStatus SetNetMask(std::string mask);\nVelodyneStatus SetNetGateway(std::string gateway);\nVelodyneStatus SetNetDhcp(bool use_dhcp);\n\nVelodyneStatus InitHttpClientAsync();\nVelodyneStatus GetStatusAsync(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\nVelodyneStatus GetStatusAsync();\nVelodyneStatus GetDiagAsync(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\nVelodyneStatus GetDiagAsync();\nVelodyneStatus GetSnapshotAsync(std::function&lt;void(const std::string &amp; str)&gt; str_callback);\nVelodyneStatus GetSnapshotAsync();\nVelodyneStatus CheckAndSetConfigBySnapshotAsync();\nVelodyneStatus SetRpmAsync(uint16_t rpm);\nVelodyneStatus SetFovStartAsync(uint16_t fov_start);\nVelodyneStatus SetFovEndAsync(uint16_t fov_end);\nVelodyneStatus SetReturnTypeAsync(ReturnMode return_mode);\nVelodyneStatus SaveConfigAsync();\nVelodyneStatus ResetSystemAsync();\nVelodyneStatus LaserOnAsync();\nVelodyneStatus LaserOffAsync();\nVelodyneStatus LaserOnOffAsync(bool on);\nVelodyneStatus SetHostAddrAsync(std::string addr);\nVelodyneStatus SetHostDportAsync(uint16_t dport);\nVelodyneStatus SetHostTportAsync(uint16_t tport);\nVelodyneStatus SetNetAddrAsync(std::string addr);\nVelodyneStatus SetNetMaskAsync(std::string mask);\nVelodyneStatus SetNetGatewayAsync(std::string gateway);\nVelodyneStatus SetNetDhcpAsync(bool use_dhcp);\n\nvoid SetLogger(std::shared_ptr&lt;rclcpp::Logger&gt; node);\n};\n\n}  // namespace drivers\n}  // namespace nebula\n\n#endif  // NEBULA_VELODYNE_HW_INTERFACE_H\n</code></pre>"},{"location":"nebula_hw_interfaces/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace drivers </li> </ul> </li> </ul>"},{"location":"nebula_hw_interfaces/classes/","title":"Class Index","text":""},{"location":"nebula_hw_interfaces/classes/#h","title":"h","text":"<ul> <li>HesaiConfig (nebula)</li> <li>HesaiHwInterface (nebula::drivers)</li> <li>HesaiInventory (nebula)</li> <li>HesaiLidarMonitor (nebula)</li> <li>HesaiLidarRangeAll (nebula)</li> <li>HesaiLidarStatus (nebula)</li> <li>HesaiPtpConfig (nebula)</li> <li>HesaiPtpDiagGrandmaster (nebula)</li> <li>HesaiPtpDiagPort (nebula)</li> <li>HesaiPtpDiagStatus (nebula)</li> <li>HesaiPtpDiagTime (nebula)</li> </ul>"},{"location":"nebula_hw_interfaces/classes/#n","title":"n","text":"<ul> <li>NebulaHwInterfaceBase (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/classes/#v","title":"v","text":"<ul> <li>VelodyneHwInterface (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::drivers::NebulaHwInterfaceBase Base class for hardware interface of each LiDAR. <ul> <li>class nebula::drivers::HesaiHwInterface Hardware interface of hesai driver. </li> <li>class nebula::drivers::VelodyneHwInterface Hardware interface of velodyne driver. </li> </ul> </li> <li>struct nebula::HesaiConfig struct of PTC_COMMAND_GET_CONFIG_INFO </li> <li>struct nebula::HesaiInventory struct of PTC_COMMAND_GET_INVENTORY_INFO </li> <li>struct nebula::HesaiLidarMonitor struct of PTC_COMMAND_LIDAR_MONITOR </li> <li>struct nebula::HesaiLidarRangeAll struct of PTC_COMMAND_GET_LIDAR_RANGE </li> <li>struct nebula::HesaiLidarStatus struct of PTC_COMMAND_GET_LIDAR_STATUS </li> <li>struct nebula::HesaiPtpConfig struct of PTC_COMMAND_GET_PTP_CONFIG </li> <li>struct nebula::HesaiPtpDiagGrandmaster LinuxPTP TLV GRANDMASTER_SETTINGS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct nebula::HesaiPtpDiagPort PTP TLV PORT_DATA_SET struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct nebula::HesaiPtpDiagStatus PTP STATUS struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> <li>struct nebula::HesaiPtpDiagTime LinuxPTP TLV TIME_STATUS_NP struct of PTC_COMMAND_PTP_DIAGNOSTICS. </li> </ul>"},{"location":"nebula_hw_interfaces/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_hw_interfaces/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"nebula_hw_interfaces/class_members/","title":"Class Members","text":""},{"location":"nebula_hw_interfaces/class_members/#a","title":"a","text":"<ul> <li>angle_offset (nebula::HesaiInventory)</li> <li>announceReceiptTimeout (nebula::HesaiPtpDiagPort)</li> <li>azimuth_index_ (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#b","title":"b","text":"<ul> <li>boost_ctx_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#c","title":"c","text":"<ul> <li>clock_data_fmt (nebula::HesaiConfig)</li> <li>clock_source (nebula::HesaiConfig)</li> <li>control_fw_ver (nebula::HesaiInventory)</li> <li>clockQuality (nebula::HesaiPtpDiagGrandmaster)</li> <li>cumulativeScaledRateOffset (nebula::HesaiPtpDiagTime)</li> <li>CheckAndSetConfig (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckLock (nebula::drivers::HesaiHwInterface)</li> <li>CheckUnlock (nebula::drivers::HesaiHwInterface)</li> <li>CloudInterfaceStart (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>CloudInterfaceStop (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>calibration_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_io_context_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_udp_driver_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckAndSetConfigBySnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#d","title":"d","text":"<ul> <li>dest_LiDAR_udp_port (nebula::HesaiConfig)</li> <li>dest_gps_udp_port (nebula::HesaiConfig)</li> <li>dest_ipaddr (nebula::HesaiConfig)</li> <li>date_of_manufacture (nebula::HesaiInventory)</li> <li>domain (nebula::HesaiPtpConfig)</li> <li>delayMechanism (nebula::HesaiPtpDiagPort)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#e","title":"e","text":"<ul> <li>end (nebula::HesaiLidarRangeAll)</li> <li>elapsed_millisec (nebula::HesaiPtpDiagStatus)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#f","title":"f","text":"<ul> <li>FinalizeTcpDriver (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#g","title":"g","text":"<ul> <li>gateway (nebula::HesaiConfig)</li> <li>get_str_model (nebula::HesaiInventory)</li> <li>get_str_gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>get_str_gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>get_str_ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>gmIdentity (nebula::HesaiPtpDiagTime)</li> <li>gmPresent (nebula::HesaiPtpDiagTime)</li> <li>gmTimeBaseIndicator (nebula::HesaiPtpDiagTime)</li> <li>GetCalibrationConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>GetConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetHttpClientDriverOnce (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetIOContext (nebula::drivers::HesaiHwInterface)</li> <li>GetInventory (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitorAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagGrandmaster (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagPort (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagTime (nebula::drivers::HesaiHwInterface)</li> <li>GetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>GetDiag (nebula::drivers::VelodyneHwInterface)</li> <li>GetDiagAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshot (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatus (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatusAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#h","title":"h","text":"<ul> <li>HesaiInventory (nebula::HesaiInventory)</li> <li>hw_ver (nebula::HesaiInventory)</li> <li>HesaiLidarStatus (nebula::HesaiLidarStatus)</li> <li>HesaiPtpDiagPort (nebula::HesaiPtpDiagPort)</li> <li>HesaiPtpDiagTime (nebula::HesaiPtpDiagTime)</li> <li>HesaiHwInterface (nebula::drivers::HesaiHwInterface)</li> <li>http_client_driver_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#i","title":"i","text":"<ul> <li>ipaddr (nebula::HesaiConfig)</li> <li>input_current (nebula::HesaiLidarMonitor)</li> <li>input_power (nebula::HesaiLidarMonitor)</li> <li>input_voltage (nebula::HesaiLidarMonitor)</li> <li>ingress_time (nebula::HesaiPtpDiagTime)</li> <li>IOContextRun (nebula::drivers::HesaiHwInterface)</li> <li>InitializeTcpDriver (nebula::drivers::HesaiHwInterface)</li> <li>is_solid_state (nebula::drivers::HesaiHwInterface)</li> <li>is_valid_packet_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>InitHttpClient (nebula::drivers::VelodyneHwInterface)</li> <li>InitHttpClientAsync (nebula::drivers::VelodyneHwInterface)</li> <li>InitializeSensorConfiguration (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#l","title":"l","text":"<ul> <li>logAnnounceInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinDelayReqInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logSyncInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinPdelayReqInterval (nebula::HesaiPtpDiagPort)</li> <li>lastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> <li>LaserOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOffAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOn (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOffAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#m","title":"m","text":"<ul> <li>mask (nebula::HesaiConfig)</li> <li>motor_status (nebula::HesaiConfig)</li> <li>mac (nebula::HesaiInventory)</li> <li>model (nebula::HesaiInventory)</li> <li>motor_type (nebula::HesaiInventory)</li> <li>method (nebula::HesaiLidarRangeAll)</li> <li>motor_speed (nebula::HesaiLidarStatus)</li> <li>master_offset (nebula::HesaiPtpDiagStatus, nebula::HesaiPtpDiagTime)</li> <li>m_owned_ctx (nebula::drivers::HesaiHwInterface)</li> <li>m_owned_ctx_s (nebula::drivers::HesaiHwInterface)</li> <li>mtu_size_ (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#n","title":"n","text":"<ul> <li>noise_filtering (nebula::HesaiConfig)</li> <li>num_of_lines (nebula::HesaiInventory)</li> <li>network (nebula::HesaiPtpConfig)</li> <li>NebulaHwInterfaceBase (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#p","title":"p","text":"<ul> <li>ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>profile (nebula::HesaiPtpConfig)</li> <li>peerMeanPathDelay (nebula::HesaiPtpDiagPort)</li> <li>portIdentity (nebula::HesaiPtpDiagPort)</li> <li>portState (nebula::HesaiPtpDiagPort)</li> <li>ptp_state (nebula::HesaiPtpDiagStatus)</li> <li>ParseJson (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintDebug (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintError (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintInfo (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>parent_node_logger (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>prev_phase_ (nebula::drivers::HesaiHwInterface)</li> <li>packet_first_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>phase_ (nebula::drivers::VelodyneHwInterface)</li> <li>prev_packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>processed_packets_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#r","title":"r","text":"<ul> <li>reflectivity_mapping (nebula::HesaiConfig)</li> <li>reserved (nebula::HesaiConfig, nebula::HesaiInventory, nebula::HesaiLidarMonitor, nebula::HesaiLidarStatus)</li> <li>return_mode (nebula::HesaiConfig)</li> <li>ReceiveCloudPacketCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>RegisterScanCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>ResetSystem (nebula::drivers::VelodyneHwInterface)</li> <li>ResetSystemAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#s","title":"s","text":"<ul> <li>spin_rate (nebula::HesaiConfig)</li> <li>standby_mode (nebula::HesaiConfig)</li> <li>start_angle (nebula::HesaiConfig)</li> <li>stop_angle (nebula::HesaiConfig)</li> <li>sync (nebula::HesaiConfig)</li> <li>sync_angle (nebula::HesaiConfig)</li> <li>sensor_fw_ver (nebula::HesaiInventory)</li> <li>sn (nebula::HesaiInventory)</li> <li>sw_ver (nebula::HesaiInventory)</li> <li>start (nebula::HesaiLidarRangeAll)</li> <li>startup_times (nebula::HesaiLidarStatus)</li> <li>system_uptime (nebula::HesaiLidarStatus)</li> <li>status (nebula::HesaiPtpConfig)</li> <li>scaledLastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> <li>SendReset (nebula::drivers::HesaiHwInterface)</li> <li>SetClockSource (nebula::drivers::HesaiHwInterface)</li> <li>SetControlPort (nebula::drivers::HesaiHwInterface)</li> <li>SetDestinationIp (nebula::drivers::HesaiHwInterface)</li> <li>SetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>SetLogger (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>SetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>SetPtpConfigSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetReturnMode (nebula::drivers::HesaiHwInterface)</li> <li>SetRotDir (nebula::drivers::HesaiHwInterface)</li> <li>SetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>SetSpinRate (nebula::drivers::HesaiHwInterface)</li> <li>SetSpinSpeedAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetStandbyMode (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngle (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngleSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetTargetModel (nebula::drivers::HesaiHwInterface)</li> <li>SetTriggerMethod (nebula::drivers::HesaiHwInterface)</li> <li>scan_cloud_ptr_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>scan_reception_callback_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>sensor_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>str_cb (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>SaveConfig (nebula::drivers::VelodyneHwInterface)</li> <li>SaveConfigAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEnd (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEndAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStart (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStartAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcp (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcpAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGateway (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGatewayAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMask (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMaskAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnType (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnTypeAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpm (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpmAsync (nebula::drivers::VelodyneHwInterface)</li> <li>StringCallback (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#t","title":"t","text":"<ul> <li>trigger_method (nebula::HesaiConfig)</li> <li>temperature (nebula::HesaiLidarStatus)</li> <li>total_operation_time (nebula::HesaiLidarStatus)</li> <li>time_flags (nebula::HesaiPtpDiagGrandmaster)</li> <li>time_source (nebula::HesaiPtpDiagGrandmaster)</li> <li>target_model_no (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_ (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_s_ (nebula::drivers::HesaiHwInterface)</li> <li>timeout_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>tms_ (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>TARGET_DIAG (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_FOV (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_HOST (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_NET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_RESET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SAVE (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SETTING (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SNAPSHOT (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_STATUS (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#u","title":"u","text":"<ul> <li>udp_seq (nebula::HesaiConfig)</li> <li>utc_offset (nebula::HesaiPtpDiagGrandmaster)</li> <li>UseHttpGetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>UseHttpSetSpinRate (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#v","title":"v","text":"<ul> <li>vlan_flag (nebula::HesaiConfig)</li> <li>vlan_id (nebula::HesaiConfig)</li> <li>versionNumber (nebula::HesaiPtpDiagPort)</li> <li>VelodyneHwInterface (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_members/#w","title":"w","text":"<ul> <li>wl (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_hw_interfaces/class_member_functions/#c","title":"c","text":"<ul> <li>CheckAndSetConfig (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>CheckLock (nebula::drivers::HesaiHwInterface)</li> <li>CheckUnlock (nebula::drivers::HesaiHwInterface)</li> <li>CloudInterfaceStart (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>CloudInterfaceStop (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>CheckAndSetConfigBySnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#f","title":"f","text":"<ul> <li>FinalizeTcpDriver (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#g","title":"g","text":"<ul> <li>get_str_model (nebula::HesaiInventory)</li> <li>get_str_gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>get_str_gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>get_str_ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>GetCalibrationConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>GetConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetHttpClientDriverOnce (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>GetIOContext (nebula::drivers::HesaiHwInterface)</li> <li>GetInventory (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarMonitorAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>GetLidarStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagGrandmaster (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagPort (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagStatus (nebula::drivers::HesaiHwInterface)</li> <li>GetPtpDiagTime (nebula::drivers::HesaiHwInterface)</li> <li>GetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>GetDiag (nebula::drivers::VelodyneHwInterface)</li> <li>GetDiagAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshot (nebula::drivers::VelodyneHwInterface)</li> <li>GetSnapshotAsync (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatus (nebula::drivers::VelodyneHwInterface)</li> <li>GetStatusAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiInventory (nebula::HesaiInventory)</li> <li>HesaiLidarStatus (nebula::HesaiLidarStatus)</li> <li>HesaiPtpDiagPort (nebula::HesaiPtpDiagPort)</li> <li>HesaiPtpDiagTime (nebula::HesaiPtpDiagTime)</li> <li>HesaiHwInterface (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#i","title":"i","text":"<ul> <li>IOContextRun (nebula::drivers::HesaiHwInterface)</li> <li>InitializeTcpDriver (nebula::drivers::HesaiHwInterface)</li> <li>InitHttpClient (nebula::drivers::VelodyneHwInterface)</li> <li>InitHttpClientAsync (nebula::drivers::VelodyneHwInterface)</li> <li>InitializeSensorConfiguration (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#l","title":"l","text":"<ul> <li>LaserOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOffAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOn (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnAsync (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOff (nebula::drivers::VelodyneHwInterface)</li> <li>LaserOnOffAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#n","title":"n","text":"<ul> <li>NebulaHwInterfaceBase (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (nebula::drivers::NebulaHwInterfaceBase)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#p","title":"p","text":"<ul> <li>ParseJson (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintDebug (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintError (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>PrintInfo (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#r","title":"r","text":"<ul> <li>ReceiveCloudPacketCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>RegisterScanCallback (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>ResetSystem (nebula::drivers::VelodyneHwInterface)</li> <li>ResetSystemAsync (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#s","title":"s","text":"<ul> <li>SendReset (nebula::drivers::HesaiHwInterface)</li> <li>SetClockSource (nebula::drivers::HesaiHwInterface)</li> <li>SetControlPort (nebula::drivers::HesaiHwInterface)</li> <li>SetDestinationIp (nebula::drivers::HesaiHwInterface)</li> <li>SetLidarRange (nebula::drivers::HesaiHwInterface)</li> <li>SetLogger (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>SetPtpConfig (nebula::drivers::HesaiHwInterface)</li> <li>SetPtpConfigSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetReturnMode (nebula::drivers::HesaiHwInterface)</li> <li>SetRotDir (nebula::drivers::HesaiHwInterface)</li> <li>SetSensorConfiguration (nebula::drivers::HesaiHwInterface, nebula::drivers::NebulaHwInterfaceBase, nebula::drivers::VelodyneHwInterface)</li> <li>SetSpinRate (nebula::drivers::HesaiHwInterface)</li> <li>SetSpinSpeedAsyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetStandbyMode (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngle (nebula::drivers::HesaiHwInterface)</li> <li>SetSyncAngleSyncHttp (nebula::drivers::HesaiHwInterface)</li> <li>SetTargetModel (nebula::drivers::HesaiHwInterface)</li> <li>SetTriggerMethod (nebula::drivers::HesaiHwInterface)</li> <li>str_cb (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibration (nebula::drivers::HesaiHwInterface)</li> <li>syncGetLidarCalibrationFromSensor (nebula::drivers::HesaiHwInterface)</li> <li>SaveConfig (nebula::drivers::VelodyneHwInterface)</li> <li>SaveConfigAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEnd (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovEndAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStart (nebula::drivers::VelodyneHwInterface)</li> <li>SetFovStartAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostDportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTport (nebula::drivers::VelodyneHwInterface)</li> <li>SetHostTportAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddr (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetAddrAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcp (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetDhcpAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGateway (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetGatewayAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMask (nebula::drivers::VelodyneHwInterface)</li> <li>SetNetMaskAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnType (nebula::drivers::VelodyneHwInterface)</li> <li>SetReturnTypeAsync (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpm (nebula::drivers::VelodyneHwInterface)</li> <li>SetRpmAsync (nebula::drivers::VelodyneHwInterface)</li> <li>StringCallback (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#u","title":"u","text":"<ul> <li>UseHttpGetLidarMonitor (nebula::drivers::HesaiHwInterface)</li> <li>UseHttpSetSpinRate (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneHwInterface (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_hw_interfaces/class_member_variables/#a","title":"a","text":"<ul> <li>angle_offset (nebula::HesaiInventory)</li> <li>announceReceiptTimeout (nebula::HesaiPtpDiagPort)</li> <li>azimuth_index_ (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#b","title":"b","text":"<ul> <li>boost_ctx_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#c","title":"c","text":"<ul> <li>clock_data_fmt (nebula::HesaiConfig)</li> <li>clock_source (nebula::HesaiConfig)</li> <li>control_fw_ver (nebula::HesaiInventory)</li> <li>clockQuality (nebula::HesaiPtpDiagGrandmaster)</li> <li>cumulativeScaledRateOffset (nebula::HesaiPtpDiagTime)</li> <li>calibration_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_io_context_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>cloud_udp_driver_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#d","title":"d","text":"<ul> <li>dest_LiDAR_udp_port (nebula::HesaiConfig)</li> <li>dest_gps_udp_port (nebula::HesaiConfig)</li> <li>dest_ipaddr (nebula::HesaiConfig)</li> <li>date_of_manufacture (nebula::HesaiInventory)</li> <li>domain (nebula::HesaiPtpConfig)</li> <li>delayMechanism (nebula::HesaiPtpDiagPort)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#e","title":"e","text":"<ul> <li>end (nebula::HesaiLidarRangeAll)</li> <li>elapsed_millisec (nebula::HesaiPtpDiagStatus)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#g","title":"g","text":"<ul> <li>gateway (nebula::HesaiConfig)</li> <li>gps_gprmc_status (nebula::HesaiLidarStatus)</li> <li>gps_pps_lock (nebula::HesaiLidarStatus)</li> <li>gmIdentity (nebula::HesaiPtpDiagTime)</li> <li>gmPresent (nebula::HesaiPtpDiagTime)</li> <li>gmTimeBaseIndicator (nebula::HesaiPtpDiagTime)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#h","title":"h","text":"<ul> <li>hw_ver (nebula::HesaiInventory)</li> <li>http_client_driver_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#i","title":"i","text":"<ul> <li>ipaddr (nebula::HesaiConfig)</li> <li>input_current (nebula::HesaiLidarMonitor)</li> <li>input_power (nebula::HesaiLidarMonitor)</li> <li>input_voltage (nebula::HesaiLidarMonitor)</li> <li>ingress_time (nebula::HesaiPtpDiagTime)</li> <li>is_solid_state (nebula::drivers::HesaiHwInterface)</li> <li>is_valid_packet_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#l","title":"l","text":"<ul> <li>logAnnounceInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinDelayReqInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logSyncInterval (nebula::HesaiPtpConfig, nebula::HesaiPtpDiagPort)</li> <li>logMinPdelayReqInterval (nebula::HesaiPtpDiagPort)</li> <li>lastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#m","title":"m","text":"<ul> <li>mask (nebula::HesaiConfig)</li> <li>motor_status (nebula::HesaiConfig)</li> <li>mac (nebula::HesaiInventory)</li> <li>model (nebula::HesaiInventory)</li> <li>motor_type (nebula::HesaiInventory)</li> <li>method (nebula::HesaiLidarRangeAll)</li> <li>motor_speed (nebula::HesaiLidarStatus)</li> <li>master_offset (nebula::HesaiPtpDiagStatus, nebula::HesaiPtpDiagTime)</li> <li>m_owned_ctx (nebula::drivers::HesaiHwInterface)</li> <li>m_owned_ctx_s (nebula::drivers::HesaiHwInterface)</li> <li>mtu_size_ (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#n","title":"n","text":"<ul> <li>noise_filtering (nebula::HesaiConfig)</li> <li>num_of_lines (nebula::HesaiInventory)</li> <li>network (nebula::HesaiPtpConfig)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#p","title":"p","text":"<ul> <li>ptp_clock_status (nebula::HesaiLidarStatus)</li> <li>profile (nebula::HesaiPtpConfig)</li> <li>peerMeanPathDelay (nebula::HesaiPtpDiagPort)</li> <li>portIdentity (nebula::HesaiPtpDiagPort)</li> <li>portState (nebula::HesaiPtpDiagPort)</li> <li>ptp_state (nebula::HesaiPtpDiagStatus)</li> <li>parent_node_logger (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>prev_phase_ (nebula::drivers::HesaiHwInterface)</li> <li>packet_first_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_ (nebula::drivers::VelodyneHwInterface)</li> <li>packet_last_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>phase_ (nebula::drivers::VelodyneHwInterface)</li> <li>prev_packet_first_azm_phased_ (nebula::drivers::VelodyneHwInterface)</li> <li>processed_packets_ (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#r","title":"r","text":"<ul> <li>reflectivity_mapping (nebula::HesaiConfig)</li> <li>reserved (nebula::HesaiConfig, nebula::HesaiInventory, nebula::HesaiLidarMonitor, nebula::HesaiLidarStatus)</li> <li>return_mode (nebula::HesaiConfig)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#s","title":"s","text":"<ul> <li>spin_rate (nebula::HesaiConfig)</li> <li>standby_mode (nebula::HesaiConfig)</li> <li>start_angle (nebula::HesaiConfig)</li> <li>stop_angle (nebula::HesaiConfig)</li> <li>sync (nebula::HesaiConfig)</li> <li>sync_angle (nebula::HesaiConfig)</li> <li>sensor_fw_ver (nebula::HesaiInventory)</li> <li>sn (nebula::HesaiInventory)</li> <li>sw_ver (nebula::HesaiInventory)</li> <li>start (nebula::HesaiLidarRangeAll)</li> <li>startup_times (nebula::HesaiLidarStatus)</li> <li>system_uptime (nebula::HesaiLidarStatus)</li> <li>status (nebula::HesaiPtpConfig)</li> <li>scaledLastGmPhaseChange (nebula::HesaiPtpDiagTime)</li> <li>scan_cloud_ptr_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>scan_reception_callback_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> <li>sensor_configuration_ (nebula::drivers::HesaiHwInterface, nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#t","title":"t","text":"<ul> <li>trigger_method (nebula::HesaiConfig)</li> <li>temperature (nebula::HesaiLidarStatus)</li> <li>total_operation_time (nebula::HesaiLidarStatus)</li> <li>time_flags (nebula::HesaiPtpDiagGrandmaster)</li> <li>time_source (nebula::HesaiPtpDiagGrandmaster)</li> <li>target_model_no (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_ (nebula::drivers::HesaiHwInterface)</li> <li>tcp_driver_s_ (nebula::drivers::HesaiHwInterface)</li> <li>timeout_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_ (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tm_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>tms_ (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt (nebula::drivers::HesaiHwInterface)</li> <li>tms_fail_cnt_max (nebula::drivers::HesaiHwInterface)</li> <li>TARGET_DIAG (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_FOV (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_HOST (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_NET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_RESET (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SAVE (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SETTING (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_SNAPSHOT (nebula::drivers::VelodyneHwInterface)</li> <li>TARGET_STATUS (nebula::drivers::VelodyneHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#u","title":"u","text":"<ul> <li>udp_seq (nebula::HesaiConfig)</li> <li>utc_offset (nebula::HesaiPtpDiagGrandmaster)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#v","title":"v","text":"<ul> <li>vlan_flag (nebula::HesaiConfig)</li> <li>vlan_id (nebula::HesaiConfig)</li> <li>versionNumber (nebula::HesaiPtpDiagPort)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_variables/#w","title":"w","text":"<ul> <li>wl (nebula::drivers::HesaiHwInterface)</li> </ul>"},{"location":"nebula_hw_interfaces/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_hw_interfaces/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"nebula_hw_interfaces/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_hw_interfaces/namespace_members/#h","title":"h","text":"<ul> <li>HESAI_LIDAR_GPS_CLOCK_SOURCE (nebula::drivers)</li> <li>HESAI_LIDAR_PTP_CLOCK_SOURCE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_members/#m","title":"m","text":"<ul> <li>MTU_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_members/#p","title":"p","text":"<ul> <li>PANDAR128_E4X_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR128_E4X_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40P_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARAT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32M_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32_PACKET_SIZE (nebula::drivers)</li> <li>PTC_COMMAND_DUMMY_BYTE (nebula::drivers)</li> <li>PTC_COMMAND_GET_CONFIG_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_INVENTORY_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_CALIBRATION (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_GET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_HIGH (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_LOW (nebula::drivers)</li> <li>PTC_COMMAND_LIDAR_MONITOR (nebula::drivers)</li> <li>PTC_COMMAND_PTP_DIAGNOSTICS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP (nebula::drivers)</li> <li>PTC_COMMAND_PTP_PORT_DATA_SET (nebula::drivers)</li> <li>PTC_COMMAND_PTP_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_TIME_STATUS_NP (nebula::drivers)</li> <li>PTC_COMMAND_RESET (nebula::drivers)</li> <li>PTC_COMMAND_SET_CLOCK_SOURCE (nebula::drivers)</li> <li>PTC_COMMAND_SET_CONTROL_PORT (nebula::drivers)</li> <li>PTC_COMMAND_SET_DESTINATION_IP (nebula::drivers)</li> <li>PTC_COMMAND_SET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_SET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_SET_RETURN_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_ROTATE_DIRECTION (nebula::drivers)</li> <li>PTC_COMMAND_SET_SPIN_RATE (nebula::drivers)</li> <li>PTC_COMMAND_SET_STANDBY_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_SYNC_ANGLE (nebula::drivers)</li> <li>PTC_COMMAND_SET_TRIGGER_METHOD (nebula::drivers)</li> <li>PTP_DOMAIN_ID (nebula::drivers)</li> <li>PTP_LOG_ANNOUNCE_INTERVAL (nebula::drivers)</li> <li>PTP_LOG_MIN_DELAY_INTERVAL (nebula::drivers)</li> <li>PTP_NETWORK_TRANSPORT (nebula::drivers)</li> <li>PTP_PROFILE (nebula::drivers)</li> <li>PTP_SYNC_INTERVAL (nebula::drivers)</li> <li>PandarTcpCommandPort (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"nebula_hw_interfaces/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"nebula_hw_interfaces/namespace_member_variables/#h","title":"h","text":"<ul> <li>HESAI_LIDAR_GPS_CLOCK_SOURCE (nebula::drivers)</li> <li>HESAI_LIDAR_PTP_CLOCK_SOURCE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_variables/#m","title":"m","text":"<ul> <li>MTU_SIZE (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_variables/#p","title":"p","text":"<ul> <li>PANDAR128_E4X_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR128_E4X_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40P_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR40_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_EXTENDED_PACKET_SIZE (nebula::drivers)</li> <li>PANDAR64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARAT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT128_PACKET_SIZE (nebula::drivers)</li> <li>PANDARQT64_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32M_PACKET_SIZE (nebula::drivers)</li> <li>PANDARXT32_PACKET_SIZE (nebula::drivers)</li> <li>PTC_COMMAND_DUMMY_BYTE (nebula::drivers)</li> <li>PTC_COMMAND_GET_CONFIG_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_INVENTORY_INFO (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_CALIBRATION (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_GET_LIDAR_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_GET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_HIGH (nebula::drivers)</li> <li>PTC_COMMAND_HEADER_LOW (nebula::drivers)</li> <li>PTC_COMMAND_LIDAR_MONITOR (nebula::drivers)</li> <li>PTC_COMMAND_PTP_DIAGNOSTICS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_GRANDMASTER_SETTINGS_NP (nebula::drivers)</li> <li>PTC_COMMAND_PTP_PORT_DATA_SET (nebula::drivers)</li> <li>PTC_COMMAND_PTP_STATUS (nebula::drivers)</li> <li>PTC_COMMAND_PTP_TIME_STATUS_NP (nebula::drivers)</li> <li>PTC_COMMAND_RESET (nebula::drivers)</li> <li>PTC_COMMAND_SET_CLOCK_SOURCE (nebula::drivers)</li> <li>PTC_COMMAND_SET_CONTROL_PORT (nebula::drivers)</li> <li>PTC_COMMAND_SET_DESTINATION_IP (nebula::drivers)</li> <li>PTC_COMMAND_SET_LIDAR_RANGE (nebula::drivers)</li> <li>PTC_COMMAND_SET_PTP_CONFIG (nebula::drivers)</li> <li>PTC_COMMAND_SET_RETURN_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_ROTATE_DIRECTION (nebula::drivers)</li> <li>PTC_COMMAND_SET_SPIN_RATE (nebula::drivers)</li> <li>PTC_COMMAND_SET_STANDBY_MODE (nebula::drivers)</li> <li>PTC_COMMAND_SET_SYNC_ANGLE (nebula::drivers)</li> <li>PTC_COMMAND_SET_TRIGGER_METHOD (nebula::drivers)</li> <li>PTP_DOMAIN_ID (nebula::drivers)</li> <li>PTP_LOG_ANNOUNCE_INTERVAL (nebula::drivers)</li> <li>PTP_LOG_MIN_DELAY_INTERVAL (nebula::drivers)</li> <li>PTP_NETWORK_TRANSPORT (nebula::drivers)</li> <li>PTP_PROFILE (nebula::drivers)</li> <li>PTP_SYNC_INTERVAL (nebula::drivers)</li> <li>PandarTcpCommandPort (nebula::drivers)</li> </ul>"},{"location":"nebula_hw_interfaces/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"nebula_hw_interfaces/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"nebula_hw_interfaces/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_hw_interfaces/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_hw_interfaces/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_hw_interfaces/links/","title":"Nebula HW Interfaces","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"nebula_ros/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace ros <ul> <li>class HesaiDriverRosWrapper Ros wrapper of hesai driver. </li> <li>class HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. </li> <li>class HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. </li> <li>class NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. </li> <li>class NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. </li> <li>class NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. </li> <li>class VelodyneDriverRosWrapper Ros wrapper of velodyne driver. </li> <li>class VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. </li> <li>class VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. </li> </ul> </li> </ul> </li> <li>namespace rclcpp </li> </ul>"},{"location":"nebula_ros/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir nebula_ros <ul> <li>dir include <ul> <li>dir nebula_ros <ul> <li>dir common <ul> <li>file nebula_driver_ros_wrapper_base.hpp </li> <li>file nebula_hw_interface_ros_wrapper_base.hpp </li> <li>file nebula_hw_monitor_ros_wrapper_base.hpp </li> </ul> </li> <li>dir hesai <ul> <li>file hesai_decoder_ros_wrapper.hpp </li> <li>file hesai_hw_interface_ros_wrapper.hpp </li> <li>file hesai_hw_monitor_ros_wrapper.hpp </li> </ul> </li> <li>dir velodyne <ul> <li>file velodyne_decoder_ros_wrapper.hpp </li> <li>file velodyne_hw_interface_ros_wrapper.hpp </li> <li>file velodyne_hw_monitor_ros_wrapper.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"nebula_ros/namespacenebula/","title":"Namespace nebula","text":"<p>Namespace List &gt; nebula</p>"},{"location":"nebula_ros/namespacenebula/#namespaces","title":"Namespaces","text":"Type Name namespace ros <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/namespacenebula_1_1ros/","title":"Namespace nebula::ros","text":"<p>Namespace List &gt; nebula &gt; ros</p>"},{"location":"nebula_ros/namespacenebula_1_1ros/#classes","title":"Classes","text":"Type Name class HesaiDriverRosWrapper Ros wrapper of hesai driver. class HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. class HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. class NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. class NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. class NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. class VelodyneDriverRosWrapper Ros wrapper of velodyne driver. class VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. class VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver."},{"location":"nebula_ros/namespacenebula_1_1ros/#public-functions","title":"Public Functions","text":"Type Name bool get_param (const std::vector&lt; rclcpp::Parameter &gt; &amp; p, const std::string &amp; name, T &amp; value) Get parameter from rclcpp::Parameter."},{"location":"nebula_ros/namespacenebula_1_1ros/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/namespacenebula_1_1ros/#function-get_param","title":"function get_param","text":"<p>Get parameter from rclcpp::Parameter. <pre><code>template&lt;typename T typename T&gt;\nbool nebula::ros::get_param (\nconst std::vector&lt; rclcpp::Parameter &gt; &amp; p,\nconst std::string &amp; name,\nT &amp; value\n) </code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> </li> </ul> <p>Parameters:</p> <ul> <li><code>p</code> Parameter from rclcpp parameter callback </li> <li><code>name</code> Target parameter name </li> <li><code>value</code> Corresponding value </li> </ul> <p>Returns:</p> <p>Whether the target name existed </p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/","title":"Class nebula::ros::HesaiDriverRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; HesaiDriverRosWrapper</p> <p>Ros wrapper of hesai driver. </p> <ul> <li><code>#include &lt;hesai_decoder_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaDriverRosWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetStatus () Get current status of this driver. HesaiDriverRosWrapper (const rclcpp::NodeOptions &amp; options)  void ReceiveScanMsgCallback (const pandar_msgs::msg::PandarScan::SharedPtr scan_msg) Callback for PandarScan subscriber."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#public-functions-inherited-from-nebularosnebuladriverroswrapperbase","title":"Public Functions inherited from nebula::ros::NebulaDriverRosWrapperBase","text":"<p>See nebula::ros::NebulaDriverRosWrapperBase</p> Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::ros::HesaiDriverRosWrapper::GetStatus () </code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#function-hesaidriverroswrapper","title":"function HesaiDriverRosWrapper","text":"<pre><code>explicit nebula::ros::HesaiDriverRosWrapper::HesaiDriverRosWrapper (\nconst rclcpp::NodeOptions &amp; options\n) </code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiDriverRosWrapper/#function-receivescanmsgcallback","title":"function ReceiveScanMsgCallback","text":"<p>Callback for PandarScan subscriber. <pre><code>void nebula::ros::HesaiDriverRosWrapper::ReceiveScanMsgCallback (\nconst pandar_msgs::msg::PandarScan::SharedPtr scan_msg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_msg</code> Received PandarScan </li> </ul> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/","title":"Class nebula::ros::HesaiHwInterfaceRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; HesaiHwInterfaceRosWrapper</p> <p>Hardware interface ros wrapper of hesai driver. </p> <ul> <li><code>#include &lt;hesai_hw_interface_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwInterfaceWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::HesaiSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. HesaiHwInterfaceRosWrapper (const rclcpp::NodeOptions &amp; options)  virtual Status Shutdown () overrideShutdown (not used) virtual Status StreamStart () overrideStart point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () overrideStop point cloud streaming (not used) ~HesaiHwInterfaceRosWrapper () noexcept override"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#public-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#protected-attributes-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Attributes inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#protected-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::HesaiHwInterfaceRosWrapper::GetParameters (\ndrivers::HesaiSensorConfiguration &amp; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-hesaihwinterfaceroswrapper","title":"function HesaiHwInterfaceRosWrapper","text":"<pre><code>explicit nebula::ros::HesaiHwInterfaceRosWrapper::HesaiHwInterfaceRosWrapper (\nconst rclcpp::NodeOptions &amp; options\n) </code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::HesaiHwInterfaceRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::HesaiHwInterfaceRosWrapper::StreamStart () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::HesaiHwInterfaceRosWrapper::StreamStop () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwInterfaceRosWrapper/#function-hesaihwinterfaceroswrapper_1","title":"function ~HesaiHwInterfaceRosWrapper","text":"<pre><code>nebula::ros::HesaiHwInterfaceRosWrapper::~HesaiHwInterfaceRosWrapper () noexcept override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/","title":"Class nebula::ros::HesaiHwMonitorRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; HesaiHwMonitorRosWrapper</p> <p>Hardware monitor ros wrapper of hesai driver. </p> <ul> <li><code>#include &lt;hesai_hw_monitor_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwMonitorWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::HesaiSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. HesaiHwMonitorRosWrapper (const rclcpp::NodeOptions &amp; options)  virtual Status MonitorStart () overrideNot used. virtual Status MonitorStop () overrideNot used. virtual Status Shutdown () overrideNot used. ~HesaiHwMonitorRosWrapper () noexcept override"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#public-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#protected-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::HesaiHwMonitorRosWrapper::GetParameters (\ndrivers::HesaiSensorConfiguration &amp; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-hesaihwmonitorroswrapper","title":"function HesaiHwMonitorRosWrapper","text":"<pre><code>explicit nebula::ros::HesaiHwMonitorRosWrapper::HesaiHwMonitorRosWrapper (\nconst rclcpp::NodeOptions &amp; options\n) </code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-monitorstart","title":"function MonitorStart","text":"<p>Not used. <pre><code>virtual Status nebula::ros::HesaiHwMonitorRosWrapper::MonitorStart () override\n</code></pre></p> <p>Returns:</p> <p>Current status </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-monitorstop","title":"function MonitorStop","text":"<p>Not used. <pre><code>virtual Status nebula::ros::HesaiHwMonitorRosWrapper::MonitorStop () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Not used. <pre><code>virtual Status nebula::ros::HesaiHwMonitorRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1HesaiHwMonitorRosWrapper/#function-hesaihwmonitorroswrapper_1","title":"function ~HesaiHwMonitorRosWrapper","text":"<pre><code>nebula::ros::HesaiHwMonitorRosWrapper::~HesaiHwMonitorRosWrapper () noexcept override\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/","title":"Class nebula::ros::NebulaDriverRosWrapperBase","text":"<p>ClassList &gt; nebula &gt; ros &gt; NebulaDriverRosWrapperBase</p> <p>Base class for ros wrapper of each sensor driver. </p> <ul> <li><code>#include &lt;nebula_driver_ros_wrapper_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::ros::HesaiDriverRosWrapper,  nebula::ros::VelodyneDriverRosWrapper</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#public-functions","title":"Public Functions","text":"Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-nebuladriverroswrapperbase-13","title":"function NebulaDriverRosWrapperBase [1/3]","text":"<pre><code>nebula::ros::NebulaDriverRosWrapperBase::NebulaDriverRosWrapperBase () = default\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-nebuladriverroswrapperbase-23","title":"function NebulaDriverRosWrapperBase [2/3]","text":"<pre><code>nebula::ros::NebulaDriverRosWrapperBase::NebulaDriverRosWrapperBase (\nNebulaDriverRosWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-nebuladriverroswrapperbase-33","title":"function NebulaDriverRosWrapperBase [3/3]","text":"<pre><code>nebula::ros::NebulaDriverRosWrapperBase::NebulaDriverRosWrapperBase (\nconst NebulaDriverRosWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaDriverRosWrapperBase &amp; nebula::ros::NebulaDriverRosWrapperBase::operator= (\nNebulaDriverRosWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaDriverRosWrapperBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaDriverRosWrapperBase &amp; nebula::ros::NebulaDriverRosWrapperBase::operator= (\nconst NebulaDriverRosWrapperBase &amp; c\n) = delete\n</code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/","title":"Class nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>ClassList &gt; nebula &gt; ros &gt; NebulaHwInterfaceWrapperBase</p> <p>Base class for hardware interface ros wrapper of each LiDAR. </p> <ul> <li><code>#include &lt;nebula_hw_interface_ros_wrapper_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::ros::HesaiHwInterfaceRosWrapper,  nebula::ros::VelodyneHwInterfaceRosWrapper</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#public-functions","title":"Public Functions","text":"Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-attributes","title":"Protected Attributes","text":"Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-functions","title":"Protected Functions","text":"Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-nebulahwinterfacewrapperbase-13","title":"function NebulaHwInterfaceWrapperBase [1/3]","text":"<pre><code>nebula::ros::NebulaHwInterfaceWrapperBase::NebulaHwInterfaceWrapperBase () = default\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-nebulahwinterfacewrapperbase-23","title":"function NebulaHwInterfaceWrapperBase [2/3]","text":"<pre><code>nebula::ros::NebulaHwInterfaceWrapperBase::NebulaHwInterfaceWrapperBase (\nNebulaHwInterfaceWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-nebulahwinterfacewrapperbase-33","title":"function NebulaHwInterfaceWrapperBase [3/3]","text":"<pre><code>nebula::ros::NebulaHwInterfaceWrapperBase::NebulaHwInterfaceWrapperBase (\nconst NebulaHwInterfaceWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaHwInterfaceWrapperBase &amp; nebula::ros::NebulaHwInterfaceWrapperBase::operator= (\nNebulaHwInterfaceWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaHwInterfaceWrapperBase &amp; nebula::ros::NebulaHwInterfaceWrapperBase::operator= (\nconst NebulaHwInterfaceWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#variable-setup_sensor","title":"variable setup_sensor","text":"<pre><code>bool nebula::ros::NebulaHwInterfaceWrapperBase::setup_sensor;\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwInterfaceWrapperBase/#function-initializehwinterface","title":"function InitializeHwInterface","text":"<p>Virtual function for initializing hardware interface ros wrapper. <pre><code>virtual Status nebula::ros::NebulaHwInterfaceWrapperBase::InitializeHwInterface (\nconst drivers::SensorConfigurationBase &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/","title":"Class nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>ClassList &gt; nebula &gt; ros &gt; NebulaHwMonitorWrapperBase</p> <p>Base class for hardware monitor ros wrapper of each LiDAR. </p> <ul> <li><code>#include &lt;nebula_hw_monitor_ros_wrapper_base.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: nebula::ros::HesaiHwMonitorRosWrapper,  nebula::ros::VelodyneHwMonitorRosWrapper</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#public-functions","title":"Public Functions","text":"Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#protected-functions","title":"Protected Functions","text":"Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-monitorstart","title":"function MonitorStart","text":"<p>Start monitoring (not used) <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-monitorstop","title":"function MonitorStop","text":"<p>Stop monitoring (not used) <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-nebulahwmonitorwrapperbase-13","title":"function NebulaHwMonitorWrapperBase [1/3]","text":"<pre><code>nebula::ros::NebulaHwMonitorWrapperBase::NebulaHwMonitorWrapperBase () = default\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-nebulahwmonitorwrapperbase-23","title":"function NebulaHwMonitorWrapperBase [2/3]","text":"<pre><code>nebula::ros::NebulaHwMonitorWrapperBase::NebulaHwMonitorWrapperBase (\nNebulaHwMonitorWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-nebulahwmonitorwrapperbase-33","title":"function NebulaHwMonitorWrapperBase [3/3]","text":"<pre><code>nebula::ros::NebulaHwMonitorWrapperBase::NebulaHwMonitorWrapperBase (\nconst NebulaHwMonitorWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::Shutdown () = 0\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-operator","title":"function operator=","text":"<pre><code>NebulaHwMonitorWrapperBase &amp; nebula::ros::NebulaHwMonitorWrapperBase::operator= (\nNebulaHwMonitorWrapperBase &amp;&amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-operator_1","title":"function operator=","text":"<pre><code>NebulaHwMonitorWrapperBase &amp; nebula::ros::NebulaHwMonitorWrapperBase::operator= (\nconst NebulaHwMonitorWrapperBase &amp; c\n) = delete\n</code></pre>"},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1NebulaHwMonitorWrapperBase/#function-initializehwmonitor","title":"function InitializeHwMonitor","text":"<p>Virtual function for initializing hardware monitor ros wrapper. <pre><code>virtual Status nebula::ros::NebulaHwMonitorWrapperBase::InitializeHwMonitor (\nconst drivers::SensorConfigurationBase &amp; sensor_configuration\n) = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> SensorConfiguration for this driver </li> </ul> <p>Returns:</p> <p>Resulting status </p> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/","title":"Class nebula::ros::VelodyneDriverRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; VelodyneDriverRosWrapper</p> <p>Ros wrapper of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_decoder_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaDriverRosWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetStatus () Get current status of this driver. void ReceiveScanMsgCallback (const velodyne_msgs::msg::VelodyneScan::SharedPtr scan_msg) Callback for VelodyneScan subscriber. VelodyneDriverRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#public-functions-inherited-from-nebularosnebuladriverroswrapperbase","title":"Public Functions inherited from nebula::ros::NebulaDriverRosWrapperBase","text":"<p>See nebula::ros::NebulaDriverRosWrapperBase</p> Type Name NebulaDriverRosWrapperBase () = default NebulaDriverRosWrapperBase (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase (const NebulaDriverRosWrapperBase &amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (NebulaDriverRosWrapperBase &amp;&amp; c) = delete NebulaDriverRosWrapperBase &amp; operator= (const NebulaDriverRosWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#function-getstatus","title":"function GetStatus","text":"<p>Get current status of this driver. <pre><code>Status nebula::ros::VelodyneDriverRosWrapper::GetStatus () </code></pre></p> <p>Returns:</p> <p>Current status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#function-receivescanmsgcallback","title":"function ReceiveScanMsgCallback","text":"<p>Callback for VelodyneScan subscriber. <pre><code>void nebula::ros::VelodyneDriverRosWrapper::ReceiveScanMsgCallback (\nconst velodyne_msgs::msg::VelodyneScan::SharedPtr scan_msg\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>scan_msg</code> Received VelodyneScan </li> </ul>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneDriverRosWrapper/#function-velodynedriverroswrapper","title":"function VelodyneDriverRosWrapper","text":"<pre><code>explicit nebula::ros::VelodyneDriverRosWrapper::VelodyneDriverRosWrapper (\nconst rclcpp::NodeOptions &amp; options\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/","title":"Class nebula::ros::VelodyneHwInterfaceRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; VelodyneHwInterfaceRosWrapper</p> <p>Hardware interface ros wrapper of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_hw_interface_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwInterfaceWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::VelodyneSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. virtual Status Shutdown () overrideShutdown (not used) virtual Status StreamStart () overrideStart point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () overrideStop point cloud streaming (not used) VelodyneHwInterfaceRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#public-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name NebulaHwInterfaceWrapperBase () = default NebulaHwInterfaceWrapperBase (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase (const NebulaHwInterfaceWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) virtual Status StreamStart () = 0Start point cloud streaming (Call CloudInterfaceStart of HwInterface) virtual Status StreamStop () = 0Stop point cloud streaming (not used) NebulaHwInterfaceWrapperBase &amp; operator= (NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete NebulaHwInterfaceWrapperBase &amp; operator= (const NebulaHwInterfaceWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#protected-attributes-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Attributes inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name bool setup_sensor Enable sensor setup during initialization and set_parameters_callback."},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#protected-functions-inherited-from-nebularosnebulahwinterfacewrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwInterfaceWrapperBase","text":"<p>See nebula::ros::NebulaHwInterfaceWrapperBase</p> Type Name virtual Status InitializeHwInterface (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware interface ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::VelodyneHwInterfaceRosWrapper::GetParameters (\ndrivers::VelodyneSensorConfiguration &amp; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Shutdown (not used) <pre><code>virtual Status nebula::ros::VelodyneHwInterfaceRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-streamstart","title":"function StreamStart","text":"<p>Start point cloud streaming (Call CloudInterfaceStart of HwInterface) <pre><code>virtual Status nebula::ros::VelodyneHwInterfaceRosWrapper::StreamStart () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-streamstop","title":"function StreamStop","text":"<p>Stop point cloud streaming (not used) <pre><code>virtual Status nebula::ros::VelodyneHwInterfaceRosWrapper::StreamStop () override\n</code></pre></p> <p>Returns:</p> <p>Resulting status </p> <p>Implements nebula::ros::NebulaHwInterfaceWrapperBase::StreamStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwInterfaceRosWrapper/#function-velodynehwinterfaceroswrapper","title":"function VelodyneHwInterfaceRosWrapper","text":"<pre><code>explicit nebula::ros::VelodyneHwInterfaceRosWrapper::VelodyneHwInterfaceRosWrapper (\nconst rclcpp::NodeOptions &amp; options\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/","title":"Class nebula::ros::VelodyneHwMonitorRosWrapper","text":"<p>ClassList &gt; nebula &gt; ros &gt; VelodyneHwMonitorRosWrapper</p> <p>Hardware monitor ros wrapper of velodyne driver. </p> <ul> <li><code>#include &lt;velodyne_hw_monitor_ros_wrapper.hpp&gt;</code></li> </ul> <p>Inherits the following classes: rclcpp::Node,  nebula::ros::NebulaHwMonitorWrapperBase</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#public-functions","title":"Public Functions","text":"Type Name Status GetParameters (drivers::VelodyneSensorConfiguration &amp; sensor_configuration) Get configurations from ros parameters. virtual Status MonitorStart () overrideNot used. virtual Status MonitorStop () overrideNot used. virtual Status Shutdown () overrideNot used. VelodyneHwMonitorRosWrapper (const rclcpp::NodeOptions &amp; options)"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#public-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Public Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status MonitorStart () = 0Start monitoring (not used) virtual Status MonitorStop () = 0Stop monitoring (not used) NebulaHwMonitorWrapperBase () = default NebulaHwMonitorWrapperBase (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase (const NebulaHwMonitorWrapperBase &amp; c) = delete virtual Status Shutdown () = 0Shutdown (not used) NebulaHwMonitorWrapperBase &amp; operator= (NebulaHwMonitorWrapperBase &amp;&amp; c) = delete NebulaHwMonitorWrapperBase &amp; operator= (const NebulaHwMonitorWrapperBase &amp; c) = delete"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#protected-functions-inherited-from-nebularosnebulahwmonitorwrapperbase","title":"Protected Functions inherited from nebula::ros::NebulaHwMonitorWrapperBase","text":"<p>See nebula::ros::NebulaHwMonitorWrapperBase</p> Type Name virtual Status InitializeHwMonitor (const drivers::SensorConfigurationBase &amp; sensor_configuration) = 0Virtual function for initializing hardware monitor ros wrapper."},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-getparameters","title":"function GetParameters","text":"<p>Get configurations from ros parameters. <pre><code>Status nebula::ros::VelodyneHwMonitorRosWrapper::GetParameters (\ndrivers::VelodyneSensorConfiguration &amp; sensor_configuration\n) </code></pre></p> <p>Parameters:</p> <ul> <li><code>sensor_configuration</code> Output of SensorConfiguration </li> </ul> <p>Returns:</p> <p>Resulting status </p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-monitorstart","title":"function MonitorStart","text":"<p>Not used. <pre><code>virtual Status nebula::ros::VelodyneHwMonitorRosWrapper::MonitorStart () override\n</code></pre></p> <p>Returns:</p> <p>Current status </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStart</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-monitorstop","title":"function MonitorStop","text":"<p>Not used. <pre><code>virtual Status nebula::ros::VelodyneHwMonitorRosWrapper::MonitorStop () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::MonitorStop</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-shutdown","title":"function Shutdown","text":"<p>Not used. <pre><code>virtual Status nebula::ros::VelodyneHwMonitorRosWrapper::Shutdown () override\n</code></pre></p> <p>Returns:</p> <p>Status::OK </p> <p>Implements nebula::ros::NebulaHwMonitorWrapperBase::Shutdown</p>"},{"location":"nebula_ros/classnebula_1_1ros_1_1VelodyneHwMonitorRosWrapper/#function-velodynehwmonitorroswrapper","title":"function VelodyneHwMonitorRosWrapper","text":"<pre><code>explicit nebula::ros::VelodyneHwMonitorRosWrapper::VelodyneHwMonitorRosWrapper (\nconst rclcpp::NodeOptions &amp; options\n) </code></pre> <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/namespacerclcpp/","title":"Namespace rclcpp","text":"<p>Namespace List &gt; rclcpp</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"nebula_ros/dir_6001ffc79e86749e3c101772145a53e6/","title":"Dir nebula_ros","text":"<p>FileList &gt; nebula_ros</p>"},{"location":"nebula_ros/dir_6001ffc79e86749e3c101772145a53e6/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>nebula_ros/</code></p>"},{"location":"nebula_ros/dir_dfff66b500be9c87186bdc0dd281c8b0/","title":"Dir nebula_ros/include","text":"<p>FileList &gt; include</p>"},{"location":"nebula_ros/dir_dfff66b500be9c87186bdc0dd281c8b0/#directories","title":"Directories","text":"Type Name dir nebula_ros <p>The documentation for this class was generated from the following file <code>nebula_ros/include/</code></p>"},{"location":"nebula_ros/dir_e6dd3370ff1af828926f1a1358835b64/","title":"Dir nebula_ros/include/nebula_ros","text":"<p>FileList &gt; include &gt; nebula_ros</p>"},{"location":"nebula_ros/dir_e6dd3370ff1af828926f1a1358835b64/#directories","title":"Directories","text":"Type Name dir common dir hesai dir velodyne <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/</code></p>"},{"location":"nebula_ros/dir_09712351a52108b8301edc8a4528c3da/","title":"Dir nebula_ros/include/nebula_ros/common","text":"<p>FileList &gt; common</p>"},{"location":"nebula_ros/dir_09712351a52108b8301edc8a4528c3da/#files","title":"Files","text":"Type Name file nebula_driver_ros_wrapper_base.hpp file nebula_hw_interface_ros_wrapper_base.hpp file nebula_hw_monitor_ros_wrapper_base.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/</code></p>"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp/","title":"File nebula_driver_ros_wrapper_base.hpp","text":"<p>FileList &gt; common &gt; nebula_driver_ros_wrapper_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_driver_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/nebula__driver__ros__wrapper__base_8hpp_source/","title":"File nebula_driver_ros_wrapper_base.hpp","text":"<p>File List &gt; common &gt; nebula_driver_ros_wrapper_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_DRIVER_WRAPPER_BASE_H\n#define NEBULA_DRIVER_WRAPPER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;sensor_msgs/msg/point_cloud2.hpp&gt;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass NebulaDriverRosWrapperBase\n{\npublic:\nNebulaDriverRosWrapperBase() = default;\n\nNebulaDriverRosWrapperBase(NebulaDriverRosWrapperBase &amp;&amp; c) = delete;\nNebulaDriverRosWrapperBase &amp; operator=(NebulaDriverRosWrapperBase &amp;&amp; c) = delete;\nNebulaDriverRosWrapperBase(const NebulaDriverRosWrapperBase &amp; c) = delete;\nNebulaDriverRosWrapperBase &amp; operator=(const NebulaDriverRosWrapperBase &amp; c) = delete;\n\nprivate:\nvirtual Status InitializeDriver(\nstd::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\nstd::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) = 0;\n\n//  status ReceiveScanMsgCallback(void * ScanMsg);  // ROS message callback for individual packet\n//  type\n\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr cloud_pub_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n#endif  // NEBULA_DRIVER_WRAPPER_BASE_H\n</code></pre>"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp/","title":"File nebula_hw_interface_ros_wrapper_base.hpp","text":"<p>FileList &gt; common &gt; nebula_hw_interface_ros_wrapper_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/nebula__hw__interface__ros__wrapper__base_8hpp_source/","title":"File nebula_hw_interface_ros_wrapper_base.hpp","text":"<p>File List &gt; common &gt; nebula_hw_interface_ros_wrapper_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HW_INTERFACE_WRAPPER_BASE_H\n#define NEBULA_HW_INTERFACE_WRAPPER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass NebulaHwInterfaceWrapperBase\n{\npublic:\nNebulaHwInterfaceWrapperBase() = default;\n\nNebulaHwInterfaceWrapperBase(NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete;\nNebulaHwInterfaceWrapperBase &amp; operator=(NebulaHwInterfaceWrapperBase &amp;&amp; c) = delete;\nNebulaHwInterfaceWrapperBase(const NebulaHwInterfaceWrapperBase &amp; c) = delete;\nNebulaHwInterfaceWrapperBase &amp; operator=(const NebulaHwInterfaceWrapperBase &amp; c) = delete;\n\nvirtual Status StreamStart() = 0;\n\nvirtual Status StreamStop() = 0;\n\nvirtual Status Shutdown() = 0;\n\nprotected:\nvirtual Status InitializeHwInterface(\nconst drivers::SensorConfigurationBase &amp; sensor_configuration) = 0;\n//  void SendDataPacket(const std::vector&lt;uint8_t&gt; &amp;buffer);        // Ideally this will be\n//  implemented as specific funtions, GetFanStatus, GetEchoMode\n\nbool setup_sensor;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HW_INTERFACE_WRAPPER_BASE_H\n</code></pre>"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp/","title":"File nebula_hw_monitor_ros_wrapper_base.hpp","text":"<p>FileList &gt; common &gt; nebula_hw_monitor_ros_wrapper_base.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp/#classes","title":"Classes","text":"Type Name class NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp</code></p>"},{"location":"nebula_ros/nebula__hw__monitor__ros__wrapper__base_8hpp_source/","title":"File nebula_hw_monitor_ros_wrapper_base.hpp","text":"<p>File List &gt; common &gt; nebula_hw_monitor_ros_wrapper_base.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HW_MONITOR_WRAPPER_BASE_H\n#define NEBULA_HW_MONITOR_WRAPPER_BASE_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\nclass NebulaHwMonitorWrapperBase\n{\npublic:\nNebulaHwMonitorWrapperBase() = default;\n\nNebulaHwMonitorWrapperBase(NebulaHwMonitorWrapperBase &amp;&amp; c) = delete;\nNebulaHwMonitorWrapperBase &amp; operator=(NebulaHwMonitorWrapperBase &amp;&amp; c) = delete;\nNebulaHwMonitorWrapperBase(const NebulaHwMonitorWrapperBase &amp; c) = delete;\nNebulaHwMonitorWrapperBase &amp; operator=(const NebulaHwMonitorWrapperBase &amp; c) = delete;\n\nvirtual Status MonitorStart() = 0;\n\nvirtual Status MonitorStop() = 0;\n\nvirtual Status Shutdown() = 0;\n\nprotected:\nvirtual Status InitializeHwMonitor(\nconst drivers::SensorConfigurationBase &amp; sensor_configuration) = 0;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HW_MONITOR_WRAPPER_BASE_H\n</code></pre>"},{"location":"nebula_ros/dir_aa08891b43ae5d960958b3e9046224a5/","title":"Dir nebula_ros/include/nebula_ros/hesai","text":"<p>FileList &gt; hesai</p>"},{"location":"nebula_ros/dir_aa08891b43ae5d960958b3e9046224a5/#files","title":"Files","text":"Type Name file hesai_decoder_ros_wrapper.hpp file hesai_hw_interface_ros_wrapper.hpp file hesai_hw_monitor_ros_wrapper.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/</code></p>"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp/","title":"File hesai_decoder_ros_wrapper.hpp","text":"<p>FileList &gt; hesai &gt; hesai_decoder_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> </ul>"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class HesaiDriverRosWrapper Ros wrapper of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/hesai__decoder__ros__wrapper_8hpp_source/","title":"File hesai_decoder_ros_wrapper.hpp","text":"<p>File List &gt; hesai &gt; hesai_decoder_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HesaiDriverRosWrapper_H\n#define NEBULA_HesaiDriverRosWrapper_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_decoders/nebula_decoders_hesai/hesai_driver.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;chrono&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\nnamespace nebula\n{\nnamespace ros\n{\nclass HesaiDriverRosWrapper final : public rclcpp::Node, NebulaDriverRosWrapperBase\n{\nstd::shared_ptr&lt;drivers::HesaiDriver&gt; driver_ptr_;\nStatus wrapper_status_;\nrclcpp::Subscription&lt;pandar_msgs::msg::PandarScan&gt;::SharedPtr pandar_scan_sub_;\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr nebula_points_pub_;\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_ex_pub_;\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_base_pub_;\n\nstd::shared_ptr&lt;drivers::HesaiCalibrationConfiguration&gt; calibration_cfg_ptr_;\nstd::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_cfg_ptr_;\nstd::shared_ptr&lt;drivers::HesaiCorrection&gt; correction_cfg_ptr_;\n\ndrivers::HesaiHwInterface hw_interface_;\n\nStatus InitializeDriver(\nstd::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\nstd::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) override;\n\nStatus InitializeDriver(\nconst std::shared_ptr&lt;drivers::SensorConfigurationBase&gt; &amp; sensor_configuration,\nconst std::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; &amp; calibration_configuration,\nconst std::shared_ptr&lt;drivers::HesaiCorrection&gt; &amp; correction_configuration);\n\nStatus GetParameters(\ndrivers::HesaiSensorConfiguration &amp; sensor_configuration,\ndrivers::HesaiCalibrationConfiguration &amp; calibration_configuration,\ndrivers::HesaiCorrection &amp; correction_configuration);\n\nstatic inline std::chrono::nanoseconds SecondsToChronoNanoSeconds(const double seconds)\n{\nreturn std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\nstd::chrono::duration&lt;double&gt;(seconds));\n}\n\n/***\n   * Publishes a sensor_msgs::msg::PointCloud2 to the specified publisher\n   * @param pointcloud unique pointer containing the point cloud to publish\n   * @param publisher\n   */\nvoid PublishCloud(\nstd::unique_ptr&lt;sensor_msgs::msg::PointCloud2&gt; pointcloud,\nconst rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr &amp; publisher);\n\npublic:\nexplicit HesaiDriverRosWrapper(const rclcpp::NodeOptions &amp; options);\n\nvoid ReceiveScanMsgCallback(const pandar_msgs::msg::PandarScan::SharedPtr scan_msg);\n\nStatus GetStatus();\n\nprivate:\nstd::string correction_file_path;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HesaiDriverRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp/","title":"File hesai_hw_interface_ros_wrapper.hpp","text":"<p>FileList &gt; hesai &gt; hesai_hw_interface_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"pandar_msgs/msg/pandar_packet.hpp\"</code></li> <li><code>#include \"pandar_msgs/msg/pandar_scan.hpp\"</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/hesai__hw__interface__ros__wrapper_8hpp_source/","title":"File hesai_hw_interface_ros_wrapper.hpp","text":"<p>File List &gt; hesai &gt; hesai_hw_interface_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HesaiHwInterfaceRosWrapper_H\n#define NEBULA_HesaiHwInterfaceRosWrapper_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"pandar_msgs/msg/pandar_packet.hpp\"\n#include \"pandar_msgs/msg/pandar_scan.hpp\"\n\n#include &lt;boost/asio.hpp&gt;\n\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\nauto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\nreturn parameter.get_name() == name;\n});\nif (it != p.cend()) {\nvalue = it-&gt;template get_value&lt;T&gt;();\nreturn true;\n}\nreturn false;\n}\n\nclass HesaiHwInterfaceRosWrapper final : public rclcpp::Node, NebulaHwInterfaceWrapperBase\n{\ndrivers::HesaiHwInterface hw_interface_;\nStatus interface_status_;\n\ndrivers::HesaiSensorConfiguration sensor_configuration_;\n\nrclcpp::Publisher&lt;pandar_msgs::msg::PandarScan&gt;::SharedPtr pandar_scan_pub_;\n\nStatus InitializeHwInterface(\nconst drivers::SensorConfigurationBase &amp; sensor_configuration) override;\nvoid ReceiveScanDataCallback(std::unique_ptr&lt;pandar_msgs::msg::PandarScan&gt; scan_buffer);\n\npublic:\nexplicit HesaiHwInterfaceRosWrapper(const rclcpp::NodeOptions &amp; options);\n~HesaiHwInterfaceRosWrapper() noexcept override;\nStatus StreamStart() override;\nStatus StreamStop() override;\nStatus Shutdown() override;\nStatus GetParameters(drivers::HesaiSensorConfiguration &amp; sensor_configuration);\n\nprivate:\nstd::mutex mtx_config_;\nOnSetParametersCallbackHandle::SharedPtr set_param_res_;\nrcl_interfaces::msg::SetParametersResult paramCallback(\nconst std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\nstd::vector&lt;rcl_interfaces::msg::SetParametersResult&gt; updateParameters();\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HesaiHwInterfaceRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp/","title":"File hesai_hw_monitor_ros_wrapper.hpp","text":"<p>FileList &gt; hesai &gt; hesai_hw_monitor_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/hesai/hesai_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"</code></li> <li><code>#include \"boost_tcp_driver/tcp_driver.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;boost/asio.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;boost/algorithm/string/join.hpp&gt;</code></li> <li><code>#include &lt;boost/lexical_cast.hpp&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/hesai/hesai_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/hesai__hw__monitor__ros__wrapper_8hpp_source/","title":"File hesai_hw_monitor_ros_wrapper.hpp","text":"<p>File List &gt; hesai &gt; hesai_hw_monitor_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_HesaiHwMonitorRosWrapper_H\n#define NEBULA_HesaiHwMonitorRosWrapper_H\n\n#include \"nebula_common/hesai/hesai_common.hpp\"\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_hesai/hesai_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"\n#include \"boost_tcp_driver/tcp_driver.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;boost/asio.hpp&gt;\n\n#include &lt;mutex&gt;\n#include &lt;boost/algorithm/string/join.hpp&gt;\n#include &lt;boost/asio.hpp&gt;\n#include &lt;boost/lexical_cast.hpp&gt;\n\n#include &lt;thread&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\nauto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\nreturn parameter.get_name() == name;\n});\nif (it != p.cend()) {\nvalue = it-&gt;template get_value&lt;T&gt;();\nreturn true;\n}\nreturn false;\n}\n\nclass HesaiHwMonitorRosWrapper final : public rclcpp::Node, NebulaHwMonitorWrapperBase\n{\ndrivers::HesaiHwInterface hw_interface_;\nStatus interface_status_;\n\ndrivers::HesaiSensorConfiguration sensor_configuration_;\n\nStatus InitializeHwMonitor(\nconst drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n\npublic:\nexplicit HesaiHwMonitorRosWrapper(const rclcpp::NodeOptions &amp; options);\n~HesaiHwMonitorRosWrapper() noexcept override;\nStatus MonitorStart() override;\nStatus MonitorStop() override;\nStatus Shutdown() override;\nStatus GetParameters(drivers::HesaiSensorConfiguration &amp; sensor_configuration);\n\nprivate:\ndiagnostic_updater::Updater diagnostics_updater_;\nvoid InitializeHesaiDiagnostics();\nvoid OnHesaiStatusTimer();\nvoid OnHesaiLidarMonitorTimerHttp();\nvoid OnHesaiLidarMonitorTimer();\n//  void OnHesaiDiagnosticsTimer();\n//  void OnHesaiStatusTimer();\n\nvoid HesaiCheckStatus(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid HesaiCheckPtp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid HesaiCheckTemperature(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid HesaiCheckRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid HesaiCheckVoltageHttp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid HesaiCheckVoltage(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\nrclcpp::TimerBase::SharedPtr diagnostics_update_timer_;\nrclcpp::TimerBase::SharedPtr diagnostics_update_monitor_timer_;\nrclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\nrclcpp::TimerBase::SharedPtr diagnostics_lidar_monitor_timer_;\nstd::unique_ptr&lt;HesaiLidarStatus&gt; current_status;\nstd::unique_ptr&lt;HesaiLidarMonitor&gt; current_monitor;\nstd::unique_ptr&lt;HesaiConfig&gt; current_config;\nstd::unique_ptr&lt;HesaiInventory&gt; current_inventory;\nstd::unique_ptr&lt;boost::property_tree::ptree&gt; current_lidar_monitor_tree;\nstd::unique_ptr&lt;rclcpp::Time&gt; current_status_time;\nstd::unique_ptr&lt;rclcpp::Time&gt; current_config_time;\nstd::unique_ptr&lt;rclcpp::Time&gt; current_inventory_time;\nstd::unique_ptr&lt;rclcpp::Time&gt; current_lidar_monitor_time;\nuint8_t current_diag_status;\nuint8_t current_monitor_status;\n\nuint16_t diag_span_;\nstd::mutex mtx_diag;\nstd::mutex mtx_status;\nstd::mutex mtx_lidar_monitor;\n//  std::timed_mutex mtx_lidar_monitor;\nstd::mutex mtx_config_;\nOnSetParametersCallbackHandle::SharedPtr set_param_res_;\nrcl_interfaces::msg::SetParametersResult paramCallback(\nconst std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\nstd::string GetPtreeValue(boost::property_tree::ptree * pt, const std::string &amp; key);\nstd::string GetFixedPrecisionString(double val, int pre = 2);\n\nstd::string info_model;\nstd::string info_serial;\nrclcpp::CallbackGroup::SharedPtr cbg_r_;\nrclcpp::CallbackGroup::SharedPtr cbg_m_;\nrclcpp::CallbackGroup::SharedPtr cbg_m2_;\n\nconst char * not_supported_message;\nconst char * error_message;\nstd::string message_sep;\n\nstd::vector&lt;std::string&gt; temperature_names;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_HesaiHwMonitorRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/dir_924f2fee37cae1e3bab1779917111cb0/","title":"Dir nebula_ros/include/nebula_ros/velodyne","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne</p>"},{"location":"nebula_ros/dir_924f2fee37cae1e3bab1779917111cb0/#files","title":"Files","text":"Type Name file velodyne_decoder_ros_wrapper.hpp file velodyne_hw_interface_ros_wrapper.hpp file velodyne_hw_monitor_ros_wrapper.hpp <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/</code></p>"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp/","title":"File velodyne_decoder_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_decoder_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/nebula_status.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> </ul>"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneDriverRosWrapper Ros wrapper of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_decoder_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/velodyne__decoder__ros__wrapper_8hpp_source/","title":"File velodyne_decoder_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_decoder_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VelodyneDriverRosWrapper_H\n#define NEBULA_VelodyneDriverRosWrapper_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/nebula_status.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_decoders/nebula_decoders_velodyne/velodyne_driver.hpp\"\n#include \"nebula_ros/common/nebula_driver_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\nnamespace nebula\n{\nnamespace ros\n{\nclass VelodyneDriverRosWrapper final : public rclcpp::Node, NebulaDriverRosWrapperBase\n{\nstd::shared_ptr&lt;drivers::VelodyneDriver&gt; driver_ptr_;\nStatus wrapper_status_;\nrclcpp::Subscription&lt;velodyne_msgs::msg::VelodyneScan&gt;::SharedPtr velodyne_scan_sub_;\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr nebula_points_pub_;\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_ex_pub_;\nrclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr aw_points_base_pub_;\n\nstd::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_cfg_ptr_;\nstd::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_cfg_ptr_;\n\nStatus InitializeDriver(\nstd::shared_ptr&lt;drivers::SensorConfigurationBase&gt; sensor_configuration,\nstd::shared_ptr&lt;drivers::CalibrationConfigurationBase&gt; calibration_configuration) override;\n\nStatus GetParameters(\ndrivers::VelodyneSensorConfiguration &amp; sensor_configuration,\ndrivers::VelodyneCalibrationConfiguration &amp; calibration_configuration);\n\nstatic inline std::chrono::nanoseconds SecondsToChronoNanoSeconds(const double seconds)\n{\nreturn std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(\nstd::chrono::duration&lt;double&gt;(seconds));\n}\n\n/***\n   * Publishes a sensor_msgs::msg::PointCloud2 to the specified publisher\n   * @param pointcloud unique pointer containing the point cloud to publish\n   * @param publisher\n   */\nvoid PublishCloud(\nstd::unique_ptr&lt;sensor_msgs::msg::PointCloud2&gt; pointcloud,\nconst rclcpp::Publisher&lt;sensor_msgs::msg::PointCloud2&gt;::SharedPtr &amp; publisher);\n\npublic:\nexplicit VelodyneDriverRosWrapper(const rclcpp::NodeOptions &amp; options);\n\nvoid ReceiveScanMsgCallback(const velodyne_msgs::msg::VelodyneScan::SharedPtr scan_msg);\nStatus GetStatus();\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_VelodyneDriverRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp/","title":"File velodyne_hw_interface_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_interface_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_packet.hpp\"</code></li> <li><code>#include \"velodyne_msgs/msg/velodyne_scan.hpp\"</code></li> <li><code>#include &lt;curl/curl.h&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_interface_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/velodyne__hw__interface__ros__wrapper_8hpp_source/","title":"File velodyne_hw_interface_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_interface_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VelodyneHwInterfaceRosWrapper_H\n#define NEBULA_VelodyneHwInterfaceRosWrapper_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_interface_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include \"velodyne_msgs/msg/velodyne_packet.hpp\"\n#include \"velodyne_msgs/msg/velodyne_scan.hpp\"\n\n#include &lt;curl/curl.h&gt;\n\n#include &lt;future&gt;\n#include &lt;mutex&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\nauto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\nreturn parameter.get_name() == name;\n});\nif (it != p.cend()) {\nvalue = it-&gt;template get_value&lt;T&gt;();\nreturn true;\n}\nreturn false;\n}\n\nclass VelodyneHwInterfaceRosWrapper final : public rclcpp::Node, NebulaHwInterfaceWrapperBase\n{\ndrivers::VelodyneHwInterface hw_interface_;\nStatus interface_status_;\n\ndrivers::VelodyneSensorConfiguration sensor_configuration_;\ndrivers::VelodyneCalibrationConfiguration calibration_configuration_;\n\nrclcpp::Publisher&lt;velodyne_msgs::msg::VelodyneScan&gt;::SharedPtr velodyne_scan_pub_;\n\nStatus InitializeHwInterface(\nconst drivers::SensorConfigurationBase &amp; sensor_configuration) override;\nvoid ReceiveScanDataCallback(std::unique_ptr&lt;velodyne_msgs::msg::VelodyneScan&gt; scan_buffer);\n\npublic:\nexplicit VelodyneHwInterfaceRosWrapper(const rclcpp::NodeOptions &amp; options);\nStatus StreamStart() override;\nStatus StreamStop() override;\nStatus Shutdown() override;\nStatus GetParameters(drivers::VelodyneSensorConfiguration &amp; sensor_configuration);\n\nprivate:  // ROS Diagnostics\n/*\ndiagnostic_updater::Updater diagnostics_updater_;\nvoid InitializeVelodyneDiagnostics();\n*/\n\nstd::string GetPtreeValue(\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; pt, const std::string &amp; key);\n/*\n  rclcpp::TimerBase::SharedPtr diagnostics_diag_timer_;\n*/\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; current_diag_tree;\n/*\n  void OnVelodyneDiagnosticsTimer();\n  void VelodyneCheckTopHv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopAdTemp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwrRaw(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckTopPwrVccint(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotIOut(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr12v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwrVIn(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckBotPwr125v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckVhv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdcNf(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdcStats(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckIxe(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckAdctpStat(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  rclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\n*/\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; current_status_tree;\n/*\n  void OnVelodyneStatusTimer();\n  void VelodyneCheckGpsPpsState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckGpsPosition(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorLock(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckMotorPhase(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n  void VelodyneCheckLaserState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void VelodyneCheckSnapshot(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\n  void OnVelodyneSnapshotTimer();\n  rclcpp::TimerBase::SharedPtr diagnostics_snapshot_timer_;\n  rclcpp::TimerBase::SharedPtr diagnostics_update_timer_;\n*/\nstd::shared_ptr&lt;std::string&gt; current_snapshot;\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; current_snapshot_tree;\nstd::shared_ptr&lt;rclcpp::Time&gt; current_snapshot_time;\n//  rclcpp::Time current_snapshot_time;\n//  std::shared_ptr&lt;uint8_t&gt; current_diag_status;\nuint8_t current_diag_status;\n\nuint16_t diag_span_;\nstd::mutex mtx_diag;\nstd::mutex mtx_status;\nstd::mutex mtx_config_;\n\nvoid curl_callback(std::string err, std::string body);\n/*\n  const char* key_volt_temp_top_hv;\n  const char* key_volt_temp_top_ad_temp;\n  const char* key_volt_temp_top_lm20_temp;\n  const char* key_volt_temp_top_pwr_5v;\n  const char* key_volt_temp_top_pwr_2_5v;\n  const char* key_volt_temp_top_pwr_3_3v;\n  const char* key_volt_temp_top_pwr_raw;\n  const char* key_volt_temp_top_pwr_vccint;\n  const char* key_volt_temp_bot_i_out;\n  const char* key_volt_temp_bot_pwr_1_2v;\n  const char* key_volt_temp_bot_lm20_temp;\n  const char* key_volt_temp_bot_pwr_5v;\n  const char* key_volt_temp_bot_pwr_2_5v;\n  const char* key_volt_temp_bot_pwr_3_3v;\n  const char* key_volt_temp_bot_pwr_v_in;\n  const char* key_volt_temp_bot_pwr_1_25v;\n  const char* key_vhv;\n  const char* key_adc_nf;\n  const char* key_adc_stats;\n  const char* key_ixe;\n  const char* key_adctp_stat;\n  const char* key_status_gps_pps_state;\n  const char* key_status_gps_pps_position;\n  const char* key_status_motor_state;\n  const char* key_status_motor_rpm;\n  const char* key_status_motor_lock;\n  const char* key_status_motor_phase;\n  const char* key_status_laser_state;\n*/\nconst char * not_supported_message;\n\nOnSetParametersCallbackHandle::SharedPtr set_param_res_;\nrcl_interfaces::msg::SetParametersResult paramCallback(\nconst std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\nstd::vector&lt;rcl_interfaces::msg::SetParametersResult&gt; updateParameters();\n\n//  rclcpp::callback_group::CallbackGroup::SharedPtr cbg_;\nrclcpp::CallbackGroup::SharedPtr cbg_r_;\nrclcpp::CallbackGroup::SharedPtr cbg_m_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_VelodyneHwInterfaceRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp/","title":"File velodyne_hw_monitor_ros_wrapper.hpp","text":"<p>FileList &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_monitor_ros_wrapper.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"nebula_common/nebula_common.hpp\"</code></li> <li><code>#include \"nebula_common/velodyne/velodyne_common.hpp\"</code></li> <li><code>#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"</code></li> <li><code>#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"</code></li> <li><code>#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;</code></li> <li><code>#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;</code></li> <li><code>#include &lt;rclcpp/rclcpp.hpp&gt;</code></li> <li><code>#include &lt;rclcpp_components/register_node_macro.hpp&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> </ul>"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace nebula namespace ros"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp/#classes","title":"Classes","text":"Type Name class VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. <p>The documentation for this class was generated from the following file <code>nebula_ros/include/nebula_ros/velodyne/velodyne_hw_monitor_ros_wrapper.hpp</code></p>"},{"location":"nebula_ros/velodyne__hw__monitor__ros__wrapper_8hpp_source/","title":"File velodyne_hw_monitor_ros_wrapper.hpp","text":"<p>File List &gt; include &gt; nebula_ros &gt; velodyne &gt; velodyne_hw_monitor_ros_wrapper.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef NEBULA_VelodyneHwMonitorRosWrapper_H\n#define NEBULA_VelodyneHwMonitorRosWrapper_H\n\n#include \"nebula_common/nebula_common.hpp\"\n#include \"nebula_common/velodyne/velodyne_common.hpp\"\n#include \"nebula_hw_interfaces/nebula_hw_interfaces_velodyne/velodyne_hw_interface.hpp\"\n#include \"nebula_ros/common/nebula_hw_monitor_ros_wrapper_base.hpp\"\n\n#include &lt;ament_index_cpp/get_package_prefix.hpp&gt;\n#include &lt;diagnostic_updater/diagnostic_updater.hpp&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp_components/register_node_macro.hpp&gt;\n\n#include &lt;mutex&gt;\n\nnamespace nebula\n{\nnamespace ros\n{\ntemplate &lt;typename T&gt;\nbool get_param(const std::vector&lt;rclcpp::Parameter&gt; &amp; p, const std::string &amp; name, T &amp; value)\n{\nauto it = std::find_if(p.cbegin(), p.cend(), [&amp;name](const rclcpp::Parameter &amp; parameter) {\nreturn parameter.get_name() == name;\n});\nif (it != p.cend()) {\nvalue = it-&gt;template get_value&lt;T&gt;();\nreturn true;\n}\nreturn false;\n}\n\nclass VelodyneHwMonitorRosWrapper final : public rclcpp::Node, NebulaHwMonitorWrapperBase\n{\ndrivers::VelodyneHwInterface hw_interface_;\nStatus interface_status_;\n\ndrivers::VelodyneSensorConfiguration sensor_configuration_;\ndrivers::VelodyneCalibrationConfiguration calibration_configuration_;\n\nStatus InitializeHwMonitor(\nconst drivers::SensorConfigurationBase &amp; sensor_configuration) override;\n\npublic:\nexplicit VelodyneHwMonitorRosWrapper(const rclcpp::NodeOptions &amp; options);\n\nStatus MonitorStart() override;\nStatus MonitorStop() override;\nStatus Shutdown() override;\nStatus GetParameters(drivers::VelodyneSensorConfiguration &amp; sensor_configuration);\n\nprivate:  // ROS Diagnostics\ndiagnostic_updater::Updater diagnostics_updater_;\nvoid InitializeVelodyneDiagnostics();\nstd::string GetPtreeValue(\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; pt, const std::string &amp; key);\nstd::string GetFixedPrecisionString(double val, int pre = 2);\nrclcpp::TimerBase::SharedPtr diagnostics_diag_timer_;\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; current_diag_tree;\nvoid OnVelodyneDiagnosticsTimer();\n\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopHv();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopAdTemp();  // only32\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopLm20Temp();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr5v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr25v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr33v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwr5vRaw();  // only16\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwrRaw();  // only32\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetTopPwrVccint();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotIOut();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr12v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotLm20Temp();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr5v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr25v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr33v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwrVIn();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetBotPwr125v();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetVhv();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetAdcNf();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetAdcStats();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetIxe();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetAdctpStat();\n\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetGpsPpsState();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetGpsPosition();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorState();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorRpm();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorLock();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetMotorPhase();\nstd::tuple&lt;bool, uint8_t, std::string, std::string&gt; VelodyneGetLaserState();\n\nvoid VelodyneCheckTopHv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopAdTemp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopPwrRaw(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTopPwrVccint(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotIOut(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotPwr12v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotLm20Temp(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotPwr5v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotPwr25v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotPwr33v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotPwrVIn(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckBotPwr125v(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckVhv(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckAdcNf(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckAdcStats(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckIxe(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckAdctpStat(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nrclcpp::TimerBase::SharedPtr diagnostics_status_timer_;\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; current_status_tree;\nvoid OnVelodyneStatusTimer();\nvoid VelodyneCheckGpsPpsState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckGpsPosition(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckMotorState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckMotorRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckMotorLock(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckMotorPhase(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckLaserState(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\nvoid VelodyneCheckSnapshot(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\nvoid VelodyneCheckStatus(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckPps(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckTemperature(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckRpm(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\nvoid VelodyneCheckVoltage(diagnostic_updater::DiagnosticStatusWrapper &amp; diagnostics);\n\nvoid OnVelodyneSnapshotTimer();\nrclcpp::TimerBase::SharedPtr diagnostics_snapshot_timer_;\nrclcpp::TimerBase::SharedPtr diagnostics_update_timer_;\nstd::shared_ptr&lt;std::string&gt; current_snapshot;\nstd::shared_ptr&lt;boost::property_tree::ptree&gt; current_snapshot_tree;\nstd::shared_ptr&lt;rclcpp::Time&gt; current_snapshot_time;\n//  rclcpp::Time current_snapshot_time;\n//  std::shared_ptr&lt;uint8_t&gt; current_diag_status;\nuint8_t current_diag_status;\n\nuint16_t diag_span_;\nstd::mutex mtx_diag;\nstd::mutex mtx_status;\nstd::mutex mtx_config_;\n\nvoid curl_callback(std::string err, std::string body);\n\nconst char * key_volt_temp_top_hv;\nconst char * key_volt_temp_top_ad_temp;\nconst char * key_volt_temp_top_lm20_temp;\nconst char * key_volt_temp_top_pwr_5v;\nconst char * key_volt_temp_top_pwr_2_5v;\nconst char * key_volt_temp_top_pwr_3_3v;\nconst char * key_volt_temp_top_pwr_5v_raw;\nconst char * key_volt_temp_top_pwr_raw;\nconst char * key_volt_temp_top_pwr_vccint;\nconst char * key_volt_temp_bot_i_out;\nconst char * key_volt_temp_bot_pwr_1_2v;\nconst char * key_volt_temp_bot_lm20_temp;\nconst char * key_volt_temp_bot_pwr_5v;\nconst char * key_volt_temp_bot_pwr_2_5v;\nconst char * key_volt_temp_bot_pwr_3_3v;\nconst char * key_volt_temp_bot_pwr_v_in;\nconst char * key_volt_temp_bot_pwr_1_25v;\nconst char * key_vhv;\nconst char * key_adc_nf;\nconst char * key_adc_stats;\nconst char * key_ixe;\nconst char * key_adctp_stat;\nconst char * key_status_gps_pps_state;\nconst char * key_status_gps_pps_position;\nconst char * key_status_motor_state;\nconst char * key_status_motor_rpm;\nconst char * key_status_motor_lock;\nconst char * key_status_motor_phase;\nconst char * key_status_laser_state;\n\n/*\n  const char* name_volt_temp_top_hv;\n  const char* name_volt_temp_top_ad_temp;\n  const char* name_volt_temp_top_lm20_temp;\n  const char* name_volt_temp_top_pwr_5v;\n  const char* name_volt_temp_top_pwr_2_5v;\n  const char* name_volt_temp_top_pwr_3_3v;\n  const char* name_volt_temp_top_pwr_raw;\n  const char* name_volt_temp_top_pwr_vccint;\n  const char* name_volt_temp_bot_i_out;\n  const char* name_volt_temp_bot_pwr_1_2v;\n  const char* name_volt_temp_bot_lm20_temp;\n  const char* name_volt_temp_bot_pwr_5v;\n  const char* name_volt_temp_bot_pwr_2_5v;\n  const char* name_volt_temp_bot_pwr_3_3v;\n  const char* name_volt_temp_bot_pwr_v_in;\n  const char* name_volt_temp_bot_pwr_1_25v;\n  const char* name_vhv;\n  const char* name_adc_nf;\n  const char* name_adc_stats;\n  const char* name_ixe;\n  const char* name_adctp_stat;\n  const char* name_status_gps_pps_state;\n  const char* name_status_gps_pps_position;\n  const char* name_status_motor_state;\n  const char* name_status_motor_rpm;\n  const char* name_status_motor_lock;\n  const char* name_status_motor_phase;\n  const char* name_status_laser_state;\n  */\n\nstd::string name_volt_temp_top_hv;\nstd::string name_volt_temp_top_ad_temp;\nstd::string name_volt_temp_top_lm20_temp;\nstd::string name_volt_temp_top_pwr_5v;\nstd::string name_volt_temp_top_pwr_2_5v;\nstd::string name_volt_temp_top_pwr_3_3v;\nstd::string name_volt_temp_top_pwr_5v_raw;\nstd::string name_volt_temp_top_pwr_raw;\nstd::string name_volt_temp_top_pwr_vccint;\nstd::string name_volt_temp_bot_i_out;\nstd::string name_volt_temp_bot_pwr_1_2v;\nstd::string name_volt_temp_bot_lm20_temp;\nstd::string name_volt_temp_bot_pwr_5v;\nstd::string name_volt_temp_bot_pwr_2_5v;\nstd::string name_volt_temp_bot_pwr_3_3v;\nstd::string name_volt_temp_bot_pwr_v_in;\nstd::string name_volt_temp_bot_pwr_1_25v;\nstd::string name_vhv;\nstd::string name_adc_nf;\nstd::string name_adc_stats;\nstd::string name_ixe;\nstd::string name_adctp_stat;\nstd::string name_status_gps_pps_state;\nstd::string name_status_gps_pps_position;\nstd::string name_status_motor_state;\nstd::string name_status_motor_rpm;\nstd::string name_status_motor_lock;\nstd::string name_status_motor_phase;\nstd::string name_status_laser_state;\n\nconst char * not_supported_message;\nconst char * error_message;\nstd::string message_sep;\n\nconst char * key_info_model;\nconst char * key_info_serial;\n\nstd::string temperature_cold_message;\nstd::string temperature_hot_message;\nstd::string voltage_low_message;\nstd::string voltage_high_message;\nstd::string ampere_low_message;\nstd::string ampere_high_message;\n\nstd::string info_model;\nstd::string info_serial;\n\nbool use_advanced_diagnostics;\n\nOnSetParametersCallbackHandle::SharedPtr set_param_res_;\nrcl_interfaces::msg::SetParametersResult paramCallback(\nconst std::vector&lt;rclcpp::Parameter&gt; &amp; parameters);\n\n//  rclcpp::callback_group::CallbackGroup::SharedPtr cbg_;\nrclcpp::CallbackGroup::SharedPtr cbg_r_;\nrclcpp::CallbackGroup::SharedPtr cbg_m_;\n};\n\n}  // namespace ros\n}  // namespace nebula\n\n#endif  // NEBULA_VelodyneHwMonitorRosWrapper_H\n</code></pre>"},{"location":"nebula_ros/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace nebula <ul> <li>namespace ros </li> </ul> </li> <li>namespace rclcpp </li> </ul>"},{"location":"nebula_ros/classes/","title":"Class Index","text":""},{"location":"nebula_ros/classes/#h","title":"h","text":"<ul> <li>HesaiDriverRosWrapper (nebula::ros)</li> <li>HesaiHwInterfaceRosWrapper (nebula::ros)</li> <li>HesaiHwMonitorRosWrapper (nebula::ros)</li> </ul>"},{"location":"nebula_ros/classes/#n","title":"n","text":"<ul> <li>NebulaDriverRosWrapperBase (nebula::ros)</li> <li>NebulaHwInterfaceWrapperBase (nebula::ros)</li> <li>NebulaHwMonitorWrapperBase (nebula::ros)</li> </ul>"},{"location":"nebula_ros/classes/#v","title":"v","text":"<ul> <li>VelodyneDriverRosWrapper (nebula::ros)</li> <li>VelodyneHwInterfaceRosWrapper (nebula::ros)</li> <li>VelodyneHwMonitorRosWrapper (nebula::ros)</li> </ul>"},{"location":"nebula_ros/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class nebula::ros::NebulaDriverRosWrapperBase Base class for ros wrapper of each sensor driver. <ul> <li>class nebula::ros::HesaiDriverRosWrapper Ros wrapper of hesai driver. </li> <li>class nebula::ros::VelodyneDriverRosWrapper Ros wrapper of velodyne driver. </li> </ul> </li> <li>class nebula::ros::NebulaHwInterfaceWrapperBase Base class for hardware interface ros wrapper of each LiDAR. <ul> <li>class nebula::ros::HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. </li> <li>class nebula::ros::VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. </li> </ul> </li> <li>class nebula::ros::NebulaHwMonitorWrapperBase Base class for hardware monitor ros wrapper of each LiDAR. <ul> <li>class nebula::ros::HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. </li> <li>class nebula::ros::VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. </li> </ul> </li> <li>class rclcpp::Node <ul> <li>class nebula::ros::HesaiDriverRosWrapper Ros wrapper of hesai driver. </li> <li>class nebula::ros::HesaiHwInterfaceRosWrapper Hardware interface ros wrapper of hesai driver. </li> <li>class nebula::ros::HesaiHwMonitorRosWrapper Hardware monitor ros wrapper of hesai driver. </li> <li>class nebula::ros::VelodyneDriverRosWrapper Ros wrapper of velodyne driver. </li> <li>class nebula::ros::VelodyneHwInterfaceRosWrapper Hardware interface ros wrapper of velodyne driver. </li> <li>class nebula::ros::VelodyneHwMonitorRosWrapper Hardware monitor ros wrapper of velodyne driver. </li> </ul> </li> </ul>"},{"location":"nebula_ros/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"nebula_ros/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"nebula_ros/class_members/","title":"Class Members","text":""},{"location":"nebula_ros/class_members/#a","title":"a","text":"<ul> <li>aw_points_base_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>aw_points_ex_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ampere_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>ampere_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#c","title":"c","text":"<ul> <li>calibration_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>correction_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>correction_file_path (nebula::ros::HesaiDriverRosWrapper)</li> <li>cbg_m2_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cbg_m_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>cbg_r_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_config (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_config_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_diag_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_inventory (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_inventory_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_tree (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cloud_pub_ (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>calibration_configuration_ (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>curl_callback (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_diag_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_time (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_status_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#d","title":"d","text":"<ul> <li>driver_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>diag_span_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_lidar_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_status_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_update_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_update_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_updater_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_diag_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_snapshot_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#e","title":"e","text":"<ul> <li>error_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#g","title":"g","text":"<ul> <li>GetParameters (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneDriverRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetStatus (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>GetFixedPrecisionString (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetPtreeValue (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#h","title":"h","text":"<ul> <li>HesaiDriverRosWrapper (nebula::ros::HesaiDriverRosWrapper)</li> <li>hw_interface_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>HesaiCheckPtp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckRpm (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckStatus (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckTemperature (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltage (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltageHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#i","title":"i","text":"<ul> <li>InitializeDriver (nebula::ros::HesaiDriverRosWrapper, nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::VelodyneDriverRosWrapper)</li> <li>InitializeHwInterface (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>interface_status_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>InitializeHesaiDiagnostics (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>InitializeHwMonitor (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_model (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_serial (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>InitializeVelodyneDiagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#k","title":"k","text":"<ul> <li>key_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_model (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_serial (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#m","title":"m","text":"<ul> <li>mtx_config_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>MonitorStart (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>MonitorStop (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>message_sep (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_diag (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_lidar_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>mtx_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#n","title":"n","text":"<ul> <li>nebula_points_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>not_supported_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>NebulaDriverRosWrapperBase (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>NebulaHwInterfaceWrapperBase (nebula::ros::NebulaHwInterfaceWrapperBase)</li> <li>NebulaHwMonitorWrapperBase (nebula::ros::NebulaHwMonitorWrapperBase)</li> <li>name_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#o","title":"o","text":"<ul> <li>OnHesaiLidarMonitorTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiLidarMonitorTimerHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiStatusTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>operator= (nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase)</li> <li>OnVelodyneDiagnosticsTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneSnapshotTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneStatusTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#p","title":"p","text":"<ul> <li>PublishCloud (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>pandar_scan_sub_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>pandar_scan_pub_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>paramCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#r","title":"r","text":"<ul> <li>ReceiveScanMsgCallback (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ReceiveScanDataCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#s","title":"s","text":"<ul> <li>SecondsToChronoNanoSeconds (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>sensor_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>Shutdown (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>StreamStart (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>StreamStop (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>sensor_configuration_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>set_param_res_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>setup_sensor (nebula::ros::NebulaHwInterfaceWrapperBase)</li> </ul>"},{"location":"nebula_ros/class_members/#t","title":"t","text":"<ul> <li>temperature_names (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>temperature_cold_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>temperature_hot_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#u","title":"u","text":"<ul> <li>updateParameters (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>use_advanced_diagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#v","title":"v","text":"<ul> <li>VelodyneDriverRosWrapper (nebula::ros::VelodyneDriverRosWrapper)</li> <li>velodyne_scan_sub_ (nebula::ros::VelodyneDriverRosWrapper)</li> <li>VelodyneHwInterfaceRosWrapper (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>velodyne_scan_pub_ (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>VelodyneCheckAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckPps (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckSnapshot (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckStatus (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTemperature (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVoltage (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5vRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneHwMonitorRosWrapper (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>voltage_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>voltage_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#w","title":"w","text":"<ul> <li>wrapper_status_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_members/#_1","title":"~","text":"<ul> <li>~HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>~HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/","title":"Class Member Functions","text":""},{"location":"nebula_ros/class_member_functions/#c","title":"c","text":"<ul> <li>curl_callback (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#g","title":"g","text":"<ul> <li>GetParameters (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneDriverRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetStatus (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>GetFixedPrecisionString (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>GetPtreeValue (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#h","title":"h","text":"<ul> <li>HesaiDriverRosWrapper (nebula::ros::HesaiDriverRosWrapper)</li> <li>HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>HesaiCheckPtp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckRpm (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckStatus (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckTemperature (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltage (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiCheckVoltageHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#i","title":"i","text":"<ul> <li>InitializeDriver (nebula::ros::HesaiDriverRosWrapper, nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::VelodyneDriverRosWrapper)</li> <li>InitializeHwInterface (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>InitializeHesaiDiagnostics (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>InitializeHwMonitor (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>InitializeVelodyneDiagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#m","title":"m","text":"<ul> <li>MonitorStart (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>MonitorStop (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#n","title":"n","text":"<ul> <li>NebulaDriverRosWrapperBase (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>NebulaHwInterfaceWrapperBase (nebula::ros::NebulaHwInterfaceWrapperBase)</li> <li>NebulaHwMonitorWrapperBase (nebula::ros::NebulaHwMonitorWrapperBase)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#o","title":"o","text":"<ul> <li>OnHesaiLidarMonitorTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiLidarMonitorTimerHttp (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>OnHesaiStatusTimer (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>operator= (nebula::ros::NebulaDriverRosWrapperBase, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase)</li> <li>OnVelodyneDiagnosticsTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneSnapshotTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>OnVelodyneStatusTimer (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#p","title":"p","text":"<ul> <li>PublishCloud (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>paramCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#r","title":"r","text":"<ul> <li>ReceiveScanMsgCallback (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ReceiveScanDataCallback (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#s","title":"s","text":"<ul> <li>SecondsToChronoNanoSeconds (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>Shutdown (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::NebulaHwMonitorWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>StreamStart (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>StreamStop (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::NebulaHwInterfaceWrapperBase, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#u","title":"u","text":"<ul> <li>updateParameters (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#v","title":"v","text":"<ul> <li>VelodyneDriverRosWrapper (nebula::ros::VelodyneDriverRosWrapper)</li> <li>VelodyneHwInterfaceRosWrapper (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>VelodyneCheckAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckPps (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckSnapshot (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckStatus (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTemperature (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneCheckVoltage (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcNf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdcStats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetAdctpStat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotIOut (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr125v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr12v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetBotPwrVIn (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPosition (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetGpsPpsState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetIxe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetLaserState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorLock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorPhase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorRpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetMotorState (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopAdTemp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopHv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopLm20Temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr33v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwr5vRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrRaw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetTopPwrVccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneGetVhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>VelodyneHwMonitorRosWrapper (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_functions/#_1","title":"~","text":"<ul> <li>~HesaiHwInterfaceRosWrapper (nebula::ros::HesaiHwInterfaceRosWrapper)</li> <li>~HesaiHwMonitorRosWrapper (nebula::ros::HesaiHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/","title":"Class Member Variables","text":""},{"location":"nebula_ros/class_member_variables/#a","title":"a","text":"<ul> <li>aw_points_base_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>aw_points_ex_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>ampere_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>ampere_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#c","title":"c","text":"<ul> <li>calibration_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>correction_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>correction_file_path (nebula::ros::HesaiDriverRosWrapper)</li> <li>cbg_m2_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cbg_m_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>cbg_r_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_config (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_config_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_diag_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_inventory (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_inventory_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_lidar_monitor_tree (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_monitor_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>current_status_time (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>cloud_pub_ (nebula::ros::NebulaDriverRosWrapperBase)</li> <li>calibration_configuration_ (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_diag_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_time (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_snapshot_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>current_status_tree (nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#d","title":"d","text":"<ul> <li>driver_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>diag_span_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_lidar_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_status_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_update_monitor_timer_ (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>diagnostics_update_timer_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_updater_ (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_diag_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>diagnostics_snapshot_timer_ (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#e","title":"e","text":"<ul> <li>error_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#h","title":"h","text":"<ul> <li>hw_interface_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#i","title":"i","text":"<ul> <li>interface_status_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_model (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>info_serial (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#k","title":"k","text":"<ul> <li>key_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_model (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_info_serial (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>key_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#m","title":"m","text":"<ul> <li>mtx_config_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>message_sep (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_diag (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>mtx_lidar_monitor (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>mtx_status (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#n","title":"n","text":"<ul> <li>nebula_points_pub_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>not_supported_message (nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adc_nf (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adc_stats (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_adctp_stat (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_ixe (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_position (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_gps_pps_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_laser_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_lock (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_phase (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_rpm (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_status_motor_state (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_vhv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_i_out (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_25v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_1_2v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_bot_pwr_v_in (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_ad_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_hv (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_lm20_temp (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_2_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_3_3v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_5v_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_raw (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>name_volt_temp_top_pwr_vccint (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#p","title":"p","text":"<ul> <li>pandar_scan_sub_ (nebula::ros::HesaiDriverRosWrapper)</li> <li>pandar_scan_pub_ (nebula::ros::HesaiHwInterfaceRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#s","title":"s","text":"<ul> <li>sensor_cfg_ptr_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> <li>sensor_configuration_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>set_param_res_ (nebula::ros::HesaiHwInterfaceRosWrapper, nebula::ros::HesaiHwMonitorRosWrapper, nebula::ros::VelodyneHwInterfaceRosWrapper, nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>setup_sensor (nebula::ros::NebulaHwInterfaceWrapperBase)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#t","title":"t","text":"<ul> <li>temperature_names (nebula::ros::HesaiHwMonitorRosWrapper)</li> <li>temperature_cold_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>temperature_hot_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#u","title":"u","text":"<ul> <li>use_advanced_diagnostics (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#v","title":"v","text":"<ul> <li>velodyne_scan_sub_ (nebula::ros::VelodyneDriverRosWrapper)</li> <li>velodyne_scan_pub_ (nebula::ros::VelodyneHwInterfaceRosWrapper)</li> <li>voltage_high_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> <li>voltage_low_message (nebula::ros::VelodyneHwMonitorRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_variables/#w","title":"w","text":"<ul> <li>wrapper_status_ (nebula::ros::HesaiDriverRosWrapper, nebula::ros::VelodyneDriverRosWrapper)</li> </ul>"},{"location":"nebula_ros/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"nebula_ros/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"nebula_ros/namespace_members/","title":"Namespace Members","text":""},{"location":"nebula_ros/namespace_members/#g","title":"g","text":"<ul> <li>get_param (nebula::ros)</li> </ul>"},{"location":"nebula_ros/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"nebula_ros/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_param (nebula::ros)</li> </ul>"},{"location":"nebula_ros/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"nebula_ros/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"nebula_ros/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"nebula_ros/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"nebula_ros/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"nebula_ros/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"nebula_ros/links/","title":"Nebula ROS","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}